<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FTIR UHMWPE Analyzer</title>
    
    <!-- CDN Libraries - External dependencies -->
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    
    <!-- Font Awesome for icons -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #764ba2;
            --accent-color: #f093fb;
            --success-color: #06d6a0;
            --warning-color: #ffd60a;
            --danger-color: #f72585;
            --info-color: #118ab2;
            --light-color: #f8fafc;
            --dark-color: #1a202c;
            --text-color: #2d3748;
            --border-color: #e2e8f0;
            --shadow-color: rgba(0, 0, 0, 0.08);
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #06d6a0 0%, #118ab2 100%);
            --gradient-warning: linear-gradient(135deg, #ffd60a 0%, #f77f00 100%);
            --gradient-danger: linear-gradient(135deg, #f72585 0%, #b5179e 100%);
            --gradient-light: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --border-radius: 16px;
            --border-radius-sm: 8px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--gradient-light);
            color: var(--text-color);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container-fluid {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header Styles */
        .header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            background: var(--gradient-primary);
            border-radius: var(--border-radius);
            position: relative;
            overflow: hidden;
        }

        .header-logo {
            display: block;
            max-height: 242px;
            max-width: 672px;
            width: 100%;
            height: auto;
            object-fit: contain;
            border-radius: 12px;
            background: transparent;
            padding: 0;
            margin: 0 auto 2.5rem auto;
            box-shadow: 
                0 15px 40px rgba(102, 126, 234, 0.3),
                0 8px 20px rgba(118, 75, 162, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 2px solid rgba(255, 255, 255, 0.5);
            position: relative;
            animation: logoGlow 3s ease-in-out infinite;
        }

        @keyframes logoGlow {
            0%, 100% {
                box-shadow: 
                    0 15px 40px rgba(102, 126, 234, 0.3),
                    0 8px 20px rgba(118, 75, 162, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8);
            }
            50% {
                box-shadow: 
                    0 18px 50px rgba(102, 126, 234, 0.4),
                    0 10px 30px rgba(118, 75, 162, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.9);
            }
        }

        .header-logo:hover {
            transform: scale(1.03) translateY(-4px);
            box-shadow: 
                0 20px 60px rgba(102, 126, 234, 0.5),
                0 12px 35px rgba(118, 75, 162, 0.4);
            animation: none;
        }

        .header h1 {
            display: block;
            text-align: center;
            margin-top: 0.5rem;
        }

        @media (max-width: 768px) {
            .header-logo {
                max-height: 150px;
                max-width: 100%;
                margin-bottom: 1.5rem;
                padding: 0;
            }
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255,255,255,0.1) 50%, transparent 70%);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .header h1 {
            font-weight: 700;
            margin-bottom: 0.5rem;
            font-size: 2.5rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            position: relative;
            z-index: 1;
        }

        .header .lead {
            font-size: 1.2rem;
            opacity: 0.95;
            position: relative;
            z-index: 1;
        }

        /* Card Styles */
        .card {
            margin-bottom: 2rem;
            border: none;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
            overflow: hidden;
            transition: var(--transition);
            background: white;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .card:hover {
            box-shadow: var(--shadow-xl);
            transform: translateY(-4px);
        }

        .card-header {
            background: var(--gradient-primary);
            color: white;
            font-weight: 600;
            padding: 1.5rem 2rem;
            border-bottom: none;
            position: relative;
            overflow: hidden;
        }

        .card-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s;
        }

        .card-header:hover::before {
            left: 100%;
        }

        .card-header h5, .card-header h6 {
            margin: 0;
            display: flex;
            align-items: center;
        }

        .card-body {
            padding: 1.5rem;
        }

        /* Plot Container Styles */
        .plot-container {
            height: 500px;
            background-color: white;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            margin-bottom: 1rem;
            position: relative;
            overflow: hidden;
        }

        .analysis-plot-container .plot-container {
            height: 400px;
        }

        /* Form Styles */
        .form-label {
            font-weight: 600;
            color: var(--dark-color);
            margin-bottom: 0.5rem;
        }

        .form-control, .form-select {
            border-radius: 0.5rem;
            border: 2px solid var(--border-color);
            padding: 0.75rem 1rem;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .form-control:focus, .form-select:focus {
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
            outline: none;
        }

        .form-control-sm {
            padding: 0.5rem 0.75rem;
            font-size: 0.85rem;
        }

        .form-check-input:checked {
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
        }

        .form-text {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 0.25rem;
        }

        /* Button Styles */
        .btn {
            border-radius: var(--border-radius-sm);
            font-weight: 600;
            padding: 1rem 2rem;
            transition: var(--transition);
            border: none;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.9rem;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn-primary {
            background: var(--gradient-primary);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            filter: brightness(1.1);
        }

        .btn-success {
            background: var(--gradient-success);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            filter: brightness(1.1);
        }

        .btn-warning {
            background: var(--gradient-warning);
            color: var(--dark-color);
            box-shadow: var(--shadow-md);
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            filter: brightness(1.1);
        }

        .btn-danger {
            background: var(--gradient-danger);
            color: white;
            box-shadow: var(--shadow-md);
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            filter: brightness(1.1);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--dark-color), #1a252f);
            border-color: var(--dark-color);
            color: white;
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #1a252f, #0f1419);
            border-color: #1a252f;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(44, 62, 80, 0.3);
        }

        .btn-outline-primary {
            color: var(--secondary-color);
            border-color: var(--secondary-color);
            background: transparent;
        }

        .btn-outline-primary:hover {
            background: var(--secondary-color);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-outline-secondary {
            color: var(--dark-color);
            border-color: var(--dark-color);
            background: transparent;
        }

        .btn-outline-secondary:hover {
            background: var(--dark-color);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(44, 62, 80, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color), #27ae60);
            border-color: var(--success-color);
        }

        .btn-success:hover {
            background: linear-gradient(135deg, #27ae60, #1e8449);
            border-color: #27ae60;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.3);
        }

        .btn-sm {
            padding: 0.4rem 0.8rem;
            font-size: 0.85rem;
        }

        /* Tab Styles */
        .nav-tabs {
            border-bottom: 3px solid var(--border-color);
            margin-bottom: 0;
        }

        .nav-tabs .nav-link {
            color: var(--dark-color);
            font-weight: 500;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            border: none;
            background-color: #f8f9fa;
            margin-right: 0.25rem;
            transition: all 0.2s ease;
            position: relative;
        }

        .nav-tabs .nav-link:hover {
            background-color: white;
            color: var(--secondary-color);
            transform: translateY(-2px);
        }

        .nav-tabs .nav-link.active {
            background-color: white;
            color: var(--secondary-color);
            font-weight: 600;
            border-bottom: 3px solid var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 -2px 8px rgba(0,0,0,0.1);
        }

        .tab-content {
            padding: 2rem;
            background-color: white;
            border-radius: 0 0.5rem 0.5rem 0.5rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            min-height: 200px ;
        }

        /* Loading Overlay */
        #loadingOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(3px);
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
        }

        /* Spectrum List Styles */
        .spectrum-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.5rem;
            background-color: #f8f9fa;
        }

        .spectrum-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: white;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .spectrum-item:hover {
            background-color: #f1f3f4;
            border-color: var(--secondary-color);
            transform: translateX(4px);
        }

        .spectrum-item.active {
            border-color: var(--secondary-color);
            background-color: #e3f2fd;
        }

        .spectrum-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .spectrum-color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px var(--border-color);
            flex-shrink: 0;
        }

        .spectrum-details {
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        }

        .spectrum-name {
            font-weight: 600;
            color: var(--dark-color);
            font-size: 0.9rem;
        }

        .spectrum-depth {
            font-size: 0.8rem;
            color: #6c757d;
        }

        .spectrum-controls {
            display: flex;
            gap: 0.25rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .spectrum-item:hover .spectrum-controls {
            opacity: 1;
        }

        /* Analysis Panel Styles */
        .analysis-panel {
            min-height: 500px;
        }

        .analysis-controls {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            height: fit-content;
        }

        .parameter-group {
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .parameter-group:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .analysis-actions {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border-color);
        }

        .analysis-results {
            background-color: white;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            min-height: 100px;
        }

        /* Results Table Styles */
        .table-responsive {
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .table {
            margin-bottom: 0;
        }

        .table th {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            color: white;
            font-weight: 600;
            border: none;
            padding: 1rem;
        }

        .table td {
            padding: 0.75rem 1rem;
            border-color: var(--border-color);
            vertical-align: middle;
        }

        .table-striped tbody tr:nth-of-type(odd) {
            background-color: #f8f9fa;
        }

        /* Depth Info Styles */
        .depth-info {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
        }

        .depth-info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .depth-info-item:last-child {
            border-bottom: none;
        }

        .depth-value {
            font-weight: 600;
            color: var(--secondary-color);
        }

        /* Processing Status Styles */
        #processingStatus {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.5rem;
            border-left: 4px solid var(--secondary-color);
        }

        /* Column Mapping Styles */
        .form-check-container {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            padding: 0.75rem;
            background-color: #f8f9fa;
        }

        .form-check {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
        }

        .form-check:last-child {
            margin-bottom: 0;
        }

        /* Summary Stats Styles */
        #summaryStats {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: #f8f9fa;
            border-radius: 0.5rem;
            border-left: 4px solid var(--secondary-color);
        }

        .stat-label {
            font-weight: 500;
            color: var(--dark-color);
        }

        /* Estilos mejorados para línea base */
        .selected-points-container {
            max-height: 200px;
            overflow-y: auto;
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            padding: 1rem;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }

        .selected-point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .selected-point-item:hover {
            border-color: var(--secondary-color);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.2);
            transform: translateY(-1px);
        }

        .selected-point-item:last-child {
            margin-bottom: 0;
        }

        .delete-point {
            cursor: pointer;
            color: var(--accent-color);
            transition: all 0.2s ease;
            padding: 0.25rem;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-point:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        /* Estilos mejorados para modales */
        .modal-content {
            border: none;
            border-radius: 1rem;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
        }

        .modal-header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            border-radius: 1rem 1rem 0 0;
            padding: 1.5rem 2rem;
        }

        .modal-title {
            font-weight: 700;
            font-size: 1.25rem;
        }

        .modal-body {
            padding: 2rem;
        }

        .modal-footer {
            background-color: #f8f9fa;
            border-radius: 0 0 1rem 1rem;
            padding: 1rem 2rem;
        }

        /* Depth Selection Styles */
        .depth-selector {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border: 2px solid #6c757d;
            border-radius: 0.75rem;
            padding: 1rem;
            width: 100%;
            min-width: 280px;
        }
        
        .depth-selector h6 {
            color: #495057;
            font-weight: 600;
            margin-bottom: 0.75rem;
        }
        
        .depths-checklist {
            background: white;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            width: 100%;
            min-width: 250px;
        }
        
        .depths-checklist .form-check {
            padding: 0.25rem 0.5rem;
            margin: 0;
            border-radius: 0.25rem;
            transition: background-color 0.15s ease;
        }
        
        .depths-checklist .form-check:hover {
            background-color: #f1f3f4;
        }
        
        .depths-checklist .form-check-input:checked + .depth-color-indicator + .form-check-label {
            font-weight: 500;
            color: #0d6efd;
        }
        
        .depth-color-indicator {
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px rgba(0,0,0,0.1);
        }
        
        .btn-group .btn-sm {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
        }

        /* Estilos mejorados para plots */
        .plot-container {
            border: 2px solid var(--border-color);
            border-radius: 0.75rem;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            position: relative;
        }

        .plot-container:hover {
            border-color: var(--secondary-color);
            box-shadow: 0 8px 25px rgba(52, 152, 219, 0.15);
        }

        /* Estilos mejorados para formularios */
        .form-control:focus,
        .form-select:focus {
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        /* Estilos para feedback de línea base */
        .baseline-selection-mode {
            border: 3px solid var(--warning-color) !important;
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.05), rgba(243, 156, 18, 0.1)) !important;
            position: relative;
        }

        .baseline-selection-mode::before {
            content: '🎯 Baseline selection mode active - Click on the graph';
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(243, 156, 18, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            z-index: 1000;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0.8; transform: scale(1); }
        }

        /* Estilos mejorados para badges y etiquetas */
        .badge {
            font-size: 0.8rem;
            padding: 0.5rem 0.75rem;
            border-radius: 1rem;
            font-weight: 600;
        }

        /* Estilos para puntos seleccionados en gráfico */
        .baseline-point-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--warning-color);
            border: 3px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            animation: pointPulse 1.5s ease-in-out;
        }

        @keyframes pointPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* Estilos mejorados para alertas y notificaciones */
        .alert {
            border: none;
            border-radius: 0.75rem;
            padding: 1rem 1.25rem;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .alert-info {
            background: linear-gradient(135deg, #d1ecf1, #bee5eb);
            color: #0c5460;
            border-left: 4px solid var(--info-color);
        }

        .alert-warning {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            color: #856404;
            border-left: 4px solid var(--warning-color);
        }

        .alert-success {
            background: linear-gradient(135deg, #d1e7dd, #a3cfbb);
            color: #0f5132;
            border-left: 4px solid var(--success-color);
        }

        .alert-danger {
            background: linear-gradient(135deg, #f8d7da, #f1aeb5);
            color: #721c24;
            border-left: 4px solid var(--accent-color);
        }

        /* Estilos mejorados para botones */
        .btn {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-radius: 0.5rem;
            padding: 0.75rem 1.5rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--secondary-color), #2980b9);
            border-color: var(--secondary-color);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success-color), #27ae60);
            border-color: var(--success-color);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning-color), #e67e22);
            border-color: var(--warning-color);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--accent-color), #c0392b);
            border-color: var(--accent-color);
        }

        .btn-info {
            background: linear-gradient(135deg, var(--info-color), #138496);
            border-color: var(--info-color);
        }

        /* Estilos responsivos mejorados */
        @media (max-width: 768px) {
            .container-fluid {
                padding: 1rem;
            }
            
            .modal-body {
                padding: 1rem;
            }
            
            .selected-points-container {
                max-height: 150px;
            }
            
            .btn {
                padding: 0.5rem 1rem;
                font-size: 0.85rem;
            }
        }

        .stat-value {
            font-weight: 600;
            color: var(--secondary-color);
            font-size: 1.1rem;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .container-fluid {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .header .lead {
                font-size: 1rem;
            }
            
            .card-body {
                padding: 1rem;
            }
            
            .tab-content {
                padding: 1rem;
            }
            
            .btn {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
            
            .analysis-controls {
                margin-top: 1rem;
            }
            
            .plot-container {
                height: 300px;
            }
        }

        @media (max-width: 576px) {
            .header {
                padding: 1.5rem 0;
            }
            
            .header h1 {
                font-size: 1.5rem;
            }
            
            .spectrum-item {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            
            .spectrum-controls {
                opacity: 1;
                align-self: flex-end;
            }
            
            .parameter-group .row .col-6 {
                margin-bottom: 0.5rem;
            }
        }

        /* Utility Classes */
        .text-gradient {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .shadow-sm {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
        }

        .shadow {
            box-shadow: 0 4px 6px rgba(0,0,0,0.1) !important;
        }

        .shadow-lg {
            box-shadow: 0 10px 15px rgba(0,0,0,0.1) !important;
        }

        .border-start-primary {
            border-left: 4px solid var(--secondary-color) !important;
        }

        .bg-gradient-primary {
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color)) !important;
        }

        /* Navigation Tabs */
        .nav-tabs {
            border-bottom: none;
            margin-bottom: 2rem;
        }

        .nav-tabs .nav-link {
            border: none;
            border-radius: var(--border-radius-sm);
            margin-right: 0.5rem;
            padding: 1rem 1.5rem;
            font-weight: 600;
            color: var(--text-color);
            background: white;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        .nav-tabs .nav-link:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            background: var(--light-color);
        }

        .nav-tabs .nav-link.active {
            background: var(--gradient-primary);
            color: white;
            box-shadow: var(--shadow-lg);
        }

        /* Import Mode Pills */
        .nav-pills .nav-link {
            border-radius: var(--border-radius-sm);
            margin-right: 0.5rem;
            padding: 0.75rem 1.25rem;
            font-weight: 600;
            color: var(--text-color);
            background: white;
            border: 2px solid var(--border-color);
            transition: var(--transition);
        }

        .nav-pills .nav-link:hover {
            border-color: var(--primary-color);
            transform: translateY(-1px);
            box-shadow: var(--shadow-sm);
        }

        .nav-pills .nav-link.active {
            background: var(--gradient-primary);
            color: white;
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }

       


        /* Multi-file Preview Styling */
        #multiFilePreview .list-group-item {
            border: none;
            padding: 0.5rem 0;
        }

        #multiFilePreview .badge {
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
        }

        /* Enhanced Notifications */
        .notification {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 9999;
            max-width: 400px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-xl);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .notification.success {
            background: var(--gradient-success);
            color: white;
        }

        .notification.warning {
            background: var(--gradient-warning);
            color: var(--dark-color);
        }

        .notification.error {
            background: var(--gradient-danger);
            color: white;
        }

        .notification.info {
            background: var(--gradient-primary);
            color: white;
        }

        /* Form Controls */
        .form-control {
            border-radius: var(--border-radius-sm);
            border: 2px solid var(--border-color);
            padding: 0.75rem 1rem;
            transition: var(--transition);
            background: white;
        }

        .form-control:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
            transform: translateY(-1px);
        }

        .form-select {
            border-radius: var(--border-radius-sm);
            border: 2px solid var(--border-color);
            padding: 0.75rem 1rem;
            transition: var(--transition);
            background: white;
        }

        .form-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.2rem rgba(102, 126, 234, 0.25);
        }

        /* Loading Overlay */
        #loadingOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 32, 44, 0.9);
            backdrop-filter: blur(10px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.3em;
        }

        /* Animation Classes */
        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        @keyframes slideInFromRight {
            0% { transform: translateX(100%); opacity: 0; }
            100% { transform: translateX(0); opacity: 1; }
        }

        /* Enhanced stat-item styling */
        .stat-item {
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-left: 4px solid var(--secondary-color);
            position: relative;
            overflow: hidden;
        }

        /* Deconvolution Tab Styles */
        .species-item {
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-bottom: 0.25rem;
            transition: all 0.2s ease;
            border: 1px solid #e9ecef;
            cursor: pointer;
        }

        .species-item:hover {
            background-color: #f8f9fa;
            border-color: var(--secondary-color);
            transform: translateX(3px);
        }

        .species-item.active {
            background-color: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }

        .species-name {
            font-size: 0.85rem;
            font-weight: 500;
        }

        .species-freq {
            font-size: 0.75rem;
            color: #6c757d;
        }

        .species-item.active .species-freq {
            color: rgba(255, 255, 255, 0.8);
        }

        /* Species Quantification Results */
        .species-result-item {
            padding: 0.5rem;
            border-radius: 0.25rem;
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
        }

        .species-name-small {
            font-size: 0.8rem;
            font-weight: 500;
        }

        .species-percentage {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--secondary-color);
        }

        .species-area-small {
            font-size: 0.7rem;
            color: #6c757d;
        }

        .color-indicator {
            flex-shrink: 0;
        }

        /* Deconvolution Results */
        .deconvolution-results {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-top: 1rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .deconvolution-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: #f8f9fa;
            border-radius: 0.25rem;
        }

        .fit-quality-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .fit-quality-excellent { background-color: #28a745; }
        .fit-quality-good { background-color: #ffc107; }
        .fit-quality-poor { background-color: #dc3545; }

        /* Depth Selector Enhancement */
        #deconvDepthSelect.border-success {
            border-color: #28a745 !important;
            box-shadow: 0 0 0 0.2rem rgba(40, 167, 69, 0.25);
        }

        #deconvDepthSelect.border-warning {
            border-color: #ffc107 !important;
            box-shadow: 0 0 0 0.2rem rgba(255, 193, 7, 0.25);
        }

        .depth-info {
            font-size: 0.85rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.25rem;
            background-color: #f8f9fa;
        }

        .depth-selected {
            background-color: #d4edda !important;
            border-color: #c3e6cb !important;
            color: #155724;
        }

        .stat-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .stat-item:hover::before {
            left: 100%;
        }

        .stat-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .stat-value.text-success {
            color: #28a745 !important;
            font-weight: 700;
        }

        .stat-value.text-info {
            color: #17a2b8 !important;
            font-weight: 700;
        }

        .stat-value.text-warning {
            color: #ffc107 !important;
            font-weight: 700;
        }

        /* Enhanced Quick Action Card */
        .quick-action-card {
            position: relative;
            overflow: hidden;
        }
        
        /* Enhanced Plot Container Responsiveness */
        .plot-container {
            width: 100% !important;
            min-height: 400px;
            overflow-x: auto;
        }
        
        /* Overview Plot Specific Styling */
        #overviewPlot {
            width: 100% !important;
            height: 500px !important;
            overflow-x: auto;
        }
        
        /* Analysis Plot Containers */
        .analysis-plot-container {
            width: 100%;
        }
        
        .analysis-plot-container .card-body {
            padding: 0;
        }
        
        /* Ensure all Plotly plots are responsive */
        .js-plotly-plot {
            width: 100% !important;
        }

        .quick-action-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            transform: scale(0);
            transition: transform 0.6s ease;
        }

        .quick-action-card:hover::before {
            transform: scale(1);
        }

        /* Results Display Enhancement */
        .analysis-results {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
        }

        .result-item {
            padding: 1rem;
            border-radius: var(--border-radius-sm);
            margin-bottom: 0.5rem;
            background: white;
            box-shadow: var(--shadow-sm);
            transition: var(--transition);
        }

        .result-item:hover {
            transform: translateX(5px);
            box-shadow: var(--shadow-md);
        }

        /* Enhanced Auto Analysis Button */
        #fullAutoAnalysisBtn {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        #fullAutoAnalysisBtn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(0,0,0,0.15);
        }

        #fullAutoAnalysisBtn:hover .progress-bar-overlay {
            left: 100%;
        }

        #fullAutoAnalysisBtn:disabled {
            opacity: 0.8;
            cursor: not-allowed;
            transform: none;
        }

        #fullAutoAnalysisBtn .btn-content {
            position: relative;
            z-index: 1;
        }

        /* Progress indicator animation */
        @keyframes progress-sweep {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .btn-analyzing .progress-bar-overlay {
            animation: progress-sweep 2s infinite;
        }
        .tab-pane:not(.show.active) {
  display: none !important;
}

        /* Custom File Input Styles - English Labels */
        .custom-file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .custom-file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            z-index: 2;
        }

        .custom-file-label {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0;
            border: 2px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .custom-file-label:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .custom-file-label .browse-btn {
            background: var(--gradient-primary);
            color: white;
            padding: 0.85rem 1.5rem;
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            white-space: nowrap;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .custom-file-label .browse-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }

        .custom-file-label:hover .browse-btn::before {
            left: 100%;
        }

        .custom-file-label .browse-btn i {
            font-size: 1rem;
        }

        .custom-file-label .file-name {
            color: #6c757d;
            font-style: italic;
            padding: 0 1rem;
            flex: 1;
            font-size: 0.9rem;
        }

        .custom-file-label .file-name.has-file {
            color: var(--text-color);
            font-style: normal;
            font-weight: 500;
        }

        /* Main tab button for Carbonyl Deconvolution (RED) */
        #deconvolution-tab {
            color: #e74c3c;
        }
        
        #deconvolution-tab:hover {
            color: #c0392b;
            border-color: #e74c3c;
        }
        
        #deconvolution-tab.active {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white !important;
            border-color: #e74c3c;
        }

        /* Main tab button for Adsorbed Species (GREEN) */
        #adsorbed-species-tab {
            color: #27ae60;
        }
        
        #adsorbed-species-tab:hover {
            color: #229954;
            border-color: #27ae60;
        }
        
        #adsorbed-species-tab.active {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white !important;
            border-color: #27ae60;
        }

        /* Custom sub-tab colors for Carbonyl Deconvolution (RED) */
        #deconvolutionSubTabs .nav-link {
            color: #e74c3c;
            border-color: transparent;
        }
        
        #deconvolutionSubTabs .nav-link:hover {
            color: #c0392b;
            border-color: #e74c3c;
        }
        
        #deconvolutionSubTabs .nav-link.active {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white !important;
            border-color: #e74c3c;
        }

        /* Custom sub-tab colors for Adsorbed Species (GREEN) */
        #adsorbedSpeciesSubTabs .nav-link {
            color: #27ae60;
            border-color: transparent;
        }
        
        #adsorbedSpeciesSubTabs .nav-link:hover {
            color: #229954;
            border-color: #27ae60;
        }
        
        #adsorbedSpeciesSubTabs .nav-link.active {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white !important;
            border-color: #27ae60;
        }

    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loadingOverlay">
        <div class="text-center">
            <div class="spinner-border text-light" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <div class="mt-3 text-light">
                <h5 id="loadingText">Processing...</h5>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <!-- Logo -->
        <img src="logo-gbm.png" alt="GBM I3A Logo" class="header-logo">
        
        <!-- Header -->
        <div class="header">
            <h1>FTIR UHMWPE Analyzer</h1>
            <p class="lead">Professional Oxidation, Crystallinity and TVI Analysis at Multiple Depths<br><strong>by Biomaterials Group of University of Zaragoza</strong></p>
        </div>

        <!-- File Import Section -->
        <div class="row mb-4">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-file-upload me-2"></i>Data Import</h5>
                    </div>
                    <div class="card-body">
                        <!-- Import Mode Selection -->
                        <div class="row mb-3">
                            <div class="col-12">
                                <div class="nav nav-pills" id="importModeNav" role="tablist">
                                    <button class="nav-link active" id="single-file-tab" data-bs-toggle="pill" 
                                            data-bs-target="#single-file" type="button" role="tab"
                                            title="Import a single file containing multiple depth measurements (Excel, CSV, etc.)" data-bs-toggle-extra="tooltip" data-bs-placement="top">
                                        <i class="fas fa-file me-2"></i>Single File (Multi-depth)
                                    </button>
                                    <button class="nav-link" id="multi-files-tab" data-bs-toggle="pill" 
                                            data-bs-target="#multi-files" type="button" role="tab"
                                            title="Import multiple .dpt files, one for each depth measurement" data-bs-toggle-extra="tooltip" data-bs-placement="top">
                                        <i class="fas fa-files me-2"></i>Multiple Depth Files
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="tab-content" id="importModeContent">
                            <!-- Single File Mode -->
                            <div class="tab-pane fade show active" id="single-file" role="tabpanel">
                                <div class="row">
                                    <div class="col-md-8">
                                        <label class="form-label">
                                            Select FTIR Data File (.xlsx, .dpt, .spc, .txt, .csv, .0)
                                        </label>
                                        <div class="custom-file-input-wrapper">
                                            <input type="file" id="fileInput" 
                                                   accept=".xlsx,.dpt,.spc,.txt,.csv,.0">
                                            <div class="custom-file-label" id="fileInputLabel">
                                                <span class="browse-btn">
                                                    <i class="fas fa-folder-open"></i>
                                                    Choose File
                                                </span>
                                                <span class="file-name" id="fileInputName">No file chosen</span>
                                            </div>
                                        </div>
                                        <div class="form-text">
                                            File must contain a frequency column and transmittance columns for different depths
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label">Import Options</label>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="autoDetectColumns" checked>
                                            <label class="form-check-label" for="autoDetectColumns">
                                                Auto-detect columns
                                            </label>
                                        </div>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="skipFirstRow" checked>
                                            <label class="form-check-label" for="skipFirstRow">
                                                Skip header row
                                            </label>
                                        </div>
                                    </div>
                                </div>
                                <div class="row mt-3" id="columnMapping" style="display: none;">
                                    <div class="col-12">
                                        <h6>Column Mapping</h6>
                                        <div class="row">
                                            <div class="col-md-3">
                                                <label class="form-label">Frequency Column</label>
                                                <select class="form-select" id="frequencyColumn">
                                                    <option value="">Select column...</option>
                                                </select>
                                            </div>
                                            <div class="col-md-9">
                                                <label class="form-label">Depth Columns (select multiple)</label>
                                                <div id="depthColumns" class="form-check-container">
                                                    <!-- Dynamic depth column checkboxes -->
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Multiple Files Mode -->
                            <div class="tab-pane fade" id="multi-files" role="tabpanel">
                                <div class="row">
                                    <div class="col-md-8">
                                        <label class="form-label">
                                            Select Multiple Depth Files (.dpt)
                                        </label>
                                        <div class="custom-file-input-wrapper">
                                            <input type="file" id="multiFileInput" 
                                                   accept=".dpt" multiple>
                                            <div class="custom-file-label" id="multiFileInputLabel">
                                                <span class="browse-btn">
                                                    <i class="fas fa-folder-open"></i>
                                                    Choose Files
                                                </span>
                                                <span class="file-name" id="multiFileInputName">No files chosen</span>
                                            </div>
                                        </div>
                                        <div class="form-text">
                                            Select multiple .dpt files with naming convention: SAMPLE_NAME_01, SAMPLE_NAME_02, etc.
                                            <br>Where 01 = 100μm, 02 = 200μm, 03 = 300μm, etc.
                                        </div>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label">Depth Configuration</label>
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="autoDepthDetection" checked>
                                            <label class="form-check-label" for="autoDepthDetection">
                                                Auto-detect depth from filename
                                            </label>
                                        </div>
                                        <div class="form-text">
                                            Files will be ordered by depth number in filename
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- File List Preview -->
                                <div class="row mt-3" id="multiFilePreview" style="display: none;">
                                    <div class="col-12">
                                        <h6>Selected Files Preview</h6>
                                        <div class="alert alert-info">
                                            <div id="multiFileList" class="list-group list-group-flush">
                                                <!-- Dynamic file list -->
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="row mt-3">
                            <div class="col-12">
                                <button class="btn btn-primary" id="loadDataBtn" disabled
                                        data-bs-toggle="tooltip" data-bs-placement="top" 
                                        title="Load and process the selected FTIR data file(s)">
                                    <i class="fas fa-play me-2"></i>Load Data
                                </button>
                                <button class="btn btn-secondary ms-2" id="clearDataBtn" disabled
                                        data-bs-toggle="tooltip" data-bs-placement="top" 
                                        title="Remove all loaded data and reset the application">
                                    <i class="fas fa-trash me-2"></i>Clear All
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Spectrum Overview Section -->
        <div class="row mb-4" id="spectrumOverview" style="display: none;">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5><i class="fas fa-eye me-2"></i>Spectra Overview</h5>
                        <div>
                            <button class="btn btn-outline-primary btn-sm" id="toggleSpectraBtn"
                                    data-bs-toggle="tooltip" data-bs-placement="top" 
                                    title="Toggle between overlaid and individual spectrum views">
                                <i class="fas fa-layer-group me-1"></i>Toggle Overlay
                            </button>
                            <button class="btn btn-outline-secondary btn-sm" id="resetZoomBtn"
                                    data-bs-toggle="tooltip" data-bs-placement="top" 
                                    title="Reset chart zoom to show full spectral range">
                                <i class="fas fa-search-minus me-1"></i>Reset Zoom
                            </button>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="overviewPlot" class="plot-container" style="width: 100%; height: 500px; overflow-x: auto;"></div>
                        <div class="row mt-3">
                            <div class="col-md-6">
                                <h6>Loaded Spectra</h6>
                                <div id="spectrumList" class="spectrum-list">
                                    <!-- Dynamic spectrum list -->
                                </div>
                            </div>
                            <div class="col-md-6">
                                <h6>Depth Information</h6>
                                <div id="depthInfo" class="depth-info">
                                    <p class="text-muted">No data loaded</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Processing Controls -->
        <div class="row mb-4" id="processingControls" style="display: none;">
            <div class="col-12">
                <div class="card">
                    <div class="card-header">
                        <h5><i class="fas fa-cogs me-2"></i>Data Processing</h5>
                    </div>
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-6">
                                <h6>1. Offset Correction</h6>
                                <p class="text-muted small">Correct transmittance to zero baseline</p>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-primary" id="autoOffsetBtn"
                                            data-bs-toggle="tooltip" data-bs-placement="top" 
                                            title="Automatically calculate and apply offset correction using 4000 cm⁻¹ reference">
                                        <i class="fas fa-magic me-1"></i>Auto Correction
                                    </button>
                                    <button class="btn btn-outline-primary" id="manualOffsetBtn"
                                            data-bs-toggle="tooltip" data-bs-placement="top" 
                                            title="Manually adjust offset values for each depth spectrum">
                                        <i class="fas fa-hand-pointer me-1"></i>Manual Mode
                                    </button>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <h6>Processing Status</h6>
                                <div id="processingStatus">
                                    <div class="d-flex align-items-center">
                                        <i class="fas fa-circle text-secondary me-2"></i>
                                        <span>Ready to process</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analysis Tabs -->
        <div class="row" id="analysisSection" style="display: none;">
            <div class="col-12">
                <ul class="nav nav-tabs" id="mainAnalysisTab" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="index-analysis-tab" data-bs-toggle="tab" 
                                data-bs-target="#index-analysis" type="button" role="tab">
                            <i class="fas fa-chart-line me-2"></i>Index Analysis
                        </button>
                    </li>

                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="deconvolution-tab" data-bs-toggle="tab" 
                                data-bs-target="#deconvolution" type="button" role="tab">
                            <i class="fas fa-flask me-2"></i>Carbonyl Deconvolution
                        </button>
                    </li>

                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="adsorbed-species-tab" data-bs-toggle="tab" 
                                data-bs-target="#adsorbed-species" type="button" role="tab">
                            <i class="fas fa-atom me-2"></i>Adsorbed Species Quantification
                        </button>
                    </li>
                </ul>
                

                <div class="tab-content" id="mainAnalysisTabContent">
                    <!-- INDEX ANALYSIS TAB -->
                    <div class="tab-pane fade show active" id="index-analysis" role="tabpanel">
                        
                        <!-- Full Automatic Analysis Button Section -->
                        <div class="row mb-4 mt-4">
                            <div class="col-12">
                                <div class="card quick-action-card" style="background: var(--gradient-success); border: none;">
                                    <div class="card-body text-center py-4">
                                        <h4 class="text-white mb-3">
                                            <i class="fas fa-magic me-2"></i>Full Automatic Analysis
                                        </h4>
                                        <p class="text-white mb-4 opacity-90">
                                            Automatically executes: offset calculation → baseline → oxidation, crystallinity and TVI analysis
                                        </p>
                                        <button id="fullAutoAnalysisBtn" class="btn btn-light btn-lg px-5 py-3 position-relative" 
                                                style="font-size: 1.1rem; font-weight: 700; box-shadow: var(--shadow-lg); overflow: hidden;"
                                                data-bs-toggle="tooltip" data-bs-placement="bottom" 
                                                title="Automatically processes all spectra: offset calculation, baseline correction, and oxidation/crystallinity/TVI analysis">
                                            <span class="btn-content">
                                                <i class="fas fa-play me-2"></i>Start Complete Analysis
                                            </span>
                                            <div class="progress-bar-overlay" style="position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: linear-gradient(90deg, rgba(255,255,255,0.2), rgba(255,255,255,0.4), rgba(255,255,255,0.2)); transition: left 0.3s ease;"></div>
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Index Analysis Sub-tabs -->
                        <ul class="nav nav-tabs mb-3" id="indexAnalysisSubTabs" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="oxidation-tab" data-bs-toggle="tab" 
                                        data-bs-target="#oxidation" type="button" role="tab">
                                    <i class="fas fa-fire me-2"></i>Oxidation Analysis
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="crystallinity-tab" data-bs-toggle="tab" 
                                        data-bs-target="#crystallinity" type="button" role="tab">
                                    <i class="fas fa-gem me-2"></i>Crystallinity Analysis
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="tvi-tab" data-bs-toggle="tab" 
                                        data-bs-target="#tvi" type="button" role="tab">
                                    <i class="fas fa-wave-square me-2"></i>TVI Analysis
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="reports-tab" data-bs-toggle="tab" 
                                        data-bs-target="#reports" type="button" role="tab">
                                    <i class="fas fa-chart-bar me-2"></i>Reports
                                </button>
                            </li>
                        </ul>

                        <div class="tab-content" id="indexAnalysisTabContent">
                    <!-- Oxidation Analysis Tab -->
                    <div class="tab-pane fade show active" id="oxidation" role="tabpanel">
                        <div class="analysis-panel" data-analysis="oxidation">
                            <div class="row">
                                <div class="col-md-9">
                                    <div class="analysis-plot-container">
                                        <!-- Reference Interval Plot -->
                                        <div class="row mb-4">
                                            <div class="col-12">
                                                <div class="card" style="border: 2px solid #43e97b;">
                                                    <div class="card-header" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white;">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-anchor me-2"></i>Reference Interval
                                                        </h6>
                                                    </div>
                                                    <div class="card-body p-0">
                                                        <div id="oxidationReferencePlot" style="height: 400px;"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Interest Interval Plot -->
                                        <div class="row">
                                            <div class="col-12">
                                                <div class="card" style="border: 2px solid #f093fb;">
                                                    <div class="card-header" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-bullseye me-2"></i>Interest Interval
                                                        </h6>
                                                    </div>
                                                    <div class="card-body p-0">
                                                        <div id="oxidationInterestPlot" style="height: 400px;"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Results Section -->
                                        <div class="row mt-4">
                                            <div class="col-12">
                                                <div class="card">
                                                    <div class="card-header">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-chart-bar me-2"></i>Oxidation Analysis Results
                                                        </h6>
                                                    </div>
                                                    <div class="card-body">
                                                        <div class="analysis-results" id="oxidationResults">
                                                            <p class="text-muted">No analysis results yet. Click "Analyze All Automatically" to begin.</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="analysis-controls">
                                        <!-- Depth Selection Control -->
                                        <div class="depth-selector mb-4">
                                            <h6><i class="fas fa-layer-group me-2"></i>Depth Selection</h6>
                                            <div class="depth-controls-container">
                                                <div class="mb-3">
                                                    <div class="btn-group d-flex" role="group">
                                                        <button type="button" class="btn btn-outline-primary btn-sm" onclick="selectAllDepths('oxidation')">
                                                            <i class="fas fa-check-double"></i> All
                                                        </button>
                                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="selectNoneDepths('oxidation')">
                                                            <i class="fas fa-times"></i> None
                                                        </button>
                                                        <button type="button" class="btn btn-outline-info btn-sm" onclick="selectEveryNDepths('oxidation', 5)">
                                                            <i class="fas fa-th"></i> Every 5th
                                                        </button>
                                                    </div>
                                                </div>
                                                <div class="depths-checklist" id="oxidationDepthsList" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 0.375rem; padding: 0.75rem; background: white; width: 100%;">
                                                    <p class="text-muted small mb-0">Load data to see depths</p>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <h6>Analysis Parameters</h6>
                                        <div class="parameter-group">
                                            <label class="form-label">Interest Peak (cm⁻¹)</label>
                                            <div class="row">
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="oxidationInterestMin" value="1680" step="1">
                                                    <label class="form-text">Min</label>
                                                </div>
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="oxidationInterestMax" value="1850" step="1">
                                                    <label class="form-text">Max</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="parameter-group">
                                            <label class="form-label">Reference Peak (cm⁻¹)</label>
                                            <div class="row">
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="oxidationRefMin" value="1330" step="1">
                                                    <label class="form-text">Min</label>
                                                </div>
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="oxidationRefMax" value="1400" step="1">
                                                    <label class="form-text">Max</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="analysis-actions">
                                            <button class="btn btn-primary w-100 mb-2" id="autoAnalyzeOxidation">
                                                <i class="fas fa-play me-1"></i>Analyze All Automatically
                                            </button>
                                            <button class="btn btn-outline-primary w-100 mb-2" id="manualBaselineOxidation">
                                                <i class="fas fa-hand-pointer me-1"></i>Manual Baseline
                                            </button>
                                            <button class="btn btn-outline-secondary w-100" id="resetOxidationAnalysis">
                                                <i class="fas fa-undo me-1"></i>Reset
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    

                    <!-- Crystallinity Analysis Tab -->
                    <div class="tab-pane fade" id="crystallinity" role="tabpanel">
                        <div class="analysis-panel" data-analysis="crystallinity">
                            <div class="row">
                                <div class="col-md-9">
                                    <div class="analysis-plot-container">
                                        <!-- Reference Interval Plot -->
                                        <div class="row mb-4">
                                            <div class="col-12">
                                                <div class="card" style="border: 2px solid #43e97b;">
                                                    <div class="card-header" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white;">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-anchor me-2"></i>Reference Interval
                                                        </h6>
                                                    </div>
                                                    <div class="card-body p-0">
                                                        <div id="crystallinityReferencePlot" style="height: 400px;"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Interest Interval Plot -->
                                        <div class="row">
                                            <div class="col-12">
                                                <div class="card" style="border: 2px solid #f093fb;">
                                                    <div class="card-header" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-bullseye me-2"></i>Interest Interval
                                                        </h6>
                                                    </div>
                                                    <div class="card-body p-0">
                                                        <div id="crystallinityInterestPlot" style="height: 400px;"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Results Section -->
                                        <div class="row mt-4">
                                            <div class="col-12">
                                                <div class="card">
                                                    <div class="card-header">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-chart-bar me-2"></i>Crystallinity Analysis Results
                                                        </h6>
                                                    </div>
                                                    <div class="card-body">
                                                        <div class="analysis-results" id="crystallinityResults">
                                                            <p class="text-muted">No analysis results yet. Click "Analyze All Automatically" to begin.</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="analysis-controls">
                                        <!-- Depth Selection Control -->
                                        <div class="depth-selector mb-4">
                                            <h6><i class="fas fa-layer-group me-2"></i>Depth Selection</h6>
                                            <div class="depth-controls-container">
                                                <div class="mb-3">
                                                    <div class="btn-group d-flex" role="group">
                                                        <button type="button" class="btn btn-outline-primary btn-sm" onclick="selectAllDepths('crystallinity')">
                                                            <i class="fas fa-check-double"></i> All
                                                        </button>
                                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="selectNoneDepths('crystallinity')">
                                                            <i class="fas fa-times"></i> None
                                                        </button>
                                                        <button type="button" class="btn btn-outline-info btn-sm" onclick="selectEveryNDepths('crystallinity', 5)">
                                                            <i class="fas fa-th"></i> Every 5th
                                                        </button>
                                                    </div>
                                                </div>
                                                <div class="depths-checklist" id="crystallinityDepthsList" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 0.375rem; padding: 0.75rem; background: white; width: 100%;">
                                                    <p class="text-muted small mb-0">Load data to see depths</p>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <h6>Analysis Parameters</h6>
                                        <div class="parameter-group">
                                            <label class="form-label">Crystallinity Peak (cm⁻¹)</label>
                                            <div class="row">
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="crystallinityInterestMin" value="1850" step="1">
                                                    <label class="form-text">Min</label>
                                                </div>
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="crystallinityInterestMax" value="1950" step="1">
                                                    <label class="form-text">Max</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="parameter-group">
                                            <label class="form-label">Total Peak (Crystalline + Amorphous) (cm⁻¹)</label>
                                            <div class="row">
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="crystallinityRefMin" value="1275" step="1">
                                                    <label class="form-text">Min</label>
                                                </div>
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="crystallinityRefMax" value="1330" step="1">
                                                    <label class="form-text">Max</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="analysis-actions">
                                            <button class="btn btn-primary w-100 mb-2" id="autoAnalyzeCrystallinity">
                                                <i class="fas fa-play me-1"></i>Analyze All Automatically
                                            </button>
                                            <button class="btn btn-outline-primary w-100 mb-2" id="manualBaselineCrystallinity">
                                                <i class="fas fa-hand-pointer me-1"></i>Manual Baseline
                                            </button>
                                            <button class="btn btn-outline-secondary w-100" id="resetCrystallinityAnalysis">
                                                <i class="fas fa-undo me-1"></i>Reset
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- TVI Analysis Tab -->
                    <div class="tab-pane fade" id="tvi" role="tabpanel">
                        <div class="analysis-panel" data-analysis="tvi">
                            <div class="row">
                                <div class="col-md-9">
                                    <div class="analysis-plot-container">
                                        <!-- Reference Interval Plot -->
                                        <div class="row mb-4">
                                            <div class="col-12">
                                                <div class="card" style="border: 2px solid #43e97b;">
                                                    <div class="card-header" style="background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%); color: white;">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-anchor me-2"></i>Reference Interval
                                                        </h6>
                                                    </div>
                                                    <div class="card-body p-0">
                                                        <div id="tviReferencePlot" style="height: 400px;"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Interest Interval Plot -->
                                        <div class="row">
                                            <div class="col-12">
                                                <div class="card" style="border: 2px solid #f093fb;">
                                                    <div class="card-header" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white;">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-bullseye me-2"></i>Interest Interval
                                                        </h6>
                                                    </div>
                                                    <div class="card-body p-0">
                                                        <div id="tviInterestPlot" style="height: 400px;"></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Results Section -->
                                        <div class="row mt-4">
                                            <div class="col-12">
                                                <div class="card">
                                                    <div class="card-header">
                                                        <h6 class="mb-0">
                                                            <i class="fas fa-chart-bar me-2"></i>TVI Analysis Results
                                                        </h6>
                                                    </div>
                                                    <div class="card-body">
                                                        <div class="analysis-results" id="tviResults">
                                                            <p class="text-muted">No analysis results yet. Click "Analyze All Automatically" to begin.</p>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-3">
                                    <div class="analysis-controls">
                                        <!-- Depth Selection Control -->
                                        <div class="depth-selector mb-4">
                                            <h6><i class="fas fa-layer-group me-2"></i>Depth Selection</h6>
                                            <div class="depth-controls-container">
                                                <div class="mb-3">
                                                    <div class="btn-group d-flex" role="group">
                                                        <button type="button" class="btn btn-outline-primary btn-sm" onclick="selectAllDepths('tvi')">
                                                            <i class="fas fa-check-double"></i> All
                                                        </button>
                                                        <button type="button" class="btn btn-outline-secondary btn-sm" onclick="selectNoneDepths('tvi')">
                                                            <i class="fas fa-times"></i> None
                                                        </button>
                                                        <button type="button" class="btn btn-outline-info btn-sm" onclick="selectEveryNDepths('tvi', 5)">
                                                            <i class="fas fa-th"></i> Every 5th
                                                        </button>
                                                    </div>
                                                </div>
                                                <div class="depths-checklist" id="tviDepthsList" style="max-height: 250px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 0.375rem; padding: 0.75rem; background: white; width: 100%;">
                                                    <p class="text-muted small mb-0">Load data to see depths</p>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <h6>Analysis Parameters</h6>
                                        <div class="parameter-group">
                                            <label class="form-label">TVI Peak (cm⁻¹)</label>
                                            <div class="row">
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="tviInterestMin" value="950" step="1">
                                                    <label class="form-text">Min</label>
                                                </div>
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="tviInterestMax" value="980" step="1">
                                                    <label class="form-text">Max</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="parameter-group">
                                            <label class="form-label">Reference Peak (cm⁻¹)</label>
                                            <div class="row">
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="tviRefMin" value="1330" step="1">
                                                    <label class="form-text">Min</label>
                                                </div>
                                                <div class="col-6">
                                                    <input type="number" class="form-control form-control-sm" 
                                                           id="tviRefMax" value="1400" step="1">
                                                    <label class="form-text">Max</label>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="analysis-actions">
                                            <button class="btn btn-primary w-100 mb-2" id="autoAnalyzeTvi">
                                                <i class="fas fa-play me-1"></i>Analyze All Automatically
                                            </button>
                                            <button class="btn btn-outline-primary w-100 mb-2" id="manualBaselineTvi">
                                                <i class="fas fa-hand-pointer me-1"></i>Manual Baseline
                                            </button>
                                            <button class="btn btn-outline-secondary w-100" id="resetTviAnalysis">
                                                <i class="fas fa-undo me-1"></i>Reset
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Reports Tab -->
                    <!-- Reports Tab -->
                    <div class="tab-pane fade" id="reports" role="tabpanel">
                        <div class="row">
                            <div class="col-12 mb-4">
                                <div class="d-flex justify-content-between align-items-center">
                                    <h4>
                                        <i class="fas fa-chart-bar me-3"></i>Analysis Reports
                                    </h4>
                                    <div>
                                        <button class="btn btn-success" id="generateReportsBtn">
                                            <i class="fas fa-sync me-2"></i>Update Reports
                                        </button>
                                        <button class="btn btn-outline-primary" id="exportReportsBtn">
                                            <i class="fas fa-download me-2"></i>Export Data
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="row">
                            <!-- Summary Statistics -->
                            <div class="col-lg-6 mb-4">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-calculator me-2"></i>Summary Statistics</h6>
                                    </div>
                                    <div class="card-body">
                                        <div id="summaryStats">
                                            <p class="text-muted">Run analysis to view statistics</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Depth Profile Plot -->
                            <div class="col-lg-6 mb-4">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-chart-line me-2"></i>Depth Profile</h6>
                                    </div>
                                    <div class="card-body p-0">
                                        <div id="depthProfilePlot" class="plot-container"></div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Results Table -->
                        <div class="row">
                            <div class="col-12">
                                <div class="card">
                                    <div class="card-header">
                                        <h6><i class="fas fa-table me-2"></i>Detailed Results Table</h6>
                                        <small class="text-muted" id="sampleFileInfo">No file loaded</small>
                                    </div>
                                    <div class="card-body">
                                        <div class="table-responsive">
                                            <table class="table table-striped" id="resultsTable">
                                                <thead>
                                                    <tr>
                                                        <th>Depth</th>
                                                        <th>Oxidation Index</th>
                                                        <th>Crystallinity Index</th>
                                                        <th>TVI Index</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td colspan="4" class="text-center text-muted">
                                                            No analysis results available
                                                        </td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                        </div>
                    </div>
                    <!-- END Index Analysis Tab -->

                    <!-- CARBONYL DECONVOLUTION TAB (Moved from original position) -->
                    <div class="tab-pane fade" id="deconvolution" role="tabpanel">
                        <div class="row mb-4 mt-4">
                            <div class="col-12">
                                <div class="card" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); border: none;">
                                    <div class="card-body text-center py-4">
                                        <h4 class="text-white mb-3">
                                            <i class="fas fa-flask me-2"></i>Carbonyl Deconvolution
                                        </h4>
                                        <p class="text-white mb-0 opacity-90">
                                            Analysis of carbonyl species in oxidized UHMWPE using curve fitting
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="analysis-panel" data-analysis="deconvolution">
                            <!-- Sub-tabs for Deconvolution -->
                            <ul class="nav nav-tabs mb-3" id="deconvolutionSubTabs" role="tablist">
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link active" id="individual-deconv-tab" data-bs-toggle="tab" 
                                            data-bs-target="#individual-deconv" type="button" role="tab">
                                        <i class="fas fa-chart-line me-2"></i>Individual Deconvolution
                                    </button>
                                </li>
                                <li class="nav-item" role="presentation">
                                    <button class="nav-link" id="multiple-deconv-tab" data-bs-toggle="tab" 
                                            data-bs-target="#multiple-deconv" type="button" role="tab">
                                        <i class="fas fa-layer-group me-2"></i>Multiple Deconvolution
                                    </button>
                                </li>
                            </ul>

                            <div class="tab-content" id="deconvolutionSubTabsContent">
                                <!-- Individual Deconvolution Tab -->
                                <div class="tab-pane fade show active" id="individual-deconv" role="tabpanel">
                            <div class="row">
                                <div class="col-md-8">
                                    <div class="analysis-plot-container">
                                        <!-- Derivatives Plot -->
                                        <div class="card mb-4" style="border: 2px solid #9b59b6;">
                                            <div class="card-header" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white;">
                                                <h6 class="mb-0">
                                                    <i class="fas fa-chart-line me-2"></i>Derivative Analysis (1800-1650 cm⁻¹)
                                                </h6>
                                            </div>
                                            <div class="card-body p-0">
                                                <div id="deconvolutionDerivativesPlot" class="plot-container" style="height: 300px;"></div>
                                            </div>
                                        </div>
                                        
                                        <!-- Deconvolution Plot -->
                                        <div class="card" style="border: 2px solid #e74c3c;">
                                            <div class="card-header" style="background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: white;">
                                                <h6 class="mb-0">
                                                    <i class="fas fa-wave-square me-2"></i>Carbonyl Deconvolution & Individual Species
                                                </h6>
                                            </div>
                                            <div class="card-body p-0">
                                                <div id="deconvolutionMainPlot" class="plot-container" style="height: 400px;"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-4">
                                    <div class="analysis-controls">
                                        <!-- Deconvolution Controls -->
                                        <div class="card mb-4">
                                            <div class="card-header">
                                                <h6><i class="fas fa-cogs me-2"></i>Deconvolution Controls</h6>
                                            </div>
                                            <div class="card-body">
                                                <div class="mb-3">
                                                    <label class="form-label">Select Depth for Deconvolution</label>
                                                    <select class="form-select" id="deconvDepthSelect">
                                                        <option value="">Choose depth to analyze...</option>
                                                    </select>
                                                    <div class="form-text">Choose which depth spectrum to deconvolute</div>
                                                    <div id="depthSelectionInfo" class="depth-info" style="display: none;">
                                                        <i class="fas fa-info-circle me-1"></i>
                                                        <span id="depthInfoText">Select a depth to see spectrum information</span>
                                                    </div>
                                                </div>
                                                
                                                <div class="mb-3">
                                                    <label class="form-label">Spectral Region (cm⁻¹)</label>
                                                    <div class="row">
                                                        <div class="col-6">
                                                            <input type="number" class="form-control" id="deconvMinFreq" 
                                                                   value="1650" min="1500" max="1700" step="1">
                                                        </div>
                                                        <div class="col-6">
                                                            <input type="number" class="form-control" id="deconvMaxFreq" 
                                                                   value="1800" min="1750" max="1900" step="1">
                                                        </div>
                                                    </div>
                                                </div>
                                                
                                                <div class="mb-3">
                                                    <label class="form-label">Thickness Reference Band (cm⁻¹)</label>
                                                    <input type="number" class="form-control" id="deconvRefBand" 
                                                           value="2020" min="1950" max="2050" step="1">
                                                </div>
                                                
                                                <div class="mb-3">
                                                    <label class="form-label">Baseline Correction</label>
                                                    <select class="form-select" id="deconvBaselineType">
                                                        <option value="linear">Linear (endpoints)</option>
                                                        <option value="automatic" selected>Automatic (identical to oxidation analysis)</option>
                                                        <option value="subtract_intact">Subtract Intact Sample</option>
                                                    </select>
                                                    <div class="form-text">Automatic uses identical baseline method as oxidation analysis. Peak positions can shift ±2 cm⁻¹ during optimization.</div>
                                                </div>
                                                
                                                <div class="d-grid gap-2">
                                                    <button class="btn btn-primary" id="performDeconvolutionBtn">
                                                        <i class="fas fa-play me-2"></i>Perform Deconvolution
                                                    </button>
                                                    <button class="btn btn-outline-secondary" id="resetDeconvolutionBtn">
                                                        <i class="fas fa-undo me-2"></i>Reset Analysis
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Fit Quality -->
                                        <div class="card mb-4">
                                        <div class="card-header">
                                            <h6><i class="fas fa-info-circle me-2"></i>Fit Quality</h6>
                                        </div>
                                        <div class="card-body">
                                            <div class="mb-2">
                                            <span class="text-muted">R²:</span>
                                            <span class="float-end" id="deconvR2Value">--</span>
                                            </div>
                                            <div class="mb-2">
                                            <span class="text-muted">Area Error:</span>
                                            <span class="float-end" id="deconvAreaError">--</span>
                                            </div>
                                        </div>
                                        </div>

                                        <!-- Species Components -->
                                        <div class="card mb-4">
                                            <div class="card-header">
                                                <h6><i class="fas fa-list me-2"></i>Carbonyl Species</h6>
                                            </div>
                                            <div class="card-body">
                                                <div id="carbonylSpeciesList">
                                                    <div class="species-item" data-species="ketones">
                                                        <div class="d-flex justify-content-between align-items-center">
                                                            <span style="color: #3498db;">●</span>
                                                            <span class="species-name">Ketones</span>
                                                            <span class="species-freq">1721 cm⁻¹</span>
                                                        </div>
                                                        <div class="species-details mt-1">
                                                            <small class="text-muted">Width: 11-13 cm⁻¹ | Lorentzian: 90-93%</small>
                                                        </div>
                                                    </div>
                                                    <div class="species-item" data-species="carboxylic_acids">
                                                        <div class="d-flex justify-content-between align-items-center">
                                                            <span style="color: #2ecc71;">●</span>
                                                            <span class="species-name">Carboxylic Acids</span>
                                                            <span class="species-freq">1714 cm⁻¹</span>
                                                        </div>
                                                        <div class="species-details mt-1">
                                                            <small class="text-muted">Width: 16-18 cm⁻¹ | Lorentzian: 85-95%</small>
                                                        </div>
                                                    </div>
                                                    <div class="species-item" data-species="gamma_ketoacids_acid">
                                                        <div class="d-flex justify-content-between align-items-center">
                                                            <span style="color: #f39c12;">●</span>
                                                            <span class="species-name">Gamma-ketoacids (acid)</span>
                                                            <span class="species-freq">1707 cm⁻¹</span>
                                                        </div>
                                                        <div class="species-details mt-1">
                                                            <small class="text-muted">Width: 16 cm⁻¹ | Lorentzian: 90-94%</small>
                                                        </div>
                                                    </div>
                                                    <div class="species-item" data-species="gamma_ketoacids_keto">
                                                        <div class="d-flex justify-content-between align-items-center">
                                                            <span style="color: #16a085;">●</span>
                                                            <span class="species-name">Gamma-ketoacids (keto)</span>
                                                            <span class="species-freq">1698 cm⁻¹</span>
                                                        </div>
                                                        <div class="species-details mt-1">
                                                            <small class="text-muted">Width: 15 cm⁻¹ | Lorentzian: 90%</small>
                                                        </div>
                                                    </div>
                                                    <div class="species-item" data-species="esters_aldehydes">
                                                        <div class="d-flex justify-content-between align-items-center">
                                                            <span style="color: #e74c3c;">●</span>
                                                            <span class="species-name">Esters & Aldehydes</span>
                                                            <span class="species-freq">1737 cm⁻¹</span>
                                                        </div>
                                                        <div class="species-details mt-1">
                                                            <small class="text-muted">Width: 19 cm⁻¹ | Lorentzian: 85-90%</small>
                                                        </div>
                                                    </div>
                                                    <div class="species-item" data-species="carboxylic_acids_isolated">
                                                        <div class="d-flex justify-content-between align-items-center">
                                                            <span style="color: #9b59b6;">●</span>
                                                            <span class="species-name">Carboxylic Acids (isolated)</span>
                                                            <span class="species-freq">1767 cm⁻¹</span>
                                                        </div>
                                                        <div class="species-details mt-1">
                                                            <small class="text-muted">Width: 20-23 cm⁻¹ | Lorentzian: 90%</small>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    
                                        
                                        
                                        
                                        <!-- Species Quantification Results -->
                                        <div class="card mb-4">
                                            <div class="card-header">
                                                <h6><i class="fas fa-flask me-2"></i>Species Quantification</h6>
                                            </div>
                                            <div class="card-body">
                                                <div id="speciesQuantificationResults">
                                                    <p class="text-muted text-center">Run deconvolution to see results</p>
                                                </div>
                                            </div>
                                        </div>
                                        
                                        <!-- Methodology Info -->
                                        <div class="card">
                                        <div class="card-header">
                                            <h6><i class="fas fa-info-circle me-2"></i>Methodology Info</h6>
                                        </div>
                                        <div class="card-body">
                                            <div class="methodology-content">
                                                        <p><strong>Depth Selection:</strong></p>
                                                        <ul class="small">
                                                            <li>Select specific depth from dropdown (100μm, 200μm, etc.)</li>
                                                            <li>Each depth represents material at different penetration levels</li>
                                                            <li>Surface layers (100μm) typically show higher oxidation</li>
                                                            <li>Compare different depths by changing selection and re-running analysis</li>
                                                        </ul>
                                                        
                                                        <p><strong>Deconvolution Process:</strong></p>
                                                        <ol class="small">
                                                            <li>Spectral normalization using C-H reference band (2020 cm⁻¹)</li>
                                                            <li>Baseline correction (linear/polynomial)</li>
                                                            <li>Derivative analysis (2nd & 4th order) for peak detection</li>
                                                            <li>Gaussian-Lorentzian curve fitting for 6 carbonyl species</li>
                                                            <li>Quality assessment (R² > 0.90 target)</li>
                                                        </ol>
                                                        
                                                        <p><strong>Species Identification (Table-based):</strong></p>
                                                        <ul class="small">
                                                            <li><span style="color: #16a085;">●</span> Gamma-ketoacids keto (1698 cm⁻¹) - Oxidation product</li>
                                                            <li><span style="color: #f39c12;">●</span> Gamma-ketoacids acid (1707 cm⁻¹) - Oxidation product</li>
                                                            <li><span style="color: #2ecc71;">●</span> Carboxylic Acids associated (1714 cm⁻¹) - Degradation products</li>
                                                            <li><span style="color: #3498db;">●</span> Ketones (1721 cm⁻¹) - Most common oxidation product</li>
                                                            <li><span style="color: #e74c3c;">●</span> Esters & Aldehydes (1737 cm⁻¹) - Combined oxidation species</li>
                                                            <li><span style="color: #9b59b6;">●</span> Carboxylic Acids isolated (1767 cm⁻¹) - Isolated degradation products</li>
                                                        </ul>
                                                        <p class="small"><strong>Parameters from literature:</strong></p>
                                                        <ul class="small">
                                                            <li>Peak positions, widths, and Lorentzian contributions from optimization analysis</li>
                                                            <li>Mixed Gaussian-Lorentzian functions with specific contributions</li>
                                                        </ul>
                                                        
                                                        <p class="small text-muted mt-3">
                                                            <i class="fas fa-book me-1"></i>
                                                            Based on Salvalaggio et al. methodology for UHMWPE oxidation analysis
                                                        </p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                                </div>
                                <!-- End Individual Deconvolution Tab -->

                                <!-- Multiple Deconvolution Tab -->
                                <div class="tab-pane fade" id="multiple-deconv" role="tabpanel">
                                    <div class="row">
                                        <div class="col-12">
                                            <div class="card mb-4">
                                                <div class="card-header bg-primary text-white">
                                                    <h5 class="mb-0">
                                                        <i class="fas fa-layer-group me-2"></i>Automated Multi-Depth Deconvolution
                                                    </h5>
                                                </div>
                                                <div class="card-body">
                                                    <p class="text-muted mb-3">
                                                        <i class="fas fa-info-circle me-2"></i>
                                                        This tool automatically processes all depth spectra using the same deconvolution functions 
                                                        as individual analysis. Concentration is calculated using Lambert-Beer equation with 
                                                        thickness from 2000-2040 cm⁻¹ reference interval.
                                                    </p>
                                                    <div class="d-flex gap-3 mb-4 align-items-center flex-wrap">
                                                        <button class="btn btn-success btn-lg" id="runMultipleDeconvBtn"
                                                                data-bs-toggle="tooltip" data-bs-placement="top" 
                                                                title="Automatically process all depth spectra and calculate concentrations using Lambert-Beer equation">
                                                            <i class="fas fa-play-circle me-2"></i>Run Multiple Deconvolution
                                                        </button>
                                                        <button class="btn btn-outline-secondary" id="resetMultipleDeconvBtn"
                                                                data-bs-toggle="tooltip" data-bs-placement="top" 
                                                                title="Clear all results and reset the deconvolution analysis">
                                                            <i class="fas fa-undo me-2"></i>Reset Results
                                                        </button>
                                                        <div class="ms-auto d-flex gap-2">
                                                            <button class="btn btn-danger" id="exportMultiDeconvPdfBtn" disabled
                                                                    data-bs-toggle="tooltip" data-bs-placement="top" 
                                                                    title="Export complete report with concentration chart and data table to PDF">
                                                                <i class="fas fa-file-pdf me-2"></i>Export PDF
                                                            </button>
                                                            <button class="btn btn-success" id="exportMultiDeconvExcelBtn" disabled
                                                                    data-bs-toggle="tooltip" data-bs-placement="top" 
                                                                    title="Export detailed concentration data and area values to Excel spreadsheet">
                                                                <i class="fas fa-file-excel me-2"></i>Export Excel
                                                            </button>
                                                        </div>
                                                    </div>
                                                    <div id="multiDeconvProgress" class="mb-3" style="display:none;">
                                                        <div class="progress">
                                                            <div class="progress-bar progress-bar-striped progress-bar-animated" 
                                                                 id="multiDeconvProgressBar" role="progressbar" 
                                                                 style="width: 0%"></div>
                                                        </div>
                                                        <p class="text-center mt-2" id="multiDeconvProgressText">Processing...</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Results Chart -->
                                    <div class="row">
                                        <div class="col-12">
                                            <div class="card mb-4">
                                                <div class="card-header bg-info text-white">
                                                    <h6 class="mb-0">
                                                        <i class="fas fa-chart-area me-2"></i>Concentration Profiles vs Depth
                                                    </h6>
                                                </div>
                                                <div class="card-body p-0">
                                                    <div id="multiDeconvPlot" class="plot-container" style="height: 500px;"></div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <!-- Results Table -->
                                    <div class="row">
                                        <div class="col-12">
                                            <div class="card">
                                                <div class="card-header bg-secondary text-white">
                                                    <h6 class="mb-0">
                                                        <i class="fas fa-table me-2"></i>Detailed Results Table
                                                    </h6>
                                                </div>
                                                <div class="card-body">
                                                    <div class="table-responsive">
                                                        <table class="table table-striped table-hover" id="multiDeconvTable">
                                                            <thead>
                                                                <tr>
                                                                    <th>Depth</th>
                                                                    <th>Gamma-ketoacids keto (mmol/cm³)</th>
                                                                    <th>Gamma-ketoacids acid (mmol/cm³)</th>
                                                                    <th>Carboxylic Acids assoc. (mmol/cm³)</th>
                                                                    <th>Ketones (mmol/cm³)</th>
                                                                    <th>Esters & Aldehydes (mmol/cm³)</th>
                                                                    <th>Carboxylic Acids isolated (mmol/cm³)</th>
                                                                    <th>R²</th>
                                                                </tr>
                                                            </thead>
                                                            <tbody id="multiDeconvTableBody">
                                                                <tr>
                                                                    <td colspan="8" class="text-center text-muted">
                                                                        Run multiple deconvolution to see results
                                                                    </td>
                                                                </tr>
                                                            </tbody>
                                                        </table>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <!-- End Multiple Deconvolution Tab -->
                            </div>

                            </div>
                        </div>
                    </div>
                    <!-- END Carbonyl Deconvolution Tab -->

                    <!-- ADSORBED SPECIES QUANTIFICATION TAB (New) -->
                    <div class="tab-pane fade" id="adsorbed-species" role="tabpanel">
                        <div class="row mb-4 mt-4">
                            <div class="col-12">
                                <div class="card" style="background: linear-gradient(135deg, #27ae60 0%, #229954 100%); border: none;">
                                    <div class="card-body text-center py-4">
                                        <h4 class="text-white mb-3">
                                            <i class="fas fa-atom me-2"></i>Adsorbed Species Quantification
                                        </h4>
                                        <p class="text-white mb-0 opacity-90">
                                            Quantification of vitamin E and synovial liquid adsorbed on UHMWPE surface
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Adsorbed Species Sub-tabs -->
                        <ul class="nav nav-tabs mb-3" id="adsorbedSpeciesSubTabs" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="vitamin-e-tab" data-bs-toggle="tab" 
                                        data-bs-target="#vitamin-e" type="button" role="tab">
                                    <i class="fas fa-pills me-2"></i>Vitamin E Quantification
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="synovial-liquid-tab" data-bs-toggle="tab" 
                                        data-bs-target="#synovial-liquid" type="button" role="tab">
                                    <i class="fas fa-droplet me-2"></i>Synovial Liquid Quantification
                                </button>
                            </li>
                        </ul>

                        <div class="tab-content" id="adsorbedSpeciesTabContent">
                            <!-- Vitamin E Quantification Tab -->
                            <div class="tab-pane fade show active" id="vitamin-e" role="tabpanel">
                                <div class="card">
                                    <div class="card-body text-center py-5">
                                        <i class="fas fa-flask fa-3x text-muted mb-3"></i>
                                        <h5 class="text-muted">Vitamin E Quantification</h5>
                                        <p class="text-muted">This feature is under development</p>
                                        <small class="text-muted">Coming soon: FTIR-based quantification of vitamin E absorbed on UHMWPE</small>
                                    </div>
                                </div>
                            </div>

                            <!-- Synovial Liquid Quantification Tab -->
                            <div class="tab-pane fade" id="synovial-liquid" role="tabpanel">
                                <div class="card">
                                    <div class="card-body text-center py-5">
                                        <i class="fas fa-vial fa-3x text-muted mb-3"></i>
                                        <h5 class="text-muted">Synovial Liquid Quantification</h5>
                                        <p class="text-muted">This feature is under development</p>
                                        <small class="text-muted">Coming soon: FTIR-based quantification of synovial liquid absorbed on UHMWPE</small>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <!-- END Adsorbed Species Quantification Tab -->
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

    <script>
        // Global Application State
        window.AppState = {
            rawData: null,
            processedData: null,
            spectraData: {},
            analysisResults: {
                oxidation: {},
                crystallinity: {},
                tvi: {},
                dualIndex: {}
            },
            processingStatus: {
                offsetCorrected: false,
                baselineCorrected: false
            },
            currentFileName: '',
            loadedFiles: []
        };

        // Utility Functions
        function showLoading(message = 'Processing...') {
            document.getElementById('loadingText').textContent = message;
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateProcessingStatus(message, success = true) {
            const statusElement = document.getElementById('processingStatus');
            const icon = success ? 'fa-check text-success' : 'fa-exclamation-triangle text-warning';
            statusElement.innerHTML = `
                <div class="d-flex align-items-center">
                    <i class="fas ${icon} me-2"></i>
                    <span>${message}</span>
                </div>
            `;
        }
        
        function updateSampleFileInfo() {
            const sampleFileInfo = document.getElementById('sampleFileInfo');
            if (sampleFileInfo) {
                if (window.AppState.currentFileName) {
                    if (window.AppState.loadedFiles.length > 1) {
                        sampleFileInfo.textContent = `Sample files: ${window.AppState.currentFileName} (${window.AppState.loadedFiles.length} files total)`;
                    } else {
                        sampleFileInfo.textContent = `Sample file: ${window.AppState.currentFileName}`;
                    }
                } else {
                    sampleFileInfo.textContent = 'No file loaded';
                }
            }
        }

        // File Handlers Module
        function initializeFileHandlers() {
            console.log('Initializing file handlers...');
            
            // Update custom file input labels in English
            document.getElementById('fileInput').addEventListener('change', function(e) {
                const fileName = e.target.files.length > 0 ? e.target.files[0].name : 'No file chosen';
                const fileNameSpan = document.getElementById('fileInputName');
                fileNameSpan.textContent = fileName;
                if (e.target.files.length > 0) {
                    fileNameSpan.classList.add('has-file');
                } else {
                    fileNameSpan.classList.remove('has-file');
                }
                handleFileSelection(e);
            });
            
            document.getElementById('multiFileInput').addEventListener('change', function(e) {
                const fileCount = e.target.files.length;
                const fileName = fileCount > 0 ? `${fileCount} file${fileCount > 1 ? 's' : ''} selected` : 'No files chosen';
                const fileNameSpan = document.getElementById('multiFileInputName');
                fileNameSpan.textContent = fileName;
                if (fileCount > 0) {
                    fileNameSpan.classList.add('has-file');
                } else {
                    fileNameSpan.classList.remove('has-file');
                }
                handleMultiFileSelection(e);
            });
            
            document.getElementById('loadDataBtn').addEventListener('click', loadSpectrumData);
            document.getElementById('clearDataBtn').addEventListener('click', clearAllData);
            
            // Add import mode tab listeners
            document.getElementById('single-file-tab').addEventListener('click', () => {
                clearFileSelections();
            });
            document.getElementById('multi-files-tab').addEventListener('click', () => {
                clearFileSelections();
            });
        }

        function handleFileSelection(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            console.log('File selected:', file.name, 'Type:', file.type, 'Size:', file.size);
            
            // Store filename in AppState
            window.AppState.currentFileName = file.name;
            window.AppState.loadedFiles = [file.name];
            
            // Enable load button
            document.getElementById('loadDataBtn').disabled = false;
            
            // Reset column mapping
            document.getElementById('columnMapping').style.display = 'none';
            
            // Store file for later processing
            window.selectedFile = file;
            window.selectedFiles = null; // Clear multi-file selection
        }

        function handleMultiFileSelection(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            console.log('Multiple files selected:', files.length);
            
            // Validate all files are .dpt
            const invalidFiles = files.filter(file => !file.name.toLowerCase().endsWith('.dpt'));
            if (invalidFiles.length > 0) {
                alert('All files must be .dpt format');
                event.target.value = '';
                return;
            }
            
            // Parse and sort files by depth
            const parsedFiles = files.map(file => {
                const depthMatch = file.name.match(/(\d+)\.dpt$/i);
                const depth = depthMatch ? parseInt(depthMatch[1]) * 100 : 0; // Convert to microns
                const sampleMatch = file.name.match(/^(.+?)_?(\d+)\.dpt$/i);
                const sampleName = sampleMatch ? sampleMatch[1] : file.name.replace('.dpt', '');
                
                return {
                    file: file,
                    depth: depth,
                    sampleName: sampleName,
                    originalName: file.name
                };
            }).sort((a, b) => a.depth - b.depth);
            
            // Store filenames in AppState
            window.AppState.loadedFiles = files.map(f => f.name);
            window.AppState.currentFileName = files.length > 1 ? `${files.length} files` : files[0].name;
            
            // Enable load button
            document.getElementById('loadDataBtn').disabled = false;
            
            // Store files for later processing
            window.selectedFiles = parsedFiles;
            window.selectedFile = null; // Clear single file selection
            
            // Show preview
            displayMultiFilePreview(parsedFiles);
        }

        function displayMultiFilePreview(parsedFiles) {
            const preview = document.getElementById('multiFilePreview');
            const list = document.getElementById('multiFileList');
            
            if (!preview || !list) return;
            
            let html = '';
            const sampleGroups = groupFilesBySample(parsedFiles);
            
            Object.entries(sampleGroups).forEach(([sampleName, files]) => {
                html += `<div class="mb-3">
                    <h6 class="text-primary">${sampleName}</h6>`;
                
                files.forEach(fileData => {
                    html += `
                        <div class="d-flex justify-content-between align-items-center py-1 px-2 border-bottom">
                            <span class="text-truncate me-2">${fileData.originalName}</span>
                            <span class="badge bg-secondary">${fileData.depth}μm</span>
                        </div>
                    `;
                });
                
                html += '</div>';
            });
            
            list.innerHTML = html;
            preview.style.display = 'block';
        }

        function groupFilesBySample(parsedFiles) {
            const groups = {};
            
            parsedFiles.forEach(fileData => {
                const sampleName = fileData.sampleName;
                if (!groups[sampleName]) {
                    groups[sampleName] = [];
                }
                groups[sampleName].push(fileData);
            });
            
            return groups;
        }

        function clearFileSelections() {
            document.getElementById('fileInput').value = '';
            document.getElementById('multiFileInput').value = '';
            
            // Reset custom file input labels to English
            const fileInputName = document.getElementById('fileInputName');
            fileInputName.textContent = 'No file chosen';
            fileInputName.classList.remove('has-file');
            
            const multiFileInputName = document.getElementById('multiFileInputName');
            multiFileInputName.textContent = 'No files chosen';
            multiFileInputName.classList.remove('has-file');
            
            document.getElementById('loadDataBtn').disabled = true;
            document.getElementById('columnMapping').style.display = 'none';
            document.getElementById('multiFilePreview').style.display = 'none';
            window.selectedFile = null;
            window.selectedFiles = null;
        }

        async function loadSpectrumData() {
            if (!window.selectedFile && !window.selectedFiles) {
                alert('Please select a file or files first');
                return;
            }
            
            showLoading('Loading spectrum data...');
            
            try {
                let data;
                
                if (window.selectedFiles) {
                    // Multi-file mode
                    data = await loadMultipleDPTFiles(window.selectedFiles);
                } else {
                    // Single file mode
                    const extension = getFileExtension(window.selectedFile.name);
                    
                    switch (extension) {
                        case 'xlsx':
                            data = await loadExcelFile(window.selectedFile);
                            break;
                        case 'csv':
                            data = await loadCSVFile(window.selectedFile);
                            break;
                        case 'txt':
                            data = await loadTextFile(window.selectedFile);
                            break;
                        case 'dpt':
                            data = await loadDPTFile(window.selectedFile);
                            break;
                        case 'spc':
                            data = await loadSPCFile(window.selectedFile);
                            break;
                        case '0':
                            data = await loadBinaryFile(window.selectedFile);
                            break;
                        default:
                            throw new Error(`Unsupported file format: ${extension}`);
                    }
                }
                
                if (data && (Array.isArray(data) ? data.length > 0 : Object.keys(data).length > 0)) {
                    if (window.selectedFiles) {
                        await processMultiFileData(data);
                    } else {
                        await processLoadedData(data);
                    }
                    showSpectrumOverview();
                    enableProcessingControls();
                    document.getElementById('clearDataBtn').disabled = false;
                    
                    // Asegurar que los selectores de profundidad se poblen correctamente
                    setTimeout(() => {
                        populateDepthSelectors();
                    }, 100);
                } else {
                    throw new Error('No data found in files');
                }
                
            } catch (error) {
                console.error('Error loading files:', error);
                alert(`Error loading files: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        function getFileExtension(filename) {
            return filename.split('.').pop().toLowerCase();
        }

        async function loadMultipleDPTFiles(parsedFiles) {
            console.log('Loading multiple DPT files:', parsedFiles.length);
            
            const spectraData = {};
            let commonFrequency = null;
            
            for (const fileData of parsedFiles) {
                try {
                    console.log(`Loading file: ${fileData.originalName} at depth ${fileData.depth}μm`);
                    
                    const dptData = await loadDPTFile(fileData.file);
                    
                    if (dptData && dptData.length > 0) {
                        // Assume DPT file has frequency in first column, transmittance in second
                        const frequency = dptData.map(row => row[0]).filter(val => typeof val === 'number');
                        const transmittance = dptData.map(row => row[1]).filter(val => typeof val === 'number');
                        
                        if (frequency.length > 0 && transmittance.length > 0) {
                            // Check frequency consistency
                            if (!commonFrequency) {
                                commonFrequency = frequency;
                            } else if (frequency.length !== commonFrequency.length) {
                                console.warn(`Frequency length mismatch in ${fileData.originalName}`);
                                // Try to interpolate to common frequency
                                const interpolatedTransmittance = interpolateToCommonFrequency(frequency, transmittance, commonFrequency);
                                if (interpolatedTransmittance) {
                                    spectraData[`${fileData.depth}μm`] = {
                                        depth: fileData.depth,
                                        frequency: commonFrequency,
                                        transmittance: interpolatedTransmittance,
                                        originalTransmittance: [...interpolatedTransmittance], // Save original data to prevent contamination
                                        color: generateDepthColor(Object.keys(spectraData).length, parsedFiles.length),
                                        sampleName: fileData.sampleName,
                                        originalName: fileData.originalName
                                    };
                                }
                                continue;
                            }
                            
                            spectraData[`${fileData.depth}μm`] = {
                                depth: fileData.depth,
                                frequency: frequency,
                                transmittance: transmittance,
                                originalTransmittance: [...transmittance], // Save original data to prevent contamination
                                color: generateDepthColor(Object.keys(spectraData).length, parsedFiles.length),
                                sampleName: fileData.sampleName,
                                originalName: fileData.originalName
                            };
                        } else {
                            console.warn(`No valid spectral data found in ${fileData.originalName}`);
                        }
                    } else {
                        console.warn(`Failed to load data from ${fileData.originalName}`);
                    }
                } catch (error) {
                    console.error(`Error loading ${fileData.originalName}:`, error);
                }
            }
            
            if (Object.keys(spectraData).length === 0) {
                throw new Error('No valid spectral data found in any of the selected files');
            }
            
            console.log(`Successfully loaded ${Object.keys(spectraData).length} spectra from multiple files`);
            return spectraData;
        }

        function interpolateToCommonFrequency(sourceFreq, sourceTransmittance, targetFreq) {
            try {
                const result = [];
                
                for (const targetF of targetFreq) {
                    // Find closest frequencies
                    let closest = 0;
                    let minDiff = Math.abs(sourceFreq[0] - targetF);
                    
                    for (let i = 1; i < sourceFreq.length; i++) {
                        const diff = Math.abs(sourceFreq[i] - targetF);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closest = i;
                        }
                    }
                    
                    // Simple nearest neighbor interpolation
                    result.push(sourceTransmittance[closest]);
                }
                
                return result;
            } catch (error) {
                console.error('Error in interpolation:', error);
                return null;
            }
        }

        async function processMultiFileData(spectraData) {
            console.log('Processing multi-file spectra data...');
            
            // Store in global state
            window.AppState.spectraData = spectraData;
            
            // Update sample file info in UI
            updateSampleFileInfo();
            
            // Update depth selector for deconvolution
            populateDepthSelector();
            
            // Update depth selectors for analysis tabs
            populateDepthSelectors();
            
            // Create a dummy rawData structure for compatibility
            const firstSpectrum = Object.values(spectraData)[0];
            if (firstSpectrum) {
                const headers = ['Frequency', ...Object.keys(spectraData)];
                const rawData = [headers];
                
                for (let i = 0; i < firstSpectrum.frequency.length; i++) {
                    const row = [firstSpectrum.frequency[i]];
                    Object.values(spectraData).forEach(spectrum => {
                        row.push(spectrum.transmittance[i]);
                    });
                    rawData.push(row);
                }
                
                window.AppState.rawData = rawData;
            }
            
            console.log('Multi-file data processing complete. Spectra loaded:', Object.keys(spectraData));
        }

        async function loadExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        
                        // Obtener primera hoja de trabajo
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        
                        // Convertir a JSON
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                            header: 1,
                            defval: null
                        });
                        
                        console.log('Excel data loaded:', jsonData.length, 'rows');
                        resolve(jsonData);
                    } catch (error) {
                        reject(new Error('Error analyzing Excel file: ' + error.message));
                    }
                };
                reader.onerror = () => reject(new Error('Error reading Excel file'));
                reader.readAsArrayBuffer(file);
            });
        }

        async function loadCSVFile(file) {
            return new Promise((resolve, reject) => {
                Papa.parse(file, {
                    complete: function(results) {
                        if (results.errors.length > 0) {
                            console.warn('CSV analysis warnings:', results.errors);
                        }
                        console.log('CSV data loaded:', results.data.length, 'rows');
                        resolve(results.data);
                    },
                    error: function(error) {
                        reject(new Error('Error analyzing CSV file: ' + error.message));
                    },
                    skipEmptyLines: true,
                    dynamicTyping: true
                });
            });
        }

        async function loadTextFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const text = e.target.result;
                        const lines = text.split('\n').filter(line => line.trim());
                        
                        // Intentar detectar delimitador (tab, coma, espacio, punto y coma)
                        const delimiters = ['\t', ',', ' ', ';'];
                        let bestDelimiter = '\t';
                        let maxColumns = 0;
                        
                        for (const delimiter of delimiters) {
                            const testColumns = lines[0].split(delimiter).length;
                            if (testColumns > maxColumns) {
                                maxColumns = testColumns;
                                bestDelimiter = delimiter;
                            }
                        }
                        
                        const data = lines.map(line => {
                            return line.split(bestDelimiter).map(cell => {
                                const num = parseFloat(cell.trim());
                                return isNaN(num) ? cell.trim() : num;
                            });
                        });
                        
                        console.log('Text data loaded:', data.length, 'rows, delimiter:', bestDelimiter);
                        resolve(data);
                    } catch (error) {
                        reject(new Error('Error analyzing text file: ' + error.message));
                    }
                };
                reader.onerror = () => reject(new Error('Error reading text file'));
                reader.readAsText(file);
            });
        }

        async function loadDPTFile(file) {
            // DPT files are typically text files delimited by spaces/tabs
            return loadTextFile(file);
        }

        async function loadBinaryFile(file) {
            try {
                console.log('Loading binary file (.0 format):', file.name);
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        try {
                            const buffer = e.target.result;
                            const spectrumData = parseBinaryFile(buffer, file.name);
                            
                            if (!spectrumData) {
                                reject(new Error('Invalid binary file format'));
                                return;
                            }
                            
                            // Handle multi-depth files
                            if (spectrumData.multiDepth) {
                                console.log(`Processing multi-depth file with ${spectrumData.spectra.length} spectra`);
                                
                                const formattedData = [];
                                
                                // Process each spectrum and format for the analyzer
                                for (let spectrum of spectrumData.spectra) {
                                    for (let i = 0; i < spectrum.frequency.length; i++) {
                                        formattedData.push([
                                            spectrum.frequency[i], 
                                            spectrum.transmittance[i],
                                            spectrum.depth // Multi-depth with actual depth values
                                        ]);
                                    }
                                }
                                
                                resolve(formattedData);
                            } 
                            // Handle single-depth files
                            else if (spectrumData.frequency && spectrumData.transmittance) {
                                const formattedData = [];
                                for (let i = 0; i < spectrumData.frequency.length; i++) {
                                    formattedData.push([
                                        spectrumData.frequency[i], 
                                        spectrumData.transmittance[i],
                                        0 // Single depth
                                    ]);
                                }
                                resolve(formattedData);
                            } 
                            else {
                                reject(new Error('Unable to extract spectral data from file'));
                            }
                        } catch (error) {
                            reject(error);
                        }
                    };
                    
                    reader.onerror = () => reject(new Error('Error reading binary file'));
                    reader.readAsArrayBuffer(file);
                });
            } catch (error) {
                console.error('Error in loadBinaryFile:', error);
                throw error;
            }
        }
        
        function parseOPUSdot0File(buffer) {
            console.log('Using specialized OPUS .0 parser...');
            const dataView = new DataView(buffer);
            
            // Check if this is a multi-depth file (larger than 1MB indicates multiple spectra)
            if (buffer.byteLength > 1024 * 1024) {
                console.log('Large file detected, searching for multiple depth spectra...');
                return parseMultiDepthOPUS(dataView);
            }
            
            // Single depth file - use original approach
            const knownTransmittanceOffset = 2024;
            if (knownTransmittanceOffset + 4 < buffer.byteLength) {
                const transmittanceData = extractTransmittanceFromOffset(dataView, knownTransmittanceOffset);
                if (transmittanceData && transmittanceData.length > 1000) {
                    console.log(`Found transmittance data at known offset ${knownTransmittanceOffset}: ${transmittanceData.length} points`);
                    console.log(`Transmittance range: ${Math.min(...transmittanceData).toFixed(6)} - ${Math.max(...transmittanceData).toFixed(6)}`);
                    
                    const frequencyData = generateFrequencyArray(transmittanceData.length);
                    
                    return {
                        frequency: frequencyData,
                        transmittance: transmittanceData,
                        metadata: {
                            format: 'OPUS .0 (Single)',
                            points: frequencyData.length,
                            offset: knownTransmittanceOffset
                        }
                    };
                }
            }
            
            // Fall back to signature-based approach for single depth
            return parseSingleDepthOPUS(dataView);
        }
        
        function parseMultiDepthOPUS(dataView) {
            console.log('Parsing multi-depth OPUS file...');
            
            // Find all OPUS signatures
            const opusPositions = findAllOPUSSignatures(dataView);
            console.log(`Found ${opusPositions.length} OPUS signatures at positions: ${opusPositions.slice(0, 5).join(', ')}${opusPositions.length > 5 ? '...' : ''}`);
            
            const multiDepthSpectra = [];
            
            // Search for spectral data near each OPUS signature
            for (let i = 0; i < opusPositions.length; i++) {
                const opusPos = opusPositions[i];
                console.log(`Searching for spectrum near OPUS signature ${i + 1} at position ${opusPos}`);
                
                // Search in a range around each OPUS signature
                const spectrum = findSpectrumNearOPUS(dataView, opusPos, i);
                if (spectrum) {
                    multiDepthSpectra.push(spectrum);
                    console.log(`Found spectrum ${i + 1}: ${spectrum.transmittance.length} points at depth ${spectrum.depth}μm`);
                }
            }
            
            if (multiDepthSpectra.length === 0) {
                console.log('No valid spectra found in multi-depth file');
                return null;
            }
            
            console.log(`Successfully extracted ${multiDepthSpectra.length} spectra from multi-depth file`);
            
            return {
                multiDepth: true,
                spectra: multiDepthSpectra,
                metadata: {
                    format: 'OPUS .0 (Multi-depth)',
                    totalSpectra: multiDepthSpectra.length,
                    opusSignatures: opusPositions.length
                }
            };
        }
        
        function findAllOPUSSignatures(dataView) {
            const positions = [];
            const opusBytes = new TextEncoder().encode('OPUS');
            const uint8Array = new Uint8Array(dataView.buffer);
            
            for (let i = 0; i <= uint8Array.length - 4; i++) {
                let match = true;
                for (let j = 0; j < 4; j++) {
                    if (uint8Array[i + j] !== opusBytes[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    positions.push(i);
                }
            }
            
            return positions;
        }
        
        function findSpectrumNearOPUS(dataView, opusPos, depthIndex) {
            // Search offsets based on analysis of multi-depth file
            const searchOffsets = [1200, 1400, 1600, 1800, 2000, 2200, 2400, 6000, 8000];
            
            console.log(`Searching for spectrum near OPUS ${depthIndex + 1} at position ${opusPos}`);
            
            for (let offset of searchOffsets) {
                const testOffset = opusPos + offset;
                
                if (testOffset + 8000 < dataView.byteLength) {
                    const transmittanceData = extractTransmittanceFromOffset(dataView, testOffset);
                    
                    if (transmittanceData && transmittanceData.length > 100) {
                        const frequencyData = generateFrequencyArray(transmittanceData.length);
                        
                        console.log(`Found valid spectrum at offset ${testOffset}: ${transmittanceData.length} points, depth ${depthIndex * 10}μm`);
                        console.log(`Transmittance range: ${Math.min(...transmittanceData).toFixed(4)} - ${Math.max(...transmittanceData).toFixed(4)}`);
                        
                        return {
                            depth: depthIndex * 10, // Assign depths in 10μm increments
                            frequency: frequencyData,
                            transmittance: transmittanceData,
                            offset: testOffset,
                            points: transmittanceData.length
                        };
                    }
                }
            }
            
            console.log(`No valid spectrum found near OPUS ${depthIndex + 1}`);
            return null;
        }
        
        function parseSingleDepthOPUS(dataView) {
            // Original single-depth parsing logic
            const opusPos = findOPUSSignature(dataView.buffer);
            if (opusPos === -1) {
                console.log('OPUS signature not found, trying alternative approach...');
                return parseOPUSdot0Alternative(dataView.buffer);
            }
            
            console.log(`OPUS signature found at position: ${opusPos}`);
            
            const directoryEntries = readOPUSDirectory(dataView);
            console.log(`Found ${directoryEntries.length} directory entries`);
            
            let frequencyData = null;
            let transmittanceData = null;
            
            for (let i = 0; i < directoryEntries.length; i++) {
                const entry = directoryEntries[i];
                const spectralData = extractSpectralDataFromBlock(dataView, entry.offset, entry.size);
                
                if (spectralData) {
                    if (spectralData.type === 'frequency' && (!frequencyData || spectralData.data.length > frequencyData.length)) {
                        frequencyData = spectralData.data;
                    } else if (spectralData.type === 'transmittance' && (!transmittanceData || spectralData.data.length > transmittanceData.length)) {
                        transmittanceData = spectralData.data;
                    }
                }
            }
            
            if (!frequencyData && transmittanceData) {
                frequencyData = generateFrequencyArray(transmittanceData.length);
            }
            
            if (!frequencyData || !transmittanceData) {
                return null;
            }
            
            const minLength = Math.min(frequencyData.length, transmittanceData.length);
            frequencyData = frequencyData.slice(0, minLength);
            transmittanceData = transmittanceData.slice(0, minLength);
            
            if (frequencyData.length > 1 && frequencyData[0] < frequencyData[frequencyData.length - 1]) {
                frequencyData.reverse();
                transmittanceData.reverse();
            }
            
            return {
                frequency: frequencyData,
                transmittance: transmittanceData,
                metadata: {
                    format: 'OPUS .0 (Single)',
                    points: frequencyData.length,
                    directoryEntries: directoryEntries.length
                }
            };
        }
        
        function extractTransmittanceFromOffset(dataView, offset) {
            const transmittanceData = [];
            let currentOffset = offset;
            
            console.log(`Extracting transmittance data from offset ${offset}`);
            
            try {
                while (currentOffset + 4 <= dataView.byteLength) {
                    const value = dataView.getFloat32(currentOffset, true);
                    
                    // More lenient range check for multi-depth files
                    if (isFinite(value) && value >= 0 && value <= 20) {
                        transmittanceData.push(value);
                        currentOffset += 4;
                    } else {
                        break;
                    }
                    
                    // Limit to reasonable spectrum size
                    if (transmittanceData.length > 5000) break;
                }
                
                console.log(`Extracted ${transmittanceData.length} transmittance points from offset ${offset}`);
                if (transmittanceData.length > 100) {
                    console.log(`Sample values: ${transmittanceData.slice(0, 5).map(v => v.toFixed(4)).join(', ')}`);
                    console.log(`Range: ${Math.min(...transmittanceData).toFixed(4)} - ${Math.max(...transmittanceData).toFixed(4)}`);
                }
            } catch (e) {
                console.log('Error extracting transmittance data:', e);
            }
            
            return transmittanceData.length > 100 ? transmittanceData : null;
        }
        
        function generateFrequencyArray(numPoints) {
            const frequencyData = [];
            const startFreq = 4000;
            const endFreq = 600;
            const step = (startFreq - endFreq) / (numPoints - 1);
            
            for (let i = 0; i < numPoints; i++) {
                frequencyData.push(startFreq - i * step);
            }
            
            return frequencyData;
        }
        
        function findOPUSSignature(buffer) {
            const uint8Array = new Uint8Array(buffer);
            const opusSignature = new TextEncoder().encode('OPUS');
            
            for (let i = 0; i <= uint8Array.length - 4; i++) {
                let match = true;
                for (let j = 0; j < 4; j++) {
                    if (uint8Array[i + j] !== opusSignature[j]) {
                        match = false;
                        break;
                    }
                }
                if (match) return i;
            }
            return -1;
        }
        
        function readOPUSDirectory(dataView) {
            const entries = [];
            
            // OPUS files have a directory of blocks at the beginning
            // Format: offset (4 bytes) + size (4 bytes) pairs
            for (let i = 16; i < Math.min(400, dataView.byteLength - 8); i += 8) {
                try {
                    const offset = dataView.getUint32(i, true);
                    const size = dataView.getUint32(i + 4, true);
                    
                    // Validate entry
                    if (offset > 50 && offset < dataView.byteLength && 
                        size > 20 && size < dataView.byteLength && 
                        offset + size <= dataView.byteLength) {
                        entries.push({ offset, size });
                    }
                } catch (e) {
                    // Continue if we hit an invalid entry
                    continue;
                }
            }
            
            return entries;
        }
        
        function extractSpectralDataFromBlock(dataView, offset, size) {
            if (offset + size > dataView.byteLength || size < 40) {
                return null;
            }
            
            const numFloats = Math.floor(size / 4);
            const values = [];
            
            // Extract float32 values
            for (let i = 0; i < numFloats; i++) {
                try {
                    const value = dataView.getFloat32(offset + i * 4, true);
                    if (isFinite(value)) {
                        values.push(value);
                    }
                } catch (e) {
                    break;
                }
            }
            
            if (values.length < 50) {
                return null;
            }
            
            // Analyze the data type
            let freqCount = 0;
            let transCount = 0;
            
            for (let val of values) {
                if (val >= 200 && val <= 6000) freqCount++;
                if (val >= -10 && val <= 150) transCount++;
            }
            
            const freqRatio = freqCount / values.length;
            const transRatio = transCount / values.length;
            
            // Determine data type
            if (freqRatio > 0.8) {
                return { type: 'frequency', data: values };
            } else if (transRatio > 0.6) {
                return { type: 'transmittance', data: values };
            }
            
            return null;
        }
        
        function parseOPUSdot0Alternative(buffer) {
            console.log('Using alternative OPUS .0 parsing method...');
            const dataView = new DataView(buffer);
            
            // Search for spectral data patterns in known OPUS locations
            const searchOffsets = [1800, 2048, 2200, 3000, 4096, 8192];
            
            let bestFrequency = null;
            let bestTransmittance = null;
            let bestScore = 0;
            
            for (let baseOffset of searchOffsets) {
                if (baseOffset >= dataView.byteLength) continue;
                
                for (let offset = baseOffset; offset < Math.min(baseOffset + 1000, dataView.byteLength - 2000); offset += 100) {
                    const spectralData = findSpectralDataAtOffset(dataView, offset);
                    
                    if (spectralData && spectralData.score > bestScore) {
                        bestScore = spectralData.score;
                        if (spectralData.frequency) bestFrequency = spectralData.frequency;
                        if (spectralData.transmittance) bestTransmittance = spectralData.transmittance;
                    }
                }
            }
            
            // Generate frequency if not found
            if (!bestFrequency && bestTransmittance) {
                const numPoints = bestTransmittance.length;
                bestFrequency = [];
                for (let i = 0; i < numPoints; i++) {
                    bestFrequency.push(4000 - (3600 * i / (numPoints - 1)));
                }
            }
            
            if (!bestFrequency || !bestTransmittance) {
                console.log('Alternative parsing method failed');
                return null;
            }
            
            return {
                frequency: bestFrequency,
                transmittance: bestTransmittance,
                metadata: {
                    format: 'OPUS .0 Alternative',
                    points: bestFrequency.length,
                    score: bestScore
                }
            };
        }
        
        function findSpectralDataAtOffset(dataView, offset) {
            try {
                const maxFloats = Math.min(2000, Math.floor((dataView.byteLength - offset) / 4));
                const values = [];
                
                for (let i = 0; i < maxFloats; i++) {
                    const value = dataView.getFloat32(offset + i * 4, true);
                    if (isFinite(value) && Math.abs(value) < 1e6) {
                        values.push(value);
                    } else if (values.length > 100) {
                        break;
                    }
                }
                
                if (values.length < 100) return null;
                
                // Check for FTIR-like patterns
                const freqLike = values.filter(v => v >= 200 && v <= 6000).length;
                const transLike = values.filter(v => v >= -5 && v <= 150).length;
                
                const freqRatio = freqLike / values.length;
                const transRatio = transLike / values.length;
                
                let score = 0;
                let result = {};
                
                if (freqRatio > 0.8) {
                    // Check if it's a decreasing sequence (typical for FTIR frequency)
                    let decreasing = 0;
                    for (let i = 1; i < Math.min(values.length, 50); i++) {
                        if (values[i] <= values[i-1]) decreasing++;
                    }
                    
                    if (decreasing > 40) {
                        score = 90 + freqRatio * 10;
                        result.frequency = values;
                    }
                } else if (transRatio > 0.6) {
                    score = 70 + transRatio * 20;
                    result.transmittance = values;
                }
                
                return score > 50 ? { ...result, score } : null;
                
            } catch (e) {
                return null;
            }
        }

        function parseBinaryFile(buffer, fileName) {
            try {
                console.log(`Parsing OPUS FTIR file (.0): ${fileName}, size: ${buffer.byteLength} bytes`);
                
                // Try the specialized .0 format parser first
                let opusData = parseOPUSdot0File(buffer);
                
                if (!opusData || !opusData.frequency || !opusData.transmittance) {
                    console.log('Specialized .0 parser failed, trying comprehensive OPUS parser...');
                    opusData = parseOPUSFileComprehensive(buffer);
                }
                
                if (!opusData || !opusData.frequency || !opusData.transmittance) {
                    console.log('Comprehensive OPUS parser failed, trying simple extraction...');
                    opusData = parseOPUSSimple(buffer);
                }
                
                if (!opusData || !opusData.frequency || !opusData.transmittance) {
                    throw new Error('Unable to extract spectral data from OPUS file');
                }
                
                console.log('OPUS file parsing successful:', {
                    points: opusData.frequency.length,
                    firstX: opusData.frequency[0],
                    lastX: opusData.frequency[opusData.frequency.length - 1],
                    fileName: fileName,
                    freqRange: `${Math.min(...opusData.frequency).toFixed(1)} - ${Math.max(...opusData.frequency).toFixed(1)} cm⁻¹`,
                    metadata: opusData.metadata
                });
                
                return {
                    frequency: opusData.frequency,
                    transmittance: opusData.transmittance,
                    metadata: {
                        fileName: fileName,
                        points: opusData.frequency.length,
                        fileType: 'OPUS .0',
                        ...opusData.metadata
                    }
                };
            } catch (error) {
                console.error('Error parsing OPUS file:', error);
                throw new Error(`Error processing OPUS file: ${error.message}`);
            }
        }

        function parseOPUSSimple(buffer) {
            console.log('Trying simple OPUS extraction...');
            const dataView = new DataView(buffer);
            
            // Look for the largest continuous block of reasonable float data
            let bestBlock = null;
            let maxPoints = 0;
            
            // Search through the file in larger chunks
            for (let offset = 1024; offset < buffer.byteLength - 4096; offset += 1024) {
                const block = findBestDataBlock(dataView, offset, Math.min(16384, buffer.byteLength - offset));
                
                if (block && block.points > maxPoints) {
                    maxPoints = block.points;
                    bestBlock = block;
                    bestBlock.offset = offset + bestBlock.localOffset;
                }
            }
            
            if (!bestBlock || bestBlock.points < 100) {
                console.log('No suitable data block found in simple extraction');
                return null;
            }
            
            console.log(`Best block found at offset ${bestBlock.offset} with ${bestBlock.points} points`);
            
            // Extract the data from the best block
            const frequency = [];
            const transmittance = [];
            
            for (let i = 0; i < bestBlock.points; i++) {
                const offset = bestBlock.offset + i * 4;
                if (offset + 4 <= dataView.byteLength) {
                    const value = dataView.getFloat32(offset, true);
                    
                    if (bestBlock.dataType === 'transmittance') {
                        // Generate frequency for transmittance data
                        const freq = 4000 - (i * 3600 / (bestBlock.points - 1));
                        frequency.push(freq);
                        transmittance.push(value);
                    } else if (bestBlock.dataType === 'interleaved' && i % 2 === 0 && i + 1 < bestBlock.points) {
                        // Extract interleaved pairs
                        const freq = value;
                        const trans = dataView.getFloat32(offset + 4, true);
                        if (freq >= 400 && freq <= 4000 && Math.abs(trans) <= 10) {
                            frequency.push(freq);
                            transmittance.push(trans);
                        }
                        i++; // Skip next value as it's already processed
                    }
                }
            }
            
            if (frequency.length < 50) {
                return null;
            }
            
            return {
                frequency: frequency,
                transmittance: transmittance,
                metadata: { extractionMethod: 'simple', blockOffset: bestBlock.offset }
            };
        }

        function findBestDataBlock(dataView, startOffset, maxBytes) {
            let bestBlock = null;
            let maxScore = 0;
            
            // Test different block sizes and positions
            const testSizes = [1024, 2048, 4096, 8192];
            
            for (let size of testSizes) {
                if (size > maxBytes) continue;
                
                for (let localOffset = 0; localOffset <= maxBytes - size; localOffset += 256) {
                    const offset = startOffset + localOffset;
                    const numFloats = size / 4;
                    
                    let transmittanceCount = 0;
                    let frequencyCount = 0;
                    let validCount = 0;
                    
                    // Analyze the data
                    for (let i = 0; i < numFloats; i++) {
                        const floatOffset = offset + i * 4;
                        if (floatOffset + 4 <= dataView.byteLength) {
                            const value = dataView.getFloat32(floatOffset, true);
                            
                            if (isFinite(value)) {
                                validCount++;
                                
                                if (Math.abs(value) <= 10) {
                                    transmittanceCount++;
                                }
                                
                                if (value >= 400 && value <= 4000) {
                                    frequencyCount++;
                                }
                            }
                        }
                    }
                    
                    if (validCount < numFloats * 0.8) continue;
                    
                    const transmittanceRatio = transmittanceCount / validCount;
                    const frequencyRatio = frequencyCount / validCount;
                    
                    let score = 0;
                    let dataType = 'unknown';
                    
                    // Score transmittance data
                    if (transmittanceRatio > 0.7) {
                        score = transmittanceRatio * validCount;
                        dataType = 'transmittance';
                    }
                    
                    // Score interleaved data
                    if (numFloats % 2 === 0) {
                        let pairScore = 0;
                        for (let i = 0; i < numFloats - 1; i += 2) {
                            const freq = dataView.getFloat32(offset + i * 4, true);
                            const trans = dataView.getFloat32(offset + (i + 1) * 4, true);
                            
                            if (freq >= 400 && freq <= 4000 && Math.abs(trans) <= 10) {
                                pairScore++;
                            }
                        }
                        
                        const pairRatio = pairScore / (numFloats / 2);
                        if (pairRatio > 0.5) {
                            const interleavedScore = pairRatio * pairScore;
                            if (interleavedScore > score) {
                                score = interleavedScore;
                                dataType = 'interleaved';
                            }
                        }
                    }
                    
                    if (score > maxScore) {
                        maxScore = score;
                        bestBlock = {
                            localOffset: localOffset,
                            points: dataType === 'interleaved' ? numFloats / 2 : numFloats,
                            dataType: dataType,
                            score: score,
                            size: size
                        };
                    }
                }
            }
            
            return bestBlock;
        }

        function parseOPUSFileComprehensive(buffer) {
            const dataView = new DataView(buffer);
            
            console.log('Parsing OPUS file format (comprehensive)...');
            
            // OPUS files have a complex directory structure
            // Start by finding data blocks
            const blocks = findOPUSDataBlocks(dataView);
            
            if (blocks.length === 0) {
                console.log('No valid OPUS data blocks found');
                return null;
            }
            
            console.log(`Found ${blocks.length} OPUS data blocks`);
            
            // Look for spectrum data block (usually contains spectral data)
            let spectrumBlock = null;
            let parameterBlock = null;
            
            // Filter out too many small blocks (likely noise)
            const significantBlocks = blocks.filter(block => block.confidence > 0.8 || block.size > 4096);
            
            if (significantBlocks.length > 0) {
                console.log(`Filtered to ${significantBlocks.length} significant blocks`);
                
                for (let block of significantBlocks) {
                    console.log(`Block type: ${block.type}, size: ${block.size}, offset: ${block.offset}, confidence: ${block.confidence}`);
                    
                    // Common OPUS block types for spectral data
                    if (block.type === 'AB' || block.type === 'ScSm' || block.type === 'ScRf') {
                        spectrumBlock = block;
                        console.log('Found spectrum data block:', block.type);
                        break;
                    }
                    
                    // Parameter blocks contain metadata
                    if (block.type === 'Sample Parameters' || block.type === 'Acquisition Parameters') {
                        parameterBlock = block;
                    }
                }
                
                if (!spectrumBlock) {
                    // Try to find the highest confidence block as spectrum data
                    spectrumBlock = significantBlocks.reduce((best, current) => 
                        current.confidence > best.confidence ? current : best
                    );
                    console.log('Using highest confidence block as spectrum data:', spectrumBlock.type);
                }
            } else {
                console.log('No significant blocks found, trying alternative approach');
                return null;
            }
            
            // Extract spectral data from the block
            const spectralData = extractOPUSSpectralData(dataView, spectrumBlock);
            
            if (!spectralData) {
                console.log('Unable to extract spectral data from OPUS blocks');
                return null;
            }
            
            // Extract metadata if available
            let metadata = {};
            if (parameterBlock) {
                metadata = extractOPUSParameters(dataView, parameterBlock);
            }
            
            return {
                frequency: spectralData.frequency,
                transmittance: spectralData.transmittance,
                metadata: metadata
            };
        }

        function findOPUSDataBlocks(dataView) {
            console.log('Analyzing OPUS file structure...');
            
            // OPUS files have a specific directory structure at the beginning
            // Let's analyze the file header more carefully
            
            console.log('File header bytes:');
            for (let i = 0; i < Math.min(32, dataView.byteLength); i += 4) {
                const bytes = [];
                for (let j = 0; j < 4 && i + j < dataView.byteLength; j++) {
                    bytes.push(dataView.getUint8(i + j).toString(16).padStart(2, '0'));
                }
                console.log(`Offset ${i}: ${bytes.join(' ')}`);
            }
            
            // Try to find spectral data by looking for specific patterns
            const blocks = findOPUSDataPatterns(dataView);
            
            if (blocks.length === 0) {
                console.log('No data patterns found, trying alternative approach...');
                return findOPUSAlternativeStructure(dataView);
            }
            
            return blocks;
        }

        function findOPUSDataPatterns(dataView) {
            const blocks = [];
            
            console.log('Searching for OPUS data patterns...');
            
            // Look for float data patterns throughout the file
            // OPUS files often have spectral data in specific regions
            
            const searchRegions = [
                { start: 512, end: 8192, name: 'header_region' },
                { start: 8192, end: 65536, name: 'early_data' },
                { start: 65536, end: Math.min(dataView.byteLength, 1048576), name: 'main_data' }
            ];
            
            for (let region of searchRegions) {
                console.log(`Searching ${region.name} (${region.start} - ${region.end})`);
                
                for (let offset = region.start; offset < region.end - 1024; offset += 256) {
                    if (offset >= dataView.byteLength) break;
                    
                    // Check for patterns of reasonable FTIR data
                    const pattern = analyzeDataPattern(dataView, offset, Math.min(1024, region.end - offset));
                    
                    if (pattern.isValidSpectralData && pattern.count > 50) {
                        blocks.push({
                            type: `SpectralData_${region.name}`,
                            size: pattern.count * 4,
                            offset: offset,
                            dataType: pattern.dataType,
                            confidence: pattern.confidence
                        });
                        
                        console.log(`Found spectral pattern in ${region.name} at offset ${offset}: ${pattern.count} points, confidence: ${pattern.confidence.toFixed(2)}`);
                        
                        // Skip ahead to avoid overlaps
                        offset += pattern.count * 4;
                    }
                }
            }
            
            // Sort blocks by confidence score
            blocks.sort((a, b) => b.confidence - a.confidence);
            
            return blocks;
        }

        function analyzeDataPattern(dataView, startOffset, maxBytes) {
            const maxFloats = Math.floor(maxBytes / 4);
            let validFreqCount = 0;
            let validTransCount = 0;
            let consecutiveValid = 0;
            let maxConsecutive = 0;
            
            const values = [];
            
            // Extract values and analyze patterns
            for (let i = 0; i < maxFloats && startOffset + i * 4 + 4 <= dataView.byteLength; i++) {
                const value = dataView.getFloat32(startOffset + i * 4, true);
                
                if (isFinite(value)) {
                    values.push(value);
                    consecutiveValid++;
                    maxConsecutive = Math.max(maxConsecutive, consecutiveValid);
                    
                    // Check if value could be FTIR frequency (400-4000 cm⁻¹ typical range)
                    if (value >= 200 && value <= 8000) {
                        validFreqCount++;
                    }
                    
                    // Check if value could be transmittance/absorbance (-5 to 5 typical range)
                    if (value >= -10 && value <= 10) {
                        validTransCount++;
                    }
                } else {
                    consecutiveValid = 0;
                }
            }
            
            if (values.length === 0) {
                return { isValidSpectralData: false, count: 0, confidence: 0 };
            }
            
            // Calculate statistics
            const freqRatio = validFreqCount / values.length;
            const transRatio = validTransCount / values.length;
            const consecutiveRatio = maxConsecutive / values.length;
            
            // Determine if this looks like spectral data
            let confidence = 0;
            let dataType = 'unknown';
            
            // Check for interleaved frequency/transmittance pairs
            if (values.length >= 10 && values.length % 2 === 0) {
                let freqLikeEven = 0;
                let transLikeOdd = 0;
                
                for (let i = 0; i < values.length; i += 2) {
                    if (i + 1 < values.length) {
                        const evenVal = values[i];
                        const oddVal = values[i + 1];
                        
                        if (evenVal >= 200 && evenVal <= 8000) freqLikeEven++;
                        if (oddVal >= -10 && oddVal <= 10) transLikeOdd++;
                    }
                }
                
                const pairs = Math.floor(values.length / 2);
                if (freqLikeEven / pairs > 0.7 && transLikeOdd / pairs > 0.7) {
                    confidence = 0.9;
                    dataType = 'interleaved_pairs';
                }
            }
            
            // Check for pure transmittance data
            if (confidence < 0.5 && transRatio > 0.8 && consecutiveRatio > 0.8) {
                confidence = 0.7;
                dataType = 'transmittance_only';
            }
            
            // Check for pure frequency data
            if (confidence < 0.5 && freqRatio > 0.8 && consecutiveRatio > 0.8) {
                confidence = 0.6;
                dataType = 'frequency_only';
            }
            
            const isValidSpectralData = confidence > 0.5 && maxConsecutive >= 50;
            
            return {
                isValidSpectralData,
                count: maxConsecutive,
                confidence,
                dataType,
                freqRatio,
                transRatio,
                consecutiveRatio
            };
        }

        function findOPUSAlternativeStructure(dataView) {
            console.log('Trying alternative OPUS structure analysis...');
            
            // Some OPUS files store data in fixed-size blocks
            // Common block sizes: 512, 1024, 2048, 4096 bytes
            const blocks = [];
            const blockSizes = [512, 1024, 2048, 4096, 8192];
            
            for (let blockSize of blockSizes) {
                for (let offset = 0; offset < dataView.byteLength - blockSize; offset += blockSize) {
                    const pattern = analyzeDataPattern(dataView, offset, blockSize);
                    
                    if (pattern.isValidSpectralData && pattern.count > 20) {
                        blocks.push({
                            type: `FixedBlock_${blockSize}`,
                            size: pattern.count * 4,
                            offset: offset,
                            dataType: pattern.dataType,
                            confidence: pattern.confidence
                        });
                        
                        console.log(`Found fixed block pattern at offset ${offset}: block size ${blockSize}, ${pattern.count} points`);
                    }
                }
            }
            
            return blocks.sort((a, b) => b.confidence - a.confidence);
        }

        function countConsecutiveValidFloats(dataView, startOffset) {
            let count = 0;
            let offset = startOffset;
            
            while (offset + 4 <= dataView.byteLength) {
                const value = dataView.getFloat32(offset, true);
                
                // Check if it's a reasonable FTIR value
                if (isFinite(value) && Math.abs(value) < 1e6) {
                    count++;
                    offset += 4;
                } else {
                    break;
                }
                
                // Limit check to prevent infinite loops
                if (count > 10000) break;
            }
            
            return count;
        }

        function extractOPUSSpectralData(dataView, block) {
            console.log(`Extracting spectral data from block at offset ${block.offset}, size ${block.size}, type: ${block.dataType}`);
            
            const data = [];
            const numFloats = Math.floor(block.size / 4);
            
            // Extract float32 values from the block
            for (let i = 0; i < numFloats; i++) {
                const offset = block.offset + i * 4;
                if (offset + 4 <= dataView.byteLength) {
                    const value = dataView.getFloat32(offset, true);
                    if (isFinite(value)) {
                        data.push(value);
                    }
                }
            }
            
            console.log(`Extracted ${data.length} raw data points`);
            
            if (data.length < 10) {
                console.log('Not enough data points, trying alternative extraction...');
                return tryAlternativeExtraction(dataView, block);
            }
            
            // Use the detected data type to parse correctly
            if (block.dataType === 'interleaved_pairs') {
                return extractInterleavedPairs(data);
            } else if (block.dataType === 'transmittance_only') {
                return extractTransmittanceOnly(data);
            } else if (block.dataType === 'frequency_only') {
                // This shouldn't happen for spectral data, but handle it
                console.log('Frequency-only data detected, looking for corresponding transmittance...');
                return null;
            } else {
                // Try to auto-detect the format
                return autoDetectFormat(data);
            }
        }

        function extractInterleavedPairs(data) {
            console.log('Extracting interleaved frequency/transmittance pairs...');
            
            const frequency = [];
            const transmittance = [];
            
            for (let i = 0; i < data.length - 1; i += 2) {
                const freq = data[i];
                const trans = data[i + 1];
                
                // Validate ranges for FTIR data
                if (freq >= 200 && freq <= 8000 && Math.abs(trans) <= 50) {
                    frequency.push(freq);
                    transmittance.push(trans);
                }
            }
            
            if (frequency.length > 10) {
                console.log(`Successfully extracted ${frequency.length} interleaved pairs`);
                return { frequency, transmittance };
            }
            
            return null;
        }

        function extractTransmittanceOnly(data) {
            console.log('Extracting transmittance-only data, generating frequency array...');
            
            // Filter out unreasonable transmittance values
            const validTrans = data.filter(val => Math.abs(val) <= 50);
            
            if (validTrans.length < 10) {
                return null;
            }
            
            // Generate frequency array for typical FTIR range
            const frequency = [];
            const startFreq = 4000;
            const endFreq = 400;
            const step = (startFreq - endFreq) / (validTrans.length - 1);
            
            for (let i = 0; i < validTrans.length; i++) {
                frequency.push(startFreq - i * step);
            }
            
            console.log(`Generated frequency array for ${validTrans.length} transmittance points`);
            return { frequency, transmittance: validTrans };
        }

        function autoDetectFormat(data) {
            console.log('Auto-detecting data format...');
            
            // Try interleaved pairs first
            if (data.length >= 20 && data.length % 2 === 0) {
                const result = extractInterleavedPairs(data);
                if (result) {
                    return result;
                }
            }
            
            // Try as transmittance only
            const result = extractTransmittanceOnly(data);
            if (result) {
                return result;
            }
            
            console.log('Could not auto-detect format');
            return null;
        }

        function tryAlternativeExtraction(dataView, block) {
            console.log('Trying alternative extraction methods...');
            
            // Try different data types and endianness
            const alternatives = [
                { type: 'float64', littleEndian: true, step: 8 },
                { type: 'float32', littleEndian: false, step: 4 },
                { type: 'float64', littleEndian: false, step: 8 }
            ];
            
            for (let alt of alternatives) {
                const data = [];
                const numValues = Math.floor(block.size / alt.step);
                
                for (let i = 0; i < Math.min(numValues, 1000); i++) {
                    const offset = block.offset + i * alt.step;
                    if (offset + alt.step <= dataView.byteLength) {
                        let value;
                        if (alt.type === 'float64') {
                            value = dataView.getFloat64(offset, alt.littleEndian);
                        } else {
                            value = dataView.getFloat32(offset, alt.littleEndian);
                        }
                        
                        if (isFinite(value) && Math.abs(value) < 1e6) {
                            data.push(value);
                        }
                    }
                }
                
                console.log(`Alternative ${alt.type} ${alt.littleEndian ? 'LE' : 'BE'}: ${data.length} values`);
                
                if (data.length >= 20) {
                    const result = autoDetectFormat(data);
                    if (result) {
                        console.log(`Success with alternative method: ${alt.type} ${alt.littleEndian ? 'LE' : 'BE'}`);
                        return result;
                    }
                }
            }
            
            return null;
        }

        function extractOPUSParameters(dataView, block) {
            // Extract text parameters from parameter blocks
            const metadata = {};
            
            try {
                const text = readOPUSString(dataView, block.offset, block.size);
                console.log('Parameter block content:', text.substring(0, 200));
                
                // Parse common OPUS parameters
                const lines = text.split('\n');
                for (let line of lines) {
                    if (line.includes('=')) {
                        const [key, value] = line.split('=');
                        metadata[key.trim()] = value.trim();
                    }
                }
            } catch (e) {
                console.log('Could not parse parameter block:', e);
            }
            
            return metadata;
        }

        function readOPUSString(dataView, offset, length) {
            let str = '';
            for (let i = 0; i < length && offset + i < dataView.byteLength; i++) {
                const byte = dataView.getUint8(offset + i);
                if (byte >= 32 && byte <= 126) { // Printable ASCII
                    str += String.fromCharCode(byte);
                } else if (byte === 0) {
                    break; // Null terminator
                } else {
                    str += '.'; // Non-printable character
                }
            }
            return str;
        }



        async function loadSPCFile(file) {
            try {
                console.log('Loading SPC file:', file.name);
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    
                    reader.onload = function(e) {
                        try {
                            const buffer = e.target.result;
                            const spectrumData = parseSPCBuffer(buffer, file.name);
                            
                            // Manejar múltiples espectros - cargar todos automáticamente
                            if (Array.isArray(spectrumData)) {
                                console.log(`Archivo SPC contiene ${spectrumData.length} espectros`);
                                
                                // Convertir todos los espectros al formato esperado
                                const allFormattedData = [];
                                spectrumData.forEach((spectrum, index) => {
                                    const depth = spectrum.metadata.depth;
                                    console.log(`Formateando espectro ${index + 1}: profundidad=${depth}μm, puntos=${spectrum.frequency.length}`);
                                    
                                    for (let i = 0; i < spectrum.frequency.length; i++) {
                                        allFormattedData.push([
                                            spectrum.frequency[i], 
                                            spectrum.transmittance[i], 
                                            depth // Usar profundidad extraída de metadatos
                                        ]);
                                    }
                                });
                                
                                console.log(`Datos formateados: ${allFormattedData.length} puntos total`);
                                
                                resolve(allFormattedData);
                                return;
                            }
                            
                            // Espectro único
                            if (spectrumData && spectrumData.frequency && spectrumData.transmittance) {
                                const formattedData = [];
                                for (let i = 0; i < spectrumData.frequency.length; i++) {
                                    formattedData.push([spectrumData.frequency[i], spectrumData.transmittance[i]]);
                                }
                                resolve(formattedData);
                            } else {
                                reject(new Error('No se pudieron extraer datos válidos del archivo SPC'));
                            }
                        } catch (error) {
                            console.error('Error procesando SPC:', error);
                            reject(new Error('Error al procesar archivo SPC: ' + error.message));
                        }
                    };
                    
                    reader.onerror = function() {
                        reject(new Error('Error al leer el archivo SPC'));
                    };
                    
                    reader.readAsArrayBuffer(file);
                });
            } catch (error) {
                console.error('Error in loadSPCFile:', error);
                throw error;
            }
        }



        function extractDepthFromSubHeader(dataView, offset) {
            try {
                // SPC files can store depth metadata in different locations
                // Try multiple strategies to extract depth information
                
                // Strategy 1: Search in floating point fields (offset +8 to +24)
                for (let i = 8; i < 24; i += 4) {
                    if (offset + i + 4 <= dataView.byteLength) {
                        const value = dataView.getFloat32(offset + i, true);
                        if (value > 0 && value < 50000 && Number.isFinite(value)) {
                            // Reasonable value for depth in μm
                            console.log(`Depth found at offset ${i}: ${value}μm`);
                            return Math.round(value);
                        }
                    }
                }
                
                // Strategy 2: Search text with depth information
                const textRegion = new Uint8Array(dataView.buffer, offset, Math.min(32, dataView.byteLength - offset));
                const textStr = String.fromCharCode.apply(null, textRegion);
                
                // Search patterns like "9600", "μm", "um", etc.
                const depthMatch = textStr.match(/(\d+)\s*[μu]?m/i);
                if (depthMatch) {
                    const depth = parseInt(depthMatch[1]);
                    console.log(`Depth extracted from text: ${depth}μm`);
                    return depth;
                }
                
                // Estrategia 3: Buscar en campos enteros
                for (let i = 0; i < 32; i += 4) {
                    if (offset + i + 4 <= dataView.byteLength) {
                        const value = dataView.getUint32(offset + i, true);
                        if (value > 0 && value < 50000) {
                            // Verificar si el valor podría ser una profundidad
                            if (value % 100 === 0 || value % 50 === 0) {
                                console.log(`Possible depth at offset ${i}: ${value}μm`);
                                return value;
                            }
                        }
                    }
                }
                
                return null; // No depth information found
            } catch (error) {
                console.warn('Error extracting depth:', error);
                return null;
            }
        }
        
        function normalizeTransmittanceValues(values) {
            if (values.length === 0) return values;
            
            // Safe min/max calculation for large arrays
            let maxValue = values[0];
            let minValue = values[0];
            
            for (let i = 1; i < values.length; i++) {
                if (values[i] > maxValue) maxValue = values[i];
                if (values[i] < minValue) minValue = values[i];
            }
            
            console.log(`Original transmittance range: ${minValue.toExponential(2)} - ${maxValue.toExponential(2)}`);
            
            // If values are very large, apply normalization
            if (maxValue > 1000000) {
                // Normalize by dividing by max value
                const normalizedValues = values.map(v => v / maxValue);
                
                // Safe min/max for normalized values
                let normalizedMin = normalizedValues[0];
                let normalizedMax = normalizedValues[0];
                for (let i = 1; i < normalizedValues.length; i++) {
                    if (normalizedValues[i] > normalizedMax) normalizedMax = normalizedValues[i];
                    if (normalizedValues[i] < normalizedMin) normalizedMin = normalizedValues[i];
                }
                
                console.log(`Applied division normalization, new range: ${normalizedMin.toFixed(6)} - ${normalizedMax.toFixed(6)}`);
                return normalizedValues;
            }
            
            // If values are in reasonable range, check if scaling is needed
            if (maxValue > 100) {
                // Scale to 0-1 range
                const range = maxValue - minValue;
                if (range === 0) return values; // Avoid division by zero
                
                const scaledValues = values.map(v => (v - minValue) / range);
                console.log(`Applied 0-1 scaling, new range: 0.000000 - 1.000000`);
                return scaledValues;
            }
            
            // Values are already in appropriate range
            console.log('Transmittance values in appropriate range, no normalization needed');
            return values;
        }

        function searchDepthInGlobalText(buffer) {
            // Buscar información de profundidad en todo el archivo
            try {
                const uint8Array = new Uint8Array(buffer);
                const textContent = String.fromCharCode.apply(null, uint8Array.slice(0, Math.min(2048, buffer.byteLength)));
                
                // Search depth patterns
                const depthMatches = textContent.match(/spectrum\s+at\s+(\d+)\s*[μu]?m/gi);
                if (depthMatches) {
                    console.log('Depth metadata found:', depthMatches);
                    return depthMatches.map(match => {
                        const depthMatch = match.match(/(\d+)/);
                        return depthMatch ? parseInt(depthMatch[1]) : 0;
                    });
                }
                
                // Search other patterns
                const numberMatches = textContent.match(/(\d{3,5})\s*[μu]?m/gi);
                if (numberMatches) {
                    console.log('Possible depths found:', numberMatches);
                    return numberMatches.map(match => {
                        const depthMatch = match.match(/(\d+)/);
                        return depthMatch ? parseInt(depthMatch[1]) : 0;
                    }).filter(d => d > 0 && d < 50000);
                }
                
                return [];
            } catch (error) {
                console.warn('Error searching depths in text:', error);
                return [];
            }
        }

        function parseSPCBuffer(buffer, fileName) {
            try {
                const dataView = new DataView(buffer);
                let offset = 0;

                // Read complete SPC header
                const header = {
                    ftflgs: dataView.getUint8(offset),     // File type flags
                    fversn: dataView.getUint8(offset + 1), // Version
                    fexper: dataView.getUint8(offset + 2), // Experiment type
                    fexp: dataView.getInt8(offset + 3),    // Exponent for Y values
                    fnpts: dataView.getUint32(offset + 4, true),  // Number of points
                    ffirst: dataView.getFloat64(offset + 8, true), // First X value
                    flast: dataView.getFloat64(offset + 16, true), // Last X value
                    fnsub: dataView.getUint32(offset + 24, true),  // Number of subfiles
                    fxtype: dataView.getUint8(offset + 28), // X axis type
                    fytype: dataView.getUint8(offset + 29), // Y axis type
                    fztype: dataView.getUint8(offset + 30), // Z axis type
                    fpost: dataView.getUint8(offset + 31),  // Posting disposition
                    fdate: dataView.getUint32(offset + 32, true), // Date/time
                    flogoff: dataView.getUint32(offset + 304, true) // Log offset
                };

                console.log('SPC Header:', header);

                // Verify header validity
                if (header.fnpts <= 0 || header.fnpts > 100000) {
                    throw new Error('Invalid number of points in SPC file');
                }

                // Determine data format based on flags
                const hasXValues = (header.ftflgs & 0x01) !== 0;
                const isMultiFile = (header.ftflgs & 0x04) !== 0;
                
                console.log('SPC file analysis:', {
                    subspectra: header.fnsub,
                    points: header.fnpts,
                    hasXValues: hasXValues,
                    isMultiFile: isMultiFile,
                    flags: '0x' + header.ftflgs.toString(16),
                    flagsBinary: header.ftflgs.toString(2).padStart(8, '0'),
                    bufferSize: buffer.byteLength,
                    experiment: header.fexper,
                    version: header.fversn
                });

                let dataOffset = 512; // Standard header size
                const frequency = [];
                const transmittance = [];

                // Generate or read X values (frequencies/wavenumbers)
                if (hasXValues) {
                    // X values are stored in the file
                    for (let i = 0; i < header.fnpts; i++) {
                        if (dataOffset + 4 <= buffer.byteLength) {
                            frequency.push(dataView.getFloat32(dataOffset, true));
                            dataOffset += 4;
                        }
                    }
                } else {
                    // Generate uniformly spaced X values
                    for (let i = 0; i < header.fnpts; i++) {
                        const x = header.ffirst + (header.flast - header.ffirst) * i / (header.fnpts - 1);
                        frequency.push(x);
                    }
                }

                // Determine Y data size based on type
                let yDataSize = 4; // Default float32
                if (header.fytype === 0) yDataSize = 4; // float32
                else if (header.fytype === 1) yDataSize = 2; // int16
                else if (header.fytype === 2) yDataSize = 4; // int32

                // Handle multiple sub-files - extract ALL spectra
                const allSpectra = [];
                
                // Try to extract multiple spectra if fnsub > 1 (regardless of multi-file flag)
                if (header.fnsub > 1) {
                    console.log(`File with ${header.fnsub} sub-spectra, extracting all`);
                    
                    // Search for global depth metadata in the file
                    const globalDepths = searchDepthInGlobalText(buffer);
                    console.log('Global depths found:', globalDepths);
                    
                    // Calculate total data size per sub-spectrum
                    const pointsPerSpectrum = header.fnpts;
                    const bytesPerSpectrum = pointsPerSpectrum * yDataSize;
                    
                    for (let subIndex = 0; subIndex < header.fnsub; subIndex++) {
                        const subTransmittance = [];
                        
                        // Determine depth for this sub-spectrum
                        let extractedDepth;
                        if (globalDepths.length > subIndex) {
                            // Use specific depth found in metadata
                            extractedDepth = globalDepths[subIndex];
                        } else if (globalDepths.length > 0) {
                            // Interpolate between known depths
                            const step = globalDepths.length > 1 ? 
                                (globalDepths[globalDepths.length - 1] - globalDepths[0]) / (header.fnsub - 1) :
                                100; // 100μm default if only one depth
                            extractedDepth = globalDepths[0] + (subIndex * step);
                        } else {
                            // Default depth
                            extractedDepth = subIndex * 100;
                        }
                        
                        // Calculate offset for this sub-spectrum
                        let subDataOffset = dataOffset;
                        let subHeaderOffset = 0;
                        
                        if (isMultiFile) {
                            // In multi-file files, each sub-spectrum has its own 32-byte header
                            subHeaderOffset = dataOffset + (subIndex * (32 + bytesPerSpectrum));
                            subDataOffset = subHeaderOffset + 32;
                            
                            // Try to extract specific depth from sub-header
                            const headerDepth = extractDepthFromSubHeader(dataView, subHeaderOffset);
                            if (headerDepth !== null && headerDepth > 0) {
                                extractedDepth = headerDepth;
                            }
                        } else {
                            // Try different strategies for concatenated files
                            if (header.fexper === 1) {
                                // Type 1 experiment: directly concatenated data
                                subDataOffset = dataOffset + (subIndex * bytesPerSpectrum);
                            } else {
                                // Other types: may include headers between sub-spectra
                                subHeaderOffset = dataOffset + (subIndex * (bytesPerSpectrum + 32));
                                subDataOffset = subHeaderOffset + 32;
                                
                                // Try to extract depth from mini-header
                                if (subHeaderOffset + 32 <= buffer.byteLength) {
                                    const headerDepth = extractDepthFromSubHeader(dataView, subHeaderOffset);
                                    if (headerDepth !== null && headerDepth > 0) {
                                        extractedDepth = headerDepth;
                                    }
                                }
                            }
                        }
                        
                        console.log(`Sub-spectrum ${subIndex + 1}: offset=${subDataOffset}, depth=${extractedDepth}μm`);
                        
                        // Read Y data for this sub-spectrum
                        for (let i = 0; i < pointsPerSpectrum; i++) {
                            if (subDataOffset + yDataSize <= buffer.byteLength) {
                                let intensity;
                                
                                if (yDataSize === 4) {
                                    if (header.fytype === 2) {
                                        intensity = dataView.getInt32(subDataOffset, true);
                                    } else {
                                        intensity = dataView.getFloat32(subDataOffset, true);
                                    }
                                } else if (yDataSize === 2) {
                                    intensity = dataView.getInt16(subDataOffset, true);
                                } else {
                                    intensity = dataView.getUint8(subDataOffset);
                                }

                                // Apply exponent if specified
                                if (header.fexp !== 0) {
                                    intensity = intensity * Math.pow(2, header.fexp);
                                }

                                subTransmittance.push(intensity);
                                subDataOffset += yDataSize;
                            } else {
                                console.warn(`End of buffer reached in sub-spectrum ${subIndex}, point ${i}`);
                                break;
                            }
                        }
                        
                        if (subTransmittance.length > 0) {
                            // Normalize transmittance values to 0-1 scale
                            const normalizedTransmittance = normalizeTransmittanceValues(subTransmittance);
                            
                            allSpectra.push({
                                frequency: [...frequency], // Same frequency for all
                                transmittance: normalizedTransmittance,
                                label: `Depth_${extractedDepth}um`,
                                depth: extractedDepth
                            });
                            
                            console.log(`Sub-spectrum ${subIndex + 1}: ${subTransmittance.length} points, depth ${extractedDepth}μm, range: ${Math.min(...normalizedTransmittance).toFixed(3)} - ${Math.max(...normalizedTransmittance).toFixed(3)}`);
                        }
                    }
                    
                    if (allSpectra.length > 0) {
                        console.log(`Extracted ${allSpectra.length} spectra from SPC file`);
                        
                        // Return multiple spectra
                        return allSpectra.map(spectrum => ({
                            frequency: spectrum.frequency,
                            transmittance: spectrum.transmittance,
                            metadata: {
                                fileName: `${fileName}_${spectrum.label}`,
                                points: spectrum.frequency.length,
                                subspectra: header.fnsub,
                                experiment: header.fexper,
                                version: header.fversn,
                                depth: spectrum.depth,
                                isMultiSpectrum: true
                            }
                        }));
                    }
                }

                // Read Y data (intensities/transmittance)
                for (let i = 0; i < header.fnpts; i++) {
                    if (dataOffset + yDataSize <= buffer.byteLength) {
                        let intensity;
                        
                        if (yDataSize === 4) {
                            if (header.fytype === 2) {
                                intensity = dataView.getInt32(dataOffset, true);
                            } else {
                                intensity = dataView.getFloat32(dataOffset, true);
                            }
                        } else if (yDataSize === 2) {
                            intensity = dataView.getInt16(dataOffset, true);
                        } else {
                            intensity = dataView.getUint8(dataOffset);
                        }

                        // Apply exponent if specified
                        if (header.fexp !== 0) {
                            intensity = intensity * Math.pow(2, header.fexp);
                        }

                        transmittance.push(intensity);
                        dataOffset += yDataSize;
                    } else {
                        console.warn(`Data end reached at point ${i}/${header.fnpts}`);
                        break;
                    }
                }

                // Validate and clean data
                if (frequency.length === 0 || transmittance.length === 0) {
                    throw new Error('Could not extract valid data from SPC file');
                }

                // Ensure both arrays have the same length
                const minLength = Math.min(frequency.length, transmittance.length);
                const cleanFreq = frequency.slice(0, minLength);
                const cleanTrans = transmittance.slice(0, minLength);

                // Normalize transmittance values before validation
                const normalizedTrans = normalizeTransmittanceValues(cleanTrans);
                
                // Filter NaN or infinite values
                const validIndices = [];
                for (let i = 0; i < minLength; i++) {
                    if (isFinite(cleanFreq[i]) && isFinite(normalizedTrans[i])) {
                        validIndices.push(i);
                    }
                }

                if (validIndices.length === 0) {
                    throw new Error('No valid numerical data found');
                }

                const finalFreq = validIndices.map(i => cleanFreq[i]);
                const finalTrans = validIndices.map(i => normalizedTrans[i]);

                console.log('SPC parsing successful:', {
                    points: finalFreq.length,
                    firstX: finalFreq[0],
                    lastX: finalFreq[finalFreq.length - 1],
                    subspectra: header.fnsub,
                    experiment: header.fexper
                });

                return {
                    frequency: finalFreq,
                    transmittance: finalTrans,
                    metadata: {
                        fileName: fileName,
                        points: finalFreq.length,
                        subspectra: header.fnsub,
                        experiment: header.fexper,
                        version: header.fversn
                    }
                };
            } catch (error) {
                console.error('Error parsing SPC buffer:', error);
                throw new Error(`Error processing SPC file: ${error.message}`);
            }
        }

        async function processLoadedData(rawData) {
            console.log('Processing loaded data...');
            
            // Check if data has SPC format (frequency, transmittance, depth)
            if (rawData.length > 0 && rawData[0].length === 3 && typeof rawData[0][2] === 'number') {
                console.log('Detected SPC format with depth information');
                await processSPCMultiDepthData(rawData);
                return;
            }
            
            // Check if data is a single spectrum object from binary file
            if (rawData.length === 1 && rawData[0].frequency && rawData[0].transmittance) {
                console.log('Detected single binary spectrum');
                await processSingleSpectrumData(rawData[0]);
                return;
            }
            
            // Skip header row if option is checked
            const skipFirstRow = document.getElementById('skipFirstRow').checked;
            let dataRows = skipFirstRow ? rawData.slice(1) : rawData;
            
            // Filter empty rows
            dataRows = dataRows.filter(row => row && row.length > 0 && row.some(cell => cell !== null && cell !== ''));
            
            if (dataRows.length === 0) {
                throw new Error('No valid data rows found');
            }
            
            // Auto-detect columns if enabled
            const autoDetectColumns = document.getElementById('autoDetectColumns').checked;
            
            if (autoDetectColumns) {
                await autoDetectDataColumns(rawData, dataRows);
            } else {
                await showManualColumnMapping(rawData);
            }
        }

        async function processSPCMultiDepthData(rawData) {
            console.log('Processing multi-depth SPC data...');
            
            // Group data by depth
            const depthGroups = {};
            
            rawData.forEach(([frequency, transmittance, depth]) => {
                const depthKey = `${depth}μm`;
                
                if (!depthGroups[depthKey]) {
                    depthGroups[depthKey] = {
                        depth: depth,
                        frequency: [],
                        transmittance: []
                    };
                }
                
                depthGroups[depthKey].frequency.push(frequency);
                depthGroups[depthKey].transmittance.push(transmittance);
            });
            
            // Convert to spectraData format
            const spectraData = {};
            let colorIndex = 0;
            
            Object.entries(depthGroups).forEach(([depthKey, data]) => {
                spectraData[depthKey] = {
                    depth: data.depth,
                    frequency: data.frequency,
                    transmittance: data.transmittance,
                    originalTransmittance: [...data.transmittance], // Save original data to prevent contamination
                    color: generateDepthColor(colorIndex, Object.keys(depthGroups).length)
                };
                colorIndex++;
            });
            
            // Store in global state
            window.AppState.rawData = rawData;
            window.AppState.spectraData = spectraData;
            
            // Update sample file info in UI
            updateSampleFileInfo();
            
            // Update depth selectors for analysis tabs
            populateDepthSelectors();
            
            console.log(`SPC processing complete. ${Object.keys(spectraData).length} spectra at different depths:`, Object.keys(spectraData));
            
            // Show spectrum overview and processing controls
            await showSpectrumData();
        }

        async function processSingleSpectrumData(spectrumData) {
            console.log('Processing single spectrum data...');
            
            const spectraData = {
                'Surface (0μm)': {
                    depth: 0,
                    frequency: spectrumData.frequency,
                    transmittance: spectrumData.transmittance,
                    originalTransmittance: [...spectrumData.transmittance], // Save original data to prevent contamination
                    color: '#3498db'
                }
            };
            
            // Store in global state
            window.AppState.rawData = [[...spectrumData.frequency], [...spectrumData.transmittance]];
            window.AppState.spectraData = spectraData;
            
            // Update sample file info in UI
            updateSampleFileInfo();
            
            // Update depth selectors for analysis tabs
            populateDepthSelectors();
            
            console.log(`Single spectrum processing complete. ${spectrumData.frequency.length} data points`);
            
            // Show spectrum overview and processing controls
            await showSpectrumData();
        }

        function plotOverview() {
            const spectraData = window.AppState.spectraData;
            
            if (!spectraData || Object.keys(spectraData).length === 0) {
                console.log('No spectra data available for plotting');
                return;
            }
            
            const traces = [];
            let colorIndex = 0;
            
            Object.entries(spectraData).forEach(([label, data]) => {
                traces.push({
                    x: data.frequency,
                    y: data.transmittance,
                    type: 'scatter',
                    mode: 'lines',
                    name: label,
                    line: {
                        color: data.color || generateDepthColor(colorIndex, Object.keys(spectraData).length),
                        width: 2
                    },
                    hovertemplate: '<b>%{fullData.name}</b><br>' +
                                  'Frequency: %{x:.1f} cm⁻¹<br>' +
                                  'Transmittance: %{y:.4f}<br>' +
                                  '<extra></extra>'
                });
                colorIndex++;
            });
            
            const layout = {
                title: {
                    text: 'FTIR Spectra Overview - All Depths',
                    font: { size: 18, family: 'Segoe UI, sans-serif' }
                },
                xaxis: {
                    title: 'Wavenumber (cm⁻¹)',
                    autorange: 'reversed',
                    showgrid: true,
                    gridcolor: '#e0e0e0',
                    font: { size: 14 }
                },
                yaxis: {
                    title: 'Transmittance',
                    showgrid: true,
                    gridcolor: '#e0e0e0',
                    font: { size: 14 }
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white',
                font: { family: 'Segoe UI, sans-serif' },
                showlegend: true,
                legend: {
                    orientation: 'v',
                    x: 1.02,
                    y: 1,
                    font: { size: 11 },
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#cccccc',
                    borderwidth: 1,
                    itemsizing: 'constant',
                    itemwidth: 30,
                    tracegroupgap: 2
                },
                hovermode: 'closest',
                margin: { l: 60, r: 280, t: 60, b: 80 }
            };
            
            const config = {
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false,
                responsive: true,
                autosizable: true
            };
            
            // Find or create overview plot container
            let overviewPlot = document.getElementById('overviewPlot');
            if (!overviewPlot) {
                // Create overview plot container in the spectrum overview section
                const overviewSection = document.getElementById('spectrumOverview');
                if (overviewSection) {
                    overviewPlot = document.createElement('div');
                    overviewPlot.id = 'overviewPlot';
                    overviewPlot.style.height = '500px';
                    overviewPlot.style.width = '100%';
                    overviewPlot.style.marginBottom = '20px';
                    overviewPlot.style.overflowX = 'auto';
                    overviewSection.appendChild(overviewPlot);
                }
            }
            
            if (overviewPlot) {
                Plotly.newPlot(overviewPlot, traces, layout, config);
            }
        }

        async function showSpectrumData() {
            console.log('Displaying spectrum data...');
            
            // Show overview section
            document.getElementById('spectrumOverview').style.display = 'block';
            document.getElementById('processingControls').style.display = 'block';
            
            // Update spectrum list
            updateSpectrumList();
            
            // Plot overview
            plotOverview();
            
            // Enable processing buttons
            document.getElementById('clearDataBtn').disabled = false;
            
            showNotification('Spectrum data loaded successfully', 'success');
        }

        function updateSpectrumList() {
            const spectrumListElement = document.getElementById('spectrumList');
            const depthInfoElement = document.getElementById('depthInfo');
            
            if (!spectrumListElement || !depthInfoElement) return;
            
            const spectraData = window.AppState.spectraData;
            
            if (!spectraData || Object.keys(spectraData).length === 0) {
                spectrumListElement.innerHTML = '<p class="text-muted">No spectra loaded</p>';
                depthInfoElement.innerHTML = '<p class="text-muted">No data loaded</p>';
                return;
            }
            
            let html = '';
            const depths = [];
            
            Object.entries(spectraData).forEach(([label, data]) => {
                depths.push(data.depth);
                html += `
                    <div class="spectrum-item d-flex justify-content-between align-items-center p-2 border rounded mb-2">
                        <div>
                            <strong>${label}</strong>
                            <br>
                            <small class="text-muted">${data.frequency.length} data points</small>
                        </div>
                        <div class="spectrum-color" style="width: 20px; height: 20px; background-color: ${data.color}; border-radius: 3px;"></div>
                    </div>
                `;
            });
            
            spectrumListElement.innerHTML = html;
            
            // Update depth info
            const minDepth = Math.min(...depths);
            const maxDepth = Math.max(...depths);
            const depthRange = minDepth === maxDepth ? `${minDepth} μm` : `${minDepth} - ${maxDepth} μm`;
            
            depthInfoElement.innerHTML = `
                <div class="row">
                    <div class="col-6">
                        <strong>Spectra Count:</strong><br>
                        <span class="text-primary">${Object.keys(spectraData).length}</span>
                    </div>
                    <div class="col-6">
                        <strong>Depth Range:</strong><br>
                        <span class="text-primary">${depthRange}</span>
                    </div>
                </div>
            `;
        }

        async function autoDetectDataColumns(rawData, dataRows) {
            console.log('Auto-detecting columns...');
            
            // Find frequency column (usually first column with numerical data)
            let frequencyColumn = 0;
            const firstRow = dataRows[1] || dataRows[0];
            
            for (let i = 0; i < firstRow.length; i++) {
                if (typeof firstRow[i] === 'number' && firstRow[i] > 0) {
                    frequencyColumn = i;
                    break;
                }
            }
            
            // Find depth columns (all other numerical columns)
            const depthColumns = [];
            for (let i = 0; i < firstRow.length; i++) {
                if (i !== frequencyColumn && typeof firstRow[i] === 'number') {
                    depthColumns.push(i);
                }
            }
            
            if (depthColumns.length === 0) {
                throw new Error('No depth columns detected. Use manual column mapping.');
            }
            
            // Extract frequency and depth data
            const frequencies = dataRows.map(row => row[frequencyColumn]).filter(val => typeof val === 'number');
            const spectraData = {};
            
            // Generate depth labels following .dpt convention (01 = 100μm, 02 = 200μm, etc.)
            depthColumns.forEach((colIndex, i) => {
                const depthValue = (i) * 100; // 100μm, 200μm, 300μm, etc.
                const depthLabel = `${depthValue}μm`;
                const transmittanceValues = dataRows.map(row => row[colIndex]).filter(val => typeof val === 'number');
                
                if (transmittanceValues.length === frequencies.length) {
                    spectraData[depthLabel] = {
                        depth: depthValue,
                        frequency: frequencies,
                        transmittance: transmittanceValues,
                        originalTransmittance: [...transmittanceValues], // Save original data to prevent contamination
                        color: generateDepthColor(i, depthColumns.length)
                    };
                }
            });
            
            // Store in global state
            window.AppState.rawData = rawData;
            window.AppState.spectraData = spectraData;
            
            console.log('Auto-detection complete. Spectra found:', Object.keys(spectraData));
        }

        function generateDepthColor(index, total) {
            // Generate gradient colors from blue (surface) to red (deep)
            const hue = 240 - (index / (total - 1)) * 180; // 240° (blue) to 60° (red)
            const saturation = 70;
            const lightness = 50;
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        function showSpectrumOverview() {
            document.getElementById('spectrumOverview').style.display = 'block';
            updateSpectrumList();
            updateDepthInfo();
            plotSpectraOverview();
            updateAllAnalysisPlots();
        }

        function updateSpectrumList() {
            const spectrumList = document.getElementById('spectrumList');
            const spectraData = window.AppState.spectraData;
            
            spectrumList.innerHTML = '';
            
            Object.entries(spectraData).forEach(([label, data]) => {
                const item = document.createElement('div');
                item.className = 'spectrum-item';
                item.innerHTML = `
                    <div class="spectrum-info">
                        <div class="spectrum-color-indicator" style="background-color: ${data.color}"></div>
                        <div class="spectrum-details">
                            <div class="spectrum-name">${label}</div>
                            <div class="spectrum-depth">${data.frequency.length} data points</div>
                        </div>
                    </div>
                    <div class="spectrum-controls">
                        <button class="btn btn-outline-primary btn-sm" onclick="toggleSpectrum('${label}')">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                `;
                spectrumList.appendChild(item);
            });
        }

        function updateDepthInfo() {
            const depthInfo = document.getElementById('depthInfo');
            const spectraData = window.AppState.spectraData;
            
            const depths = Object.values(spectraData).map(data => data.depth).sort((a, b) => a - b);
            const minDepth = Math.min(...depths);
            const maxDepth = Math.max(...depths);
            const numSpectra = Object.keys(spectraData).length;
            
            depthInfo.innerHTML = `
                <div class="depth-info-item">
                    <span>Number of Spectra:</span>
                    <span class="depth-value">${numSpectra}</span>
                </div>
                <div class="depth-info-item">
                    <span>Depth Range:</span>
                    <span class="depth-value">${minDepth} - ${maxDepth} μm</span>
                </div>
                <div class="depth-info-item">
                    <span>Frequency Range:</span>
                    <span class="depth-value">${getFrequencyRange()}</span>
                </div>
            `;
        }

        function getFrequencyRange() {
            const spectraData = window.AppState.spectraData;
            const firstSpectrum = Object.values(spectraData)[0];
            if (!firstSpectrum) return 'N/A';
            
            const frequencies = firstSpectrum.frequency;
            const min = Math.min(...frequencies);
            const max = Math.max(...frequencies);
            return `${min.toFixed(0)} - ${max.toFixed(0)} cm⁻¹`;
        }

        function enableProcessingControls() {
            document.getElementById('processingControls').style.display = 'block';
            document.getElementById('analysisSection').style.display = 'block';
            updateProcessingStatus('Data loaded successfully', true);
        }

        function clearAllData() {
            // Reiniciar estado global
            window.AppState = {
                rawData: null,
                processedData: null,
                spectraData: {},
                analysisResults: {
                    oxidation: {},
                    crystallinity: {},
                    tvi: {}
                },
                processingStatus: {
                    offsetCorrected: false,
                    baselineCorrected: false
                }
            };
            
            // Ocultar secciones
            document.getElementById('spectrumOverview').style.display = 'none';
            document.getElementById('processingControls').style.display = 'none';
            document.getElementById('analysisSection').style.display = 'none';
            
            // Reiniciar controles
            document.getElementById('fileInput').value = '';
            document.getElementById('loadDataBtn').disabled = true;
            document.getElementById('clearDataBtn').disabled = true;
            document.getElementById('columnMapping').style.display = 'none';
            
            updateProcessingStatus('Ready to process', true);
            
            console.log('All data cleared');
        }

        function toggleSpectrum(label) {
            // Toggle visibility functionality
            console.log('Alternando visibilidad del espectro:', label);
        }

        // Visualization Functions
        function plotSpectraOverview() {
            const plotElement = document.getElementById('overviewPlot');
            const spectraData = window.AppState.spectraData;
            
            if (!plotElement || !spectraData || Object.keys(spectraData).length === 0) {
                return;
            }
            
            const traces = [];
            
            Object.entries(spectraData).forEach(([label, data]) => {
                traces.push({
                    x: data.frequency,
                    y: data.transmittance,
                    type: 'scatter',
                    mode: 'lines',
                    name: label,
                    line: {
                        color: data.color,
                        width: 2
                    },
                    hovertemplate: `
                        <b>${label}</b><br>
                        Wavenumber: %{x:.1f} cm⁻¹<br>
                        Transmittance: %{y:.4f}<br>
                        <extra></extra>
                    `
                });
            });
            
            const layout = {
                title: 'FTIR Spectra Overview - All Depths',
                xaxis: {
                    title: 'Wavenumber (cm⁻¹)',
                    autorange: 'reversed',
                    showgrid: true,
                    gridcolor: '#e2e8f0'
                },
                yaxis: {
                    title: 'Transmittance',
                    showgrid: true,
                    gridcolor: '#e2e8f0'
                },
                hovermode: 'closest',
                showlegend: true,
                legend: {
                    orientation: 'v',
                    x: 1.02,
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#e2e8f0',
                    borderwidth: 1
                },
                margin: {
                    r: 150
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
                displaylogo: false
            };
            
            Plotly.newPlot(plotElement, traces, layout, config);
        }

        // Spectrum Processing Functions
        function performAutoOffset() {
            if (!window.AppState.spectraData || Object.keys(window.AppState.spectraData).length === 0) {
                alert('No hay datos de espectro cargados');
                return;
            }
            
            showLoading('Realizando corrección automática de offset...');
            updateProcessingStatus('Corrección de offset', false);
            
            try {
                const spectraData = window.AppState.spectraData;
                const correctedData = {};
                
                Object.entries(spectraData).forEach(([label, data]) => {
                    const correctedTransmittance = applyOffsetCorrection(data.transmittance);
                    correctedData[label] = {
                        ...data,
                        transmittance: correctedTransmittance,
                        originalTransmittance: [...data.transmittance] // Mantener original para referencia
                    };
                });
                
                window.AppState.spectraData = correctedData;
                window.AppState.processingStatus.offsetCorrected = true;
                
                // Actualizar visualización
                plotSpectraOverview();
                updateAllAnalysisPlots();
                updateProcessingStatus('Offset correction completed', true);
                
                console.log('Corrección automática de offset completada');
                
            } catch (error) {
                console.error('Error en corrección de offset:', error);
                alert(`Error en corrección de offset: ${error.message}`);
                updateProcessingStatus('Error en corrección de offset', false);
            } finally {
                hideLoading();
            }
        }

        function applyOffsetCorrection(transmittance) {
            // Encontrar valor mínimo y restarlo de todos los puntos
            const minValue = Math.min(...transmittance);
            return transmittance.map(value => value - minValue);
        }

        function enableManualOffset() {
            if (!window.AppState.spectraData || Object.keys(window.AppState.spectraData).length === 0) {
                alert('No hay datos de espectro cargados');
                return;
            }
            
            showManualOffsetInterface();
        }

        function showManualOffsetInterface() {
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.tabIndex = -1;
            modal.innerHTML = `
                <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-hand-pointer me-2"></i>Corrección Manual de Offset
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="row">
                                <div class="col-md-8">
                                    <div id="manualOffsetPlot" style="height: 400px;"></div>
                                </div>
                                <div class="col-md-4">
                                    <h6>Select Spectrum</h6>
                                    <select class="form-select mb-3" id="offsetSpectrumSelect">
                                        <option value="">Select spectrum...</option>
                                    </select>
                                    
                                    <h6>Offset Value</h6>
                                    <div class="input-group mb-3">
                                        <input type="number" class="form-control" id="manualOffsetValue" 
                                               placeholder="Offset value" step="0.001">
                                        <button class="btn btn-outline-primary" onclick="applyManualOffset()">Apply</button>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <button class="btn btn-success w-100" onclick="applyManualOffsetToAll()">
                                            Apply to All Spectra
                                        </button>
                                    </div>
                                    
                                    <div class="alert alert-info">
                                        <small>
                                            <strong>Instrucciones:</strong><br>
                                            1. Seleccione un espectro<br>
                                            2. Observe el valor mínimo actual<br>
                                            3. Ajuste el valor de offset<br>
                                            4. Aplique a espectro individual o todos
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            const modalInstance = new bootstrap.Modal(modal);
            modalInstance.show();
            
            // Llenar selector de espectros
            const select = modal.querySelector('#offsetSpectrumSelect');
            Object.keys(window.AppState.spectraData).forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                select.appendChild(option);
            });
            
            // Event listener para cambio de espectro
            select.addEventListener('change', function() {
                if (this.value) {
                    plotSpectrumForManualOffset(this.value);
                }
            });
            
            modal.addEventListener('hidden.bs.modal', function () {
                document.body.removeChild(modal);
            });
        }

        function plotSpectrumForManualOffset(spectrumLabel) {
            const plotElement = document.querySelector('#manualOffsetPlot');
            const spectrumData = window.AppState.spectraData[spectrumLabel];
            
            if (!plotElement || !spectrumData) return;
            
            const minValue = Math.min(...spectrumData.transmittance);
            document.querySelector('#manualOffsetValue').value = minValue.toFixed(4);
            
            const trace = {
                x: spectrumData.frequency,
                y: spectrumData.transmittance,
                type: 'scatter',
                mode: 'lines',
                name: spectrumLabel,
                line: {
                    color: spectrumData.color,
                    width: 2
                }
            };
            
            const layout = {
                title: `Espectro: ${spectrumLabel} (Mín: ${minValue.toFixed(4)})`,
                xaxis: {
                    title: 'Número de Onda (cm⁻¹)',
                    autorange: 'reversed'
                },
                yaxis: {
                    title: 'Transmitancia'
                },
                showlegend: false
            };
            
            Plotly.newPlot(plotElement, [trace], layout, { responsive: true });
        }

        function applyManualOffset() {
            const spectrumLabel = document.querySelector('#offsetSpectrumSelect').value;
            const offsetValue = parseFloat(document.querySelector('#manualOffsetValue').value);
            
            if (!spectrumLabel || isNaN(offsetValue)) {
                alert('Por favor seleccione un espectro y especifique un valor de offset válido');
                return;
            }
            
            const spectrumData = window.AppState.spectraData[spectrumLabel];
            spectrumData.originalTransmittance = [...spectrumData.transmittance];
            spectrumData.transmittance = spectrumData.transmittance.map(val => val - offsetValue);
            
            plotSpectrumForManualOffset(spectrumLabel);
        }

        function applyManualOffsetToAll() {
            const offsetValue = parseFloat(document.querySelector('#manualOffsetValue').value);
            
            if (isNaN(offsetValue)) {
                alert('Por favor especifique un valor de offset válido');
                return;
            }
            
            Object.entries(window.AppState.spectraData).forEach(([label, data]) => {
                data.originalTransmittance = [...data.transmittance];
                data.transmittance = data.transmittance.map(val => val - offsetValue);
            });
            
            window.AppState.processingStatus.offsetCorrected = true;
            plotSpectraOverview();
            updateAllAnalysisPlots();
            updateProcessingStatus('Offset manual aplicado a todos los espectros', true);
        }

        // Función de línea base manual
        function enableManualBaseline(analysisType) {
            if (!window.AppState.spectraData || Object.keys(window.AppState.spectraData).length === 0) {
                alert('No hay datos de espectro cargados');
                return;
            }
            
            if (!window.AppState.processingStatus.offsetCorrected) {
                alert('Por favor realice la corrección de offset primero');
                return;
            }
            
            showManualBaselineInterface(analysisType);
        }

        function showManualBaselineInterface(analysisType) {
            const parameters = getAnalysisParameters(analysisType);
            
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.tabIndex = -1;
            modal.innerHTML = `
                <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-hand-pointer me-2"></i>Corrección Manual de Línea Base - ${parameters.name}
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="row">
                                <div class="col-md-8">
                                    <div id="manualBaselinePlot" style="height: 500px;"></div>
                                </div>
                                <div class="col-md-4">
                                    <h6>Select Spectrum</h6>
                                    <select class="form-select mb-3" id="baselineSpectrumSelect">
                                        <option value="">Select spectrum...</option>
                                    </select>
                                    
                                    <h6>Analysis Region</h6>
                                    <div class="mb-3">
                                        <label class="form-label">Region Type</label>
                                        <select class="form-select" id="regionType">
                                            <option value="interest">Interest Peak (${parameters.interestPeak.min}-${parameters.interestPeak.max} cm⁻¹)</option>
                                            <option value="reference">Reference Peak (${parameters.referencePeak.min}-${parameters.referencePeak.max} cm⁻¹)</option>
                                        </select>
                                    </div>
                                    
                                    <h6>Método de Línea Base</h6>
                                    <div class="mb-3">
                                        <select class="form-select" id="baselineMethod">
                                            <option value="linear">Lineal (2 puntos)</option>
                                            <option value="polynomial">Polinomial (múltiples puntos)</option>
                                        </select>
                                    </div>
                                    
                                    <div class="mb-3">
                                        <button class="btn btn-warning w-100 mb-2" onclick="clearBaselinePoints()">
                                            <i class="fas fa-eraser me-1"></i>Clear Points
                                        </button>
                                        <button class="btn btn-success w-100 mb-2" onclick="applyManualBaseline()">
                                            <i class="fas fa-check me-1"></i>Apply Correction
                                        </button>
                                        <button class="btn btn-info w-100 mb-2" onclick="previewBaseline()">
                                            <i class="fas fa-eye me-1"></i>Preview
                                        </button>
                                        <button class="btn btn-secondary w-100" onclick="autoDetectBaselinePoints()">
                                            <i class="fas fa-magic me-1"></i>Auto Detection
                                        </button>
                                    </div>
                                    
                                    <div class="alert alert-info">
                                        <small>
                                            <strong>Instrucciones:</strong><br>
                                            1. Seleccione un espectro y región<br>
                                            2. Haga clic en el gráfico para seleccionar puntos de línea base<br>
                                            3. Use vista previa para verificar<br>
                                            4. Aplique la corrección
                                        </small>
                                    </div>
                                    
                                    <div id="selectedPointsList" class="mt-3">
                                        <h6>Puntos Seleccionados:</h6>
                                        <div id="pointsContainer" class="selected-points-container">
                                            <p class="text-muted small">Seleccione puntos en el gráfico</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cerrar</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            const modalInstance = new bootstrap.Modal(modal);
            modalInstance.show();
            
            // Inicializar estado con almacenamiento independiente por espectro
            window.manualBaselineState = {
                selectedPoints: {},  // Cambiar a objeto para almacenar por espectro
                currentSpectrum: null,
                currentRegion: 'interest',
                analysisType: analysisType
            };
            
            // Llenar selector de espectros
            const select = modal.querySelector('#baselineSpectrumSelect');
            const spectraKeys = Object.keys(window.AppState.spectraData);
            spectraKeys.forEach(label => {
                const option = document.createElement('option');
                option.value = label;
                option.textContent = label;
                select.appendChild(option);
            });
            
            // Inicializar automáticamente con el primer espectro
            if (spectraKeys.length > 0) {
                const firstSpectrum = spectraKeys[0];
                select.value = firstSpectrum;
                window.manualBaselineState.currentSpectrum = firstSpectrum;
                
                // Inicializar puntos para el primer espectro
                const currentKey = `${firstSpectrum}_${window.manualBaselineState.currentRegion}`;
                if (!window.manualBaselineState.selectedPoints[currentKey]) {
                    window.manualBaselineState.selectedPoints[currentKey] = [];
                }
                
                // Plotear inmediatamente
                updatePointsList();
                plotSpectrumForManualBaseline();
            }
            
            // Event listeners
            select.addEventListener('change', function() {
                if (this.value) {
                    window.manualBaselineState.currentSpectrum = this.value;
                    // Cargar puntos específicos para este espectro y región
                    const currentKey = `${this.value}_${window.manualBaselineState.currentRegion}`;
                    if (!window.manualBaselineState.selectedPoints[currentKey]) {
                        window.manualBaselineState.selectedPoints[currentKey] = [];
                    }
                    updatePointsList();
                    plotSpectrumForManualBaseline();
                }
            });
            
            modal.querySelector('#regionType').addEventListener('change', function() {
                window.manualBaselineState.currentRegion = this.value;
                // Limpiar puntos solo para el espectro y región actual
                const currentKey = `${window.manualBaselineState.currentSpectrum}_${this.value}`;
                if (!window.manualBaselineState.selectedPoints[currentKey]) {
                    window.manualBaselineState.selectedPoints[currentKey] = [];
                }
                updatePointsList();
                if (window.manualBaselineState.currentSpectrum) {
                    plotSpectrumForManualBaseline();
                }
            });
            
            modal.addEventListener('hidden.bs.modal', function () {
                delete window.manualBaselineState;
                document.body.removeChild(modal);
            });
        }

        function plotSpectrumForManualBaseline() {
            const plotElement = document.querySelector('#manualBaselinePlot');
            const spectrumLabel = window.manualBaselineState.currentSpectrum;
            const regionType = window.manualBaselineState.currentRegion;
            const analysisType = window.manualBaselineState.analysisType;
            
            if (!plotElement || !spectrumLabel) return;
            
            const spectrumData = window.AppState.spectraData[spectrumLabel];
            const parameters = getAnalysisParameters(analysisType);
            
            let regionData;
            if (regionType === 'interest') {
                regionData = cropSpectrum(spectrumData, parameters.interestPeak.min, parameters.interestPeak.max);
            } else {
                regionData = cropSpectrum(spectrumData, parameters.referencePeak.min, parameters.referencePeak.max);
            }
            
            // Guardar datos de región actual para uso en clicks
            window.manualBaselineState.currentRegionData = regionData;
            
            // Agregar clase de modo selección visual
            plotElement.classList.add('baseline-selection-mode');
            
            const traces = [{
                x: regionData.frequency,
                y: regionData.transmittance,
                type: 'scatter',
                mode: 'lines',
                name: `${spectrumLabel} - ${regionType === 'interest' ? 'Interés' : 'Referencia'}`,
                line: {
                    color: '#2980b9',
                    width: 4
                },
                hovertemplate: '<b>%{fullData.name}</b><br>' +
                              'Wavenumber: %{x:.1f} cm⁻¹<br>' +
                              'Transmittance: %{y:.4f}<br>' +
                              '<extra></extra>'
            }];
            
            // Agregar puntos seleccionados con visualización mejorada
            const currentKey = `${spectrumLabel}_${regionType}`;
            const currentPoints = window.manualBaselineState.selectedPoints[currentKey] || [];
            if (currentPoints.length > 0) {
                const pointsX = currentPoints.map(p => p.x);
                const pointsY = currentPoints.map(p => p.y);
                
                traces.push({
                    x: pointsX,
                    y: pointsY,
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Puntos de Línea Base',
                    marker: {
                        color: '#f39c12',
                        size: 14,
                        symbol: 'diamond',
                        line: {
                            color: '#d35400',
                            width: 3
                        }
                    },
                    hovertemplate: '<b>Punto de Línea Base %{pointIndex:+1}</b><br>' +
                                  'Wavenumber: %{x:.1f} cm⁻¹<br>' +
                                  'Transmittance: %{y:.4f}<br>' +
                                  '<extra></extra>'
                });
                
                // Añadir línea base calculada si hay suficientes puntos
                if (pointsX.length >= 2) {
                    const baselineCurve = calculateBaselineCurve(pointsX, pointsY, regionData.frequency);
                    if (baselineCurve && baselineCurve.x.length > 0) {
                        traces.push({
                            x: baselineCurve.x,
                            y: baselineCurve.y,
                            type: 'scatter',
                            mode: 'lines',
                            name: 'Línea Base Calculada',
                            line: {
                                color: '#27ae60',
                                width: 4,
                                dash: 'dot'
                            },
                            hovertemplate: '<b>Línea Base</b><br>' +
                                          'Wavenumber: %{x:.1f} cm⁻¹<br>' +
                                          'Value: %{y:.4f}<br>' +
                                          '<extra></extra>'
                        });
                    }
                }
            }
            
            const layout = {
                title: {
                    text: `🎯 Línea Base: ${spectrumLabel} - ${regionType === 'interest' ? 'Región de Interés' : 'Región de Referencia'}`,
                    font: { size: 18, color: '#2c3e50', family: 'Arial Black' }
                },
                xaxis: {
                    title: {
                        text: 'Número de Onda (cm⁻¹)',
                        font: { size: 16, color: '#34495e' }
                    },
                    autorange: 'reversed',
                    gridcolor: '#bdc3c7',
                    showgrid: true,
                    linecolor: '#34495e',
                    linewidth: 2
                },
                yaxis: {
                    title: {
                        text: 'Transmittance',
                        font: { size: 16, color: '#34495e' }
                    },
                    gridcolor: '#bdc3c7',
                    showgrid: true,
                    linecolor: '#34495e',
                    linewidth: 2
                },
                showlegend: true,
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#95a5a6',
                    borderwidth: 1
                },
                hovermode: 'closest',
                plot_bgcolor: 'rgba(248, 249, 250, 0.6)',
                paper_bgcolor: 'white',
                font: { family: 'Arial, sans-serif', size: 12 },
                margin: { t: 80, r: 50, b: 80, l: 90 },
                annotations: [{
                    text: `Puntos seleccionados: ${currentPoints.length}`,
                    x: 0.98,
                    y: 0.02,
                    xref: 'paper',
                    yref: 'paper',
                    xanchor: 'right',
                    yanchor: 'bottom',
                    showarrow: false,
                    font: { size: 12, color: '#7f8c8d' },
                    bgcolor: 'rgba(255,255,255,0.8)',
                    bordercolor: '#bdc3c7',
                    borderwidth: 1
                }]
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d', 'autoScale2d'],
                displaylogo: false,
                toImageButtonOptions: {
                    format: 'png',
                    filename: `FTIR_baseline_${spectrumLabel}_${regionType}`,
                    height: 700,
                    width: 1200,
                    scale: 2
                }
            };
            
            Plotly.newPlot(plotElement, traces, layout, config);
            
            // Event listener mejorado para clicks en el gráfico usando Plotly events
            plotElement.removeAllListeners && plotElement.removeAllListeners('plotly_click');
            plotElement.on('plotly_click', function(data) {
                if (!data.points || data.points.length === 0) return;
                
                const point = data.points[0];
                let selectedX, selectedY;
                
                // Usar las coordenadas exactas del punto clickeado
                if (point.data && point.data.name && (point.data.name.includes('Espectro') || point.data.name.includes('Interés') || point.data.name.includes('Referencia'))) {
                    // Click directo en una línea del espectro - usar índice exacto
                    const pointIndex = point.pointIndex;
                    selectedX = regionData.frequency[pointIndex];
                    selectedY = regionData.transmittance[pointIndex];
                } else {
                    // Click en área vacía - encontrar punto más cercano con mejor precisión
                    selectedX = point.x;
                    selectedY = point.y;
                    
                    // Encontrar el índice más cercano usando distancia euclidiana normalizada
                    let closestIndex = 0;
                    let minDistance = Infinity;
                    
                    const xRange = Math.max(...regionData.frequency) - Math.min(...regionData.frequency);
                    const yRange = Math.max(...regionData.transmittance) - Math.min(...regionData.transmittance);
                    
                    regionData.frequency.forEach((freq, index) => {
                        const xDist = Math.abs(freq - selectedX) / xRange;
                        const yDist = Math.abs(regionData.transmittance[index] - selectedY) / yRange;
                        
                        // Priorizar proximidad en X (número de onda) para línea base
                        const distance = Math.sqrt(xDist * xDist * 0.8 + yDist * yDist * 0.2);
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestIndex = index;
                        }
                    });
                    
                    selectedX = regionData.frequency[closestIndex];
                    selectedY = regionData.transmittance[closestIndex];
                }
                
                // Verificar que el punto no esté ya seleccionado
                const tolerance = Math.abs(regionData.frequency[1] - regionData.frequency[0]) * 2;
                const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
                const currentPoints = window.manualBaselineState.selectedPoints[currentKey] || [];
                const pointExists = currentPoints.some(p => 
                    Math.abs(p.x - selectedX) < tolerance
                );
                
                if (!pointExists) {
                    const selectedPoint = {
                        x: selectedX,
                        y: selectedY,
                        index: regionData.frequency.findIndex(f => Math.abs(f - selectedX) < tolerance)
                    };
                    
                    // La clave ya está definida arriba, usar la misma
                    if (!window.manualBaselineState.selectedPoints[currentKey]) {
                        window.manualBaselineState.selectedPoints[currentKey] = [];
                    }
                    window.manualBaselineState.selectedPoints[currentKey].push(selectedPoint);
                    
                    // Ordenar puntos por número de onda (de mayor a menor para FTIR)
                    window.manualBaselineState.selectedPoints[currentKey].sort((a, b) => b.x - a.x);
                    
                    updatePointsList();
                    plotSpectrumForManualBaseline();
                    
                    // Feedback visual
                    showBaselinePointFeedback(selectedX, selectedY);
                } else {
                    showNotification('Punto ya seleccionado en esa región', 'warning');
                }
            });
        }

        function calculateBaselineCurve(pointsX, pointsY, allFrequencies) {
            try {
                if (pointsX.length < 2) return null;
                
                // Ordenar puntos por frecuencia
                const sortedPoints = pointsX.map((x, i) => ({x, y: pointsY[i]}))
                    .sort((a, b) => b.x - a.x); // Orden descendente para FTIR
                
                const method = document.querySelector('#baselineMethod')?.value || 'linear';
                
                // Filtrar frecuencias dentro del rango de puntos seleccionados
                const minX = Math.min(...pointsX);
                const maxX = Math.max(...pointsX);
                const filteredFreq = allFrequencies.filter(f => f >= minX && f <= maxX);
                
                if (filteredFreq.length === 0) return null;
                
                let baselineY = [];
                
                if (method === 'linear' && sortedPoints.length >= 2) {
                    // Interpolación lineal entre primer y último punto
                    const x1 = sortedPoints[0].x, y1 = sortedPoints[0].y;
                    const x2 = sortedPoints[sortedPoints.length - 1].x, y2 = sortedPoints[sortedPoints.length - 1].y;
                    const slope = (y2 - y1) / (x2 - x1);
                    
                    baselineY = filteredFreq.map(x => y1 + slope * (x - x1));
                    
                } else if (method === 'polynomial' && sortedPoints.length >= 3) {
                    // Interpolación polinómica de orden 2 o 3
                    const order = Math.min(3, sortedPoints.length - 1);
                    baselineY = polynomialInterpolation(sortedPoints, filteredFreq, order);
                    
                } else if (method === 'cubic' && sortedPoints.length >= 4) {
                    // Interpolación cúbica spline
                    baselineY = cubicSplineInterpolation(sortedPoints, filteredFreq);
                    
                } else {
                    // Fallback a interpolación lineal por tramos
                    baselineY = piecewiseLinearInterpolation(sortedPoints, filteredFreq);
                }
                
                return {
                    x: [...filteredFreq],
                    y: baselineY
                };
                
            } catch (error) {
                console.error('Error calculando línea base:', error);
                return null;
            }
        }

        function polynomialInterpolation(points, xValues, order) {
            // Implementación simplificada de interpolación polinómica
            const n = points.length;
            const result = [];
            
            for (let x of xValues) {
                let y = 0;
                for (let i = 0; i < n; i++) {
                    let term = points[i].y;
                    for (let j = 0; j < n; j++) {
                        if (i !== j) {
                            term *= (x - points[j].x) / (points[i].x - points[j].x);
                        }
                    }
                    y += term;
                }
                result.push(y);
            }
            return result;
        }

        function piecewiseLinearInterpolation(points, xValues) {
            const result = [];
            
            for (let x of xValues) {
                // Encontrar los dos puntos más cercanos
                let leftPoint = points[0];
                let rightPoint = points[points.length - 1];
                
                for (let i = 0; i < points.length - 1; i++) {
                    if (x >= points[i+1].x && x <= points[i].x) {
                        leftPoint = points[i+1];
                        rightPoint = points[i];
                        break;
                    }
                }
                
                // Interpolación lineal
                const slope = (rightPoint.y - leftPoint.y) / (rightPoint.x - leftPoint.x);
                const y = leftPoint.y + slope * (x - leftPoint.x);
                result.push(y);
            }
            
            return result;
        }

        function cubicSplineInterpolation(points, xValues) {
            // Implementación simplificada de spline cúbico
            // Para simplificar, usar interpolación lineal por tramos
            return piecewiseLinearInterpolation(points, xValues);
        }

        function updatePointsList() {
            const container = document.querySelector('#pointsContainer');
            if (!container) return;
            
            const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
            const points = window.manualBaselineState.selectedPoints[currentKey] || [];
            
            if (points.length === 0) {
                container.innerHTML = '<p class="text-muted small">Seleccione puntos en el gráfico</p>';
                return;
            }
            
            let html = '';
            points.forEach((point, index) => {
                html += `
                    <div class="selected-point-item">
                        <span><strong>Punto ${index + 1}:</strong> ${point.x.toFixed(1)} cm⁻¹, ${point.y.toFixed(4)}</span>
                        <span class="delete-point" onclick="removeBaselinePoint(${index})">
                            <i class="fas fa-times"></i>
                        </span>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }

        function removeBaselinePoint(index) {
            const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
            if (window.manualBaselineState.selectedPoints[currentKey]) {
                window.manualBaselineState.selectedPoints[currentKey].splice(index, 1);
            }
            updatePointsList();
            plotSpectrumForManualBaseline();
        }

        function showBaselinePointFeedback(x, y) {
            // Crear notificación temporal en el gráfico
            const plotElement = document.getElementById('manualBaselinePlot');
            if (!plotElement) return;
            
            const feedback = document.createElement('div');
            feedback.className = 'baseline-point-feedback';
            feedback.innerHTML = `
                <i class="fas fa-crosshairs"></i>
                <span>Punto añadido: ${x.toFixed(1)} cm⁻¹</span>
            `;
            feedback.style.cssText = `
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(46, 204, 113, 0.9);
                color: white;
                padding: 8px 12px;
                border-radius: 20px;
                font-size: 12px;
                font-weight: 600;
                z-index: 1000;
                animation: fadeInOut 2s ease-in-out;
            `;
            
            // Añadir estilo de animación si no existe
            if (!document.getElementById('baselineFeedbackStyle')) {
                const style = document.createElement('style');
                style.id = 'baselineFeedbackStyle';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translateX(20px); }
                        20% { opacity: 1; transform: translateX(0); }
                        80% { opacity: 1; transform: translateX(0); }
                        100% { opacity: 0; transform: translateX(-20px); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            plotElement.style.position = 'relative';
            plotElement.appendChild(feedback);
            
            setTimeout(() => {
                if (feedback.parentNode) {
                    feedback.parentNode.removeChild(feedback);
                }
            }, 2000);
        }

        function showNotification(message, type = 'info') {
            // Crear notificación toast mejorada
            const notification = document.createElement('div');
            notification.className = `toast align-items-center text-white bg-${type === 'error' ? 'danger' : type} border-0`;
            notification.setAttribute('role', 'alert');
            notification.style.cssText = 'position: fixed; top: 20px; right: 20px; z-index: 10000; min-width: 300px;';
            
            notification.innerHTML = `
                <div class="d-flex">
                    <div class="toast-body">
                        <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'warning' ? 'exclamation-triangle' : type === 'error' ? 'times-circle' : 'info-circle'} me-2"></i>
                        ${message}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            `;
            
            document.body.appendChild(notification);
            const toast = new bootstrap.Toast(notification, { delay: 4000 });
            toast.show();
            
            notification.addEventListener('hidden.bs.toast', () => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            });
        }

        function clearBaselinePoints() {
            const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
            window.manualBaselineState.selectedPoints[currentKey] = [];
            updatePointsList();
            plotSpectrumForManualBaseline();
        }

        function autoDetectBaselinePoints() {
            if (!window.manualBaselineState.currentRegionData) {
                showNotification('Seleccione un espectro primero', 'warning');
                return;
            }

            try {
                const regionData = window.manualBaselineState.currentRegionData;
                const frequency = regionData.frequency;
                const transmittance = regionData.transmittance;
                const n = frequency.length;

                if (n < 10) {
                    throw new Error('No hay suficientes datos para la detección automática');
                }

                // Limpiar puntos existentes
                window.manualBaselineState.selectedPoints = [];

                // Parámetros de detección adaptivos
                const windowSize = Math.max(3, Math.floor(n / 25)); // Ventana más pequeña para mejor detección
                const minSeparation = Math.abs(frequency[n-1] - frequency[0]) / 6; // Separación más flexible

                // Suavizado de datos para mejor detección
                const smoothedTransmittance = smoothSpectrum(transmittance, 3);

                // Calcular derivadas para encontrar puntos de inflexión verdaderos
                const firstDerivative = calculateFirstDerivative(smoothedTransmittance);
                const secondDerivative = calculateSecondDerivative(smoothedTransmittance);
                
                // Encontrar puntos de inflexión mínimos como candidatos para línea base
                const candidates = [];
                
                for (let i = windowSize; i < n - windowSize; i++) {
                    const currentValue = smoothedTransmittance[i];
                    const firstDeriv = firstDerivative[i];
                    const secondDeriv = secondDerivative[i];
                    
                    // Criterios para identificar puntos de línea base verdaderos:
                    // 1. Mínimo local (primera derivada cercana a 0)
                    // 2. Curvatura convexa (segunda derivada positiva)
                    // 3. No hay valores menores en la ventana local
                    const isDerivativeMinimum = Math.abs(firstDeriv) < 0.01; // Primera derivada cerca de cero
                    const isConvex = secondDeriv > 0; // Curvatura convexa (mínimo)
                    
                    if (isDerivativeMinimum && isConvex) {
                        // Verificar que es un mínimo local en la ventana
                        let isLocalMinimum = true;
                        const checkWindow = Math.floor(windowSize / 2);
                        
                        for (let j = i - checkWindow; j <= i + checkWindow; j++) {
                            if (j !== i && j >= 0 && j < n && smoothedTransmittance[j] < currentValue) {
                                isLocalMinimum = false;
                                break;
                            }
                        }
                        
                        if (isLocalMinimum) {
                            candidates.push({
                                x: frequency[i],
                                y: transmittance[i], // Usar valor original, no suavizado
                                index: i,
                                intensity: currentValue,
                                prominence: calculateProminence(smoothedTransmittance, i, windowSize),
                                derivativeScore: Math.abs(firstDeriv), // Menor es mejor
                                curvature: secondDeriv // Mayor es mejor para mínimos
                            });
                        }
                    }
                }
                
                // Si no encontramos suficientes puntos con derivadas, usar método tradicional como respaldo
                if (candidates.length < 3) {
                    console.log('Pocas inflexiones encontradas, usando detección tradicional como respaldo...');
                    for (let i = windowSize; i < n - windowSize; i++) {
                        const currentValue = smoothedTransmittance[i];
                        
                        // Verificar si es un mínimo local
                        let lowerCount = 0;
                        const checkWindow = Math.floor(windowSize / 2);
                        
                        for (let j = i - checkWindow; j <= i + checkWindow; j++) {
                            if (j !== i && smoothedTransmittance[j] < currentValue) {
                                lowerCount++;
                            }
                        }
                        
                        // Es mínimo si no hay valores menores en la ventana
                        if (lowerCount === 0) {
                            candidates.push({
                                x: frequency[i],
                                y: transmittance[i],
                                index: i,
                                intensity: currentValue,
                                prominence: calculateProminence(smoothedTransmittance, i, windowSize),
                                derivativeScore: 0.1, // Puntuación por defecto
                                curvature: 1
                            });
                        }
                    }
                }

                // Filtrar candidatos usando múltiples criterios para inflexiones
                const filteredCandidates = [];
                candidates
                    // Ordenar por calidad de inflexión: mejor derivada + mayor curvatura + prominencia
                    .sort((a, b) => {
                        const scoreA = (1 / (a.derivativeScore + 0.001)) * a.curvature * a.prominence;
                        const scoreB = (1 / (b.derivativeScore + 0.001)) * b.curvature * b.prominence;
                        return scoreB - scoreA;
                    })
                    .forEach(candidate => {
                        let tooClose = false;
                        for (let existing of filteredCandidates) {
                            if (Math.abs(candidate.x - existing.x) < minSeparation) {
                                tooClose = true;
                                break;
                            }
                        }
                        
                        if (!tooClose) {
                            filteredCandidates.push(candidate);
                        }
                    });

                // Seleccionar los mejores candidatos (entre 4 y 7 puntos)
                let maxPoints = Math.min(7, Math.max(4, filteredCandidates.length));
                let selectedCandidates = filteredCandidates
                    .slice(0, maxPoints)
                    .sort((a, b) => b.x - a.x); // Ordenar por número de onda descendente

                if (selectedCandidates.length === 0) {
                    throw new Error('No se pudieron detectar puntos de línea base válidos');
                }

                // Asegurar que tenemos puntos en los extremos
                const firstFreq = frequency[0];
                const lastFreq = frequency[n-1];
                const tolerance = Math.abs(frequency[1] - frequency[0]) * 3;

                const hasFirstPoint = selectedCandidates.some(p => Math.abs(p.x - firstFreq) < tolerance);
                const hasLastPoint = selectedCandidates.some(p => Math.abs(p.x - lastFreq) < tolerance);

                if (!hasFirstPoint) {
                    selectedCandidates.unshift({
                        x: firstFreq,
                        y: transmittance[0],
                        index: 0
                    });
                }

                if (!hasLastPoint) {
                    selectedCandidates.push({
                        x: lastFreq,
                        y: transmittance[n-1],
                        index: n-1
                    });
                }

                // Ordenar finalmente por número de onda descendente
                selectedCandidates.sort((a, b) => b.x - a.x);

                // Asignar puntos seleccionados usando clave específica
                const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
                window.manualBaselineState.selectedPoints[currentKey] = selectedCandidates.map(c => ({
                    x: c.x,
                    y: c.y,
                    index: c.index
                }));

                updatePointsList();
                plotSpectrumForManualBaseline();

                showNotification(`Detección automática completada: ${selectedCandidates.length} puntos seleccionados`, 'success');

            } catch (error) {
                console.error('Error en detección automática:', error);
                showNotification('Error en detección automática: ' + error.message, 'error');
            }
        }

        function smoothSpectrum(data, windowSize) {
            const smoothed = [...data];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = halfWindow; i < data.length - halfWindow; i++) {
                let sum = 0;
                for (let j = i - halfWindow; j <= i + halfWindow; j++) {
                    sum += data[j];
                }
                smoothed[i] = sum / windowSize;
            }
            
            return smoothed;
        }

        function calculateFirstDerivative(data) {
            const derivative = new Array(data.length);
            
            // Usar diferencias centrales para puntos interiores
            for (let i = 1; i < data.length - 1; i++) {
                derivative[i] = (data[i + 1] - data[i - 1]) / 2;
            }
            
            // Diferencias hacia adelante/atrás para los extremos
            derivative[0] = data[1] - data[0];
            derivative[data.length - 1] = data[data.length - 1] - data[data.length - 2];
            
            return derivative;
        }
        
        function calculateSecondDerivative(data) {
            const secondDerivative = new Array(data.length);
            
            // Usar diferencias centrales para puntos interiores
            for (let i = 1; i < data.length - 1; i++) {
                secondDerivative[i] = data[i + 1] - 2 * data[i] + data[i - 1];
            }
            
            // Aproximaciones para los extremos
            secondDerivative[0] = data[2] - 2 * data[1] + data[0];
            secondDerivative[data.length - 1] = data[data.length - 1] - 2 * data[data.length - 2] + data[data.length - 3];
            
            return secondDerivative;
        }

        function calculateProminence(data, index, windowSize) {
            const value = data[index];
            let maxLeft = value, maxRight = value;
            
            // Buscar máximo a la izquierda
            for (let i = index - 1; i >= Math.max(0, index - windowSize * 2); i--) {
                if (data[i] > maxLeft) maxLeft = data[i];
            }
            
            // Buscar máximo a la derecha
            for (let i = index + 1; i < Math.min(data.length, index + windowSize * 2); i++) {
                if (data[i] > maxRight) maxRight = data[i];
            }
            
            // La prominencia es la diferencia mínima entre el punto y los máximos cercanos
            return Math.min(maxLeft - value, maxRight - value);
        }

        function previewBaseline() {
            const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
            const points = window.manualBaselineState.selectedPoints[currentKey] || [];
            if (points.length < 2) {
                showNotification('Se necesitan al menos 2 puntos para crear una línea base', 'warning');
                return;
            }
            
            if (!window.manualBaselineState.currentRegionData) {
                showNotification('No hay datos de región disponibles', 'error');
                return;
            }
            
            try {
                const regionData = window.manualBaselineState.currentRegionData;
                const pointsX = points.map(p => p.x);
                const pointsY = points.map(p => p.y);
                
                // Calcular línea base usando la función mejorada
                const baselineCurve = calculateBaselineCurve(pointsX, pointsY, regionData.frequency);
                
                if (!baselineCurve || baselineCurve.x.length === 0) {
                    showNotification('Error calculando la línea base', 'error');
                    return;
                }
                
                // Calcular línea base extrapolada para todo el intervalo
                const analysisType = window.manualBaselineState.analysisType;
                const parameters = getAnalysisParameters(analysisType);
                
                // Determinar el rango completo del intervalo (referencia + interés)
                const minFreq = Math.min(parameters.interestPeak.min, parameters.referencePeak.min);
                const maxFreq = Math.max(parameters.interestPeak.max, parameters.referencePeak.max);
                
                // Calcular pendiente usando los puntos extremos
                const sortedPoints = points.sort((a, b) => a.x - b.x);
                const firstPoint = sortedPoints[0];
                const lastPoint = sortedPoints[sortedPoints.length - 1];
                
                const slope = (lastPoint.y - firstPoint.y) / (lastPoint.x - firstPoint.x);
                const intercept = firstPoint.y - slope * firstPoint.x;
                
                // Aplicar corrección extrapolada solo en el rango relevante
                const correctedY = regionData.transmittance.map((y, i) => {
                    const freq = regionData.frequency[i];
                    if (freq >= minFreq && freq <= maxFreq) {
                        const baselineValue = slope * freq + intercept;
                        return y - baselineValue;
                    }
                    return y;
                });
                
                // Generar línea base extrapolada para visualización
                const baselineVisualization = {
                    x: regionData.frequency.filter(f => f >= minFreq && f <= maxFreq),
                    y: []
                };
                baselineVisualization.y = baselineVisualization.x.map(freq => slope * freq + intercept);
                
                // Recrear el gráfico con vista previa
                const plotElement = document.querySelector('#manualBaselinePlot');
                const spectrumLabel = window.manualBaselineState.currentSpectrum;
                const regionType = window.manualBaselineState.currentRegion;
                
                const traces = [
                    // Espectro original
                    {
                        x: regionData.frequency,
                        y: regionData.transmittance,
                        type: 'scatter',
                        mode: 'lines',
                        name: `${spectrumLabel} - Original`,
                        line: { color: '#95a5a6', width: 2, dash: 'dot' },
                        opacity: 0.6,
                        hovertemplate: '<b>Original</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<extra></extra>'
                    },
                    // Espectro corregido (vista previa)
                    {
                        x: regionData.frequency,
                        y: correctedY,
                        type: 'scatter',
                        mode: 'lines',
                        name: `${spectrumLabel} - Corregido (Vista Previa)`,
                        line: { color: '#2980b9', width: 4 },
                        hovertemplate: '<b>Corrected</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<extra></extra>'
                    },
                    // Puntos seleccionados
                    {
                        x: pointsX,
                        y: pointsY,
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Puntos de Línea Base',
                        marker: {
                            color: '#f39c12',
                            size: 14,
                            symbol: 'diamond',
                            line: { color: '#d35400', width: 3 }
                        },
                        hovertemplate: '<b>Point %{pointIndex:+1}</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<extra></extra>'
                    },
                    // Línea base extrapolada
                    {
                        x: baselineVisualization.x,
                        y: baselineVisualization.y,
                        type: 'scatter',
                        mode: 'lines',
                        name: 'Línea Base Extrapolada',
                        line: { color: '#e74c3c', width: 3, dash: 'dash' },
                        hovertemplate: '<b>Línea Base</b><br>Frecuencia: %{x:.1f} cm⁻¹<br>Valor: %{y:.4f}<extra></extra>'
                    }
                ];
                
                const layout = {
                    title: {
                        text: `🔍 Vista Previa - ${spectrumLabel} - ${regionType === 'interest' ? 'Región de Interés' : 'Región de Referencia'}`,
                        font: { size: 18, color: '#2c3e50', family: 'Arial Black' }
                    },
                    xaxis: {
                        title: { text: 'Número de Onda (cm⁻¹)', font: { size: 16, color: '#34495e' } },
                        autorange: 'reversed',
                        gridcolor: '#bdc3c7',
                        showgrid: true
                    },
                    yaxis: {
                        title: { text: 'Transmittance', font: { size: 16, color: '#34495e' } },
                        gridcolor: '#bdc3c7',
                        showgrid: true
                    },
                    showlegend: true,
                    legend: { x: 0.02, y: 0.98, bgcolor: 'rgba(255,255,255,0.9)', bordercolor: '#95a5a6', borderwidth: 1 },
                    hovermode: 'closest',
                    plot_bgcolor: 'rgba(248, 249, 250, 0.6)',
                    paper_bgcolor: 'white',
                    margin: { t: 80, r: 50, b: 80, l: 90 },
                    annotations: [{
                        text: `Vista Previa - Método: ${document.querySelector('#baselineMethod')?.value || 'linear'}`,
                        x: 0.98, y: 0.02,
                        xref: 'paper', yref: 'paper',
                        xanchor: 'right', yanchor: 'bottom',
                        showarrow: false,
                        font: { size: 12, color: '#e74c3c' },
                        bgcolor: 'rgba(255,255,255,0.8)',
                        bordercolor: '#e74c3c',
                        borderwidth: 2
                    }]
                };
                
                Plotly.newPlot(plotElement, traces, layout, {
                    responsive: true,
                    displayModeBar: true,
                    displaylogo: false
                });
                
                showNotification('Vista previa generada - Compare original vs corregido', 'success');
                
            } catch (error) {
                console.error('Error en vista previa:', error);
                showNotification('Error generando vista previa: ' + error.message, 'error');
            }
        }

        function applyManualBaseline() {
            const currentKey = `${window.manualBaselineState.currentSpectrum}_${window.manualBaselineState.currentRegion}`;
            const points = window.manualBaselineState.selectedPoints[currentKey] || [];
            if (points.length < 2) {
                showNotification('Se necesitan al menos 2 puntos para aplicar corrección de línea base', 'warning');
                return;
            }
            
            if (!window.manualBaselineState.currentRegionData) {
                showNotification('No hay datos de región disponibles', 'error');
                return;
            }
            
            try {
                const spectrumLabel = window.manualBaselineState.currentSpectrum;
                const regionType = window.manualBaselineState.currentRegion;
                const analysisType = window.manualBaselineState.analysisType;
                
                const spectrumData = window.AppState.spectraData[spectrumLabel];
                const parameters = getAnalysisParameters(analysisType);
                const regionData = window.manualBaselineState.currentRegionData;
                
                // Calcular línea base
                const pointsX = points.map(p => p.x);
                const pointsY = points.map(p => p.y);
                const baselineCurve = calculateBaselineCurve(pointsX, pointsY, regionData.frequency);
                
                if (!baselineCurve || baselineCurve.x.length === 0) {
                    showNotification('Error calculando la línea base', 'error');
                    return;
                }
                
                // Guardar datos originales si no se ha hecho antes
                if (!spectrumData.originalTransmittance) {
                    spectrumData.originalTransmittance = [...spectrumData.transmittance];
                }
                
                // Calcular línea base extrapolada para todo el intervalo relevante
                let correctedPoints = 0;
                
                // Determinar el rango completo del intervalo (referencia + interés)
                const minFreq = Math.min(parameters.interestPeak.min, parameters.referencePeak.min);
                const maxFreq = Math.max(parameters.interestPeak.max, parameters.referencePeak.max);
                
                // Calcular pendiente de la línea base usando los dos puntos extremos
                const sortedPoints = points.sort((a, b) => a.x - b.x);
                const firstPoint = sortedPoints[0];
                const lastPoint = sortedPoints[sortedPoints.length - 1];
                
                const slope = (lastPoint.y - firstPoint.y) / (lastPoint.x - firstPoint.x);
                const intercept = firstPoint.y - slope * firstPoint.x;
                
                // Aplicar corrección extrapolada a todo el intervalo relevante
                for (let i = 0; i < spectrumData.frequency.length; i++) {
                    const freq = spectrumData.frequency[i];
                    
                    // Aplicar corrección en todo el rango combinado de intervalos
                    if (freq >= minFreq && freq <= maxFreq) {
                        // Calcular valor de línea base extrapolada para esta frecuencia
                        const baselineValue = slope * freq + intercept;
                        spectrumData.transmittance[i] -= baselineValue;
                        correctedPoints++;
                    }
                }
                
                // Marcar que la línea base ha sido aplicada
                if (!spectrumData.baselineCorrections) {
                    spectrumData.baselineCorrections = {};
                }
                
                spectrumData.baselineCorrections[regionType] = {
                    method: document.querySelector('#baselineMethod')?.value || 'linear',
                    points: [...points],
                    appliedAt: new Date().toISOString(),
                    correctedPoints: correctedPoints
                };
                
                // Actualizar estado de procesamiento
                window.AppState.processingStatus.baselineCorrected = true;
                
                // Mostrar resultado
                showNotification(
                    `Línea base aplicada exitosamente a ${spectrumLabel}<br>` +
                    `Región: ${regionType === 'interest' ? 'Interés' : 'Referencia'}<br>` +
                    `Puntos corregidos: ${correctedPoints}`,
                    'success'
                );
                
                // Redibujar gráfico con datos corregidos
                plotSpectrumForManualBaseline();
                
                // Actualizar vista general si existe
                if (typeof plotSpectraOverview === 'function') {
                    plotSpectraOverview();
                }
                
                // Actualizar todos los gráficos de análisis de intervalos
                updateAllAnalysisPlots();
                
                // Actualizar estado de procesamiento
                updateProcessingStatus(`Línea base aplicada - ${spectrumLabel} (${regionType})`, true);
                
            } catch (error) {
                console.error('Error aplicando línea base:', error);
                showNotification('Error aplicando corrección: ' + error.message, 'error');
            }
        }

        // Analysis Parameters
        const ANALYSIS_PARAMETERS = {
            oxidation: {
                interestPeak: { min: 1680, max: 1850 },  // mpint C=O range
                referencePeak: { min: 1330, max: 1400 }, // mpint Std range
                name: 'Oxidation Index',
                description: 'Ratio of carbonyl peak (1680-1850 cm⁻¹) to standard peak (1330-1400 cm⁻¹) per mpint'
            },
            crystallinity: {
                interestPeak: { min: 1850, max: 1950 },  // mpint PE_cryst range
                referencePeak: { min: 1275, max: 1330 }, // mpint PE_amorf range
                name: 'Crystallinity Index',
                description: 'mpint formula: CA = PE_cryst/PE_amorf; CI = CA/(CA+1) as ratio 0-1'
            },
            tvi: {
                interestPeak: { min: 950, max: 980 },    // mpint C=C_960 range
                referencePeak: { min: 1330, max: 1400 }, // mpint Std range
                name: 'TVI Index',
                description: 'Trans-vinylene index: ratio of C=C peak (950-980 cm⁻¹) to standard peak (1330-1400 cm⁻¹) per mpint'
            }
        };

        // Analysis Functions
        function performAutoAnalysis(analysisType) {
            if (!window.AppState.spectraData || Object.keys(window.AppState.spectraData).length === 0) {
                console.error('AppState.spectraData:', window.AppState.spectraData);
                alert('No spectrum data loaded. Please load a file first.');
                return;
            }
            
            console.log(`Starting ${analysisType} analysis with ${Object.keys(window.AppState.spectraData).length} spectra`);
            console.log('Available spectra:', Object.keys(window.AppState.spectraData));
            
            // El análisis completo automático maneja el offset, no requerirlo aquí
            
            showLoading(`Performing automatic analysis of ${analysisType}...`);
            
            // Verificar si ya hay correcciones aplicadas
            const hasBaselineCorrections = Object.values(window.AppState.spectraData).some(data => 
                data.originalTransmittance && data.originalTransmittance !== data.transmittance
            );
            
            if (hasBaselineCorrections) {
                console.log('Using original data to avoid cumulative correction');
            }
            
            try {
                const results = {};
                const spectraData = window.AppState.spectraData;
                const parameters = getAnalysisParameters(analysisType);
                
                Object.entries(spectraData).forEach(([label, data]) => {
                    try {
                        console.log(`Processing spectrum: ${label}`);
                        console.log('Data check:', {
                            hasFrequency: Array.isArray(data.frequency),
                            freqLength: data.frequency ? data.frequency.length : 0,
                            hasTransmittance: Array.isArray(data.transmittance),
                            transLength: data.transmittance ? data.transmittance.length : 0
                        });
                        
                        // CRITICAL: Create a deep copy to avoid contaminating global state
                        const sourceData = {
                            frequency: [...data.frequency],
                            transmittance: data.originalTransmittance ? 
                                [...data.originalTransmittance] : 
                                [...data.transmittance],
                            originalTransmittance: data.originalTransmittance ? 
                                [...data.originalTransmittance] : 
                                [...data.transmittance],
                            depth: data.depth,
                            color: data.color
                        };
                        
                        // Aplicar línea base automática en intervalos definidos por el usuario
                        const correctedData = applyAutoBaselineToRelevantIntervals(sourceData, parameters, analysisType);
                        
                        // Realizar análisis con datos corregidos
                        const result = performSingleSpectrumAnalysis(correctedData, parameters, analysisType);
                        results[label] = result;
                        
                        console.log(`Analysis result for ${label}:`, result);
                        
                        // NOTE: Do NOT update window.AppState.spectraData[label] to avoid contamination
                        // Each tab works with its own copy of the data
                    } catch (error) {
                        console.error(`Error processing spectrum ${label}:`, error);
                        results[label] = { error: error.message };
                    }
                });
                
                window.AppState.analysisResults[analysisType] = results;
                
                // Actualizar visualización completa
                updateAnalysisPlot(analysisType);
                updateAnalysisResults(analysisType);
                
                // Forzar actualización de gráficos de intervalos con datos corregidos
                updateReferenceIntervalPlot(analysisType);
                updateInterestIntervalPlot(analysisType);
                
                console.log(`Analysis of ${analysisType} completed:`, results);
                
                // Show notification about using original data
                if (hasBaselineCorrections) {
                    showNotification(`Analysis of ${analysisType} completed using original data to avoid cumulative correction`, 'info');
                }
                
            } catch (error) {
                console.error(`Error in analysis of ${analysisType}:`, error);
                alert(`Error in analysis of ${analysisType}: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        function getAnalysisParameters(analysisType) {
            const params = ANALYSIS_PARAMETERS[analysisType];
            
            // Check if UI elements exist
            const interestMinElement = document.getElementById(`${analysisType}InterestMin`);
            const interestMaxElement = document.getElementById(`${analysisType}InterestMax`);
            const refMinElement = document.getElementById(`${analysisType}RefMin`);
            const refMaxElement = document.getElementById(`${analysisType}RefMax`);
            
            if (!interestMinElement || !interestMaxElement || !refMinElement || !refMaxElement) {
                console.error(`UI elements for ${analysisType} not found`);
                throw new Error(`UI elements for ${analysisType} analysis not found`);
            }
            
            // Obtener valores de parámetros actuales de la UI (valores definidos por el usuario)
            const interestMin = parseFloat(interestMinElement.value);
            const interestMax = parseFloat(interestMaxElement.value);
            const refMin = parseFloat(refMinElement.value);
            const refMax = parseFloat(refMaxElement.value);
            
            console.log(`${analysisType} analysis using user-defined parameters:`);
            console.log(`Interest: ${interestMin}-${interestMax} cm⁻¹, Reference: ${refMin}-${refMax} cm⁻¹`);
            
            return {
                ...params,
                interestPeak: { min: interestMin, max: interestMax },
                referencePeak: { min: refMin, max: refMax }
            };
        }

        function performSingleSpectrumAnalysis(spectrumData, parameters, analysisType) {
            try {
                // Paso 1: Recortar espectro a regiones de interés
                // IMPORTANTE: spectrumData YA viene con corrección de línea base aplicada por applyAutoBaselineToRelevantIntervals
                const interestRegion = cropSpectrum(
                    spectrumData,
                    parameters.interestPeak.min,
                    parameters.interestPeak.max
                );
                
                const referenceRegion = cropSpectrum(
                    spectrumData,
                    parameters.referencePeak.min,
                    parameters.referencePeak.max
                );
                
                if (interestRegion.frequency.length === 0) {
                    throw new Error(`No data found in interest peak region (${parameters.interestPeak.min}-${parameters.interestPeak.max} cm⁻¹)`);
                }
                
                if (referenceRegion.frequency.length === 0) {
                    throw new Error(`No data found in reference peak region (${parameters.referencePeak.min}-${parameters.referencePeak.max} cm⁻¹)`);
                }
                
                // Paso 2: NO aplicar corrección adicional - usar datos ya corregidos que se muestran en los gráficos
                // Las regiones ya vienen con la corrección automática aplicada
                
                // Paso 3: Calcular áreas de picos directamente con los datos corregidos
                const interestArea = calculatePeakArea(
                    interestRegion.frequency,
                    interestRegion.transmittance,  // Ya corregidos por línea base automática
                    'simpson'  // Usar regla de Simpson para mayor precisión
                );
                
                const referenceArea = calculatePeakArea(
                    referenceRegion.frequency,
                    referenceRegion.transmittance,  // Ya corregidos por línea base automática
                    'simpson'  // Usar regla de Simpson para mayor precisión
                );
                
                // Paso 4: Calcular índice según fórmulas exactas de mpint 1.1.1
                let index = 0;
                if (analysisType === 'crystallinity') {
                    // Fórmula mpint para cristalinidad: CA = PE_cryst/PE_amorf; CI = CA/(CA+1)
                    // En nuestro caso: interestArea = PE_cryst (1850-1950), referenceArea = PE_amorf (1275-1330)
                    if (referenceArea !== 0) {
                        const CA = interestArea / referenceArea;  // Crystalline/Amorphous ratio
                        index = CA / (CA + 1);  // CI formula from mpint
                        
                        // Protect against small negative values (as per mpint)
                        if (index < 0) index = -0.0001;
                    }
                } else if (analysisType === 'oxidation') {
                    // Fórmula mpint para oxidación: OI = C=O peak area / Standard peak area
                    // En nuestro caso: interestArea = C=O (1680-1850), referenceArea = Standard (1330-1400)
                    index = referenceArea !== 0 ? interestArea / referenceArea : 0;
                    
                    // Protect against small negative values (as per mpint)
                    if (index < 0) index = -0.0001;
                } else if (analysisType === 'tvi') {
                    // Fórmula mpint para trans-vinylene: VI = C=C peak area / Standard peak area
                    // En nuestro caso: interestArea = C=C (950-980), referenceArea = Standard (1330-1400)
                    index = referenceArea !== 0 ? interestArea / referenceArea : 0;
                    
                    // Protect against small negative values (as per mpint)
                    if (index < 0) index = -0.0001;
                }
                
                return {
                    index: index,
                    interestArea: interestArea,
                    referenceArea: referenceArea,
                    interestRegion: interestRegion,  // Datos ya corregidos
                    referenceRegion: referenceRegion,  // Datos ya corregidos
                    interestRegionOriginal: spectrumData.originalTransmittance ? 
                        cropSpectrumFromOriginal(spectrumData, parameters.interestPeak.min, parameters.interestPeak.max) : interestRegion,
                    referenceRegionOriginal: spectrumData.originalTransmittance ?
                        cropSpectrumFromOriginal(spectrumData, parameters.referencePeak.min, parameters.referencePeak.max) : referenceRegion,
                    parameters: parameters,
                    quality: 'good',
                    // Store corrected spectrum data for plotting
                    correctedSpectrum: {
                        frequency: [...spectrumData.frequency],
                        transmittance: [...spectrumData.transmittance]
                    }
                };
                
            } catch (error) {
                console.error(`Error in single spectrum analysis:`, error);
                return {
                    index: 0,
                    error: error.message,
                    interestArea: 0,
                    referenceArea: 0,
                    quality: 'poor'
                };
            }
        }

        function cropSpectrum(spectrumData, minFreq, maxFreq) {
            const { frequency, transmittance } = spectrumData;
            const croppedIndices = [];
            const croppedFrequency = [];
            const croppedTransmittance = [];
            
            frequency.forEach((freq, index) => {
                if (freq >= minFreq && freq <= maxFreq) {
                    croppedIndices.push(index);
                    croppedFrequency.push(freq);
                    croppedTransmittance.push(transmittance[index]);
                }
            });
            
            return {
                ...spectrumData,
                frequency: croppedFrequency,
                transmittance: croppedTransmittance,
                originalIndices: croppedIndices
            };
        }

        function cropSpectrumFromOriginal(spectrumData, minFreq, maxFreq) {
            const { frequency, originalTransmittance } = spectrumData;
            const croppedIndices = [];
            const croppedFrequency = [];
            const croppedTransmittance = [];
            
            frequency.forEach((freq, index) => {
                if (freq >= minFreq && freq <= maxFreq) {
                    croppedIndices.push(index);
                    croppedFrequency.push(freq);
                    croppedTransmittance.push(originalTransmittance[index]);
                }
            });
            
            return {
                ...spectrumData,
                frequency: croppedFrequency,
                transmittance: croppedTransmittance,
                originalIndices: croppedIndices
            };
        }

        function performBaselineCorrection(spectrumData, method = 'linear') {
            const { frequency, transmittance } = spectrumData;
            
            // Corrección de línea base lineal simple del primer al último punto
            const firstPoint = transmittance[0];
            const lastPoint = transmittance[transmittance.length - 1];
            const slope = (lastPoint - firstPoint) / (frequency[frequency.length - 1] - frequency[0]);
            
            const correctedTransmittance = transmittance.map((value, index) => {
                const baselineValue = firstPoint + slope * (frequency[index] - frequency[0]);
                return value - baselineValue;
            });
            
            return {
                ...spectrumData,
                transmittance: correctedTransmittance,
                baseline: transmittance.map((value, index) => {
                    return firstPoint + slope * (frequency[index] - frequency[0]);
                })
            };
        }

        function calculatePeakArea(frequency, transmittance, method = 'trapezoidal') {
            if (frequency.length !== transmittance.length) {
                throw new Error('Frequency and transmittance arrays must have the same length');
            }
            
            if (frequency.length < 2) {
                return 0;
            }
            
            switch (method.toLowerCase()) {
                case 'simpson':
                case 'simpsons':
                    return calculateAreaSimpsonRule(frequency, transmittance);
                case 'trapezoidal':
                default:
                    return calculateAreaTrapezoidalRule(frequency, transmittance);
            }
        }
        
        function calculateAreaTrapezoidalRule(frequency, transmittance) {
            // Integración trapezoidal (método original)
            let area = 0;
            for (let i = 1; i < frequency.length; i++) {
                const dx = Math.abs(frequency[i] - frequency[i-1]);
                const avgY = (transmittance[i] + transmittance[i-1]) / 2;
                area += dx * avgY;
            }
            return area;
        }
        
        function calculateAreaSimpsonRule(frequency, transmittance) {
            // Regla de Simpson (1/3) para integración más precisa
            // Fórmula: (h/3) * [f(x0) + 4*f(x1) + 2*f(x2) + 4*f(x3) + ... + f(xn)]
            // Donde h es el espaciado y n debe ser par
            
            const n = frequency.length;
            if (n < 3) {
                // Si hay muy pocos puntos, usar trapezoidal
                return calculateAreaTrapezoidalRule(frequency, transmittance);
            }
            
            let area = 0;
            
            // Si el número de intervalos es impar, usar Simpson's 1/3 + trapezoidal para el último intervalo
            let endIndex = n;
            if ((n - 1) % 2 !== 0) {
                // Usar trapezoidal para el último intervalo
                const lastDx = Math.abs(frequency[n-1] - frequency[n-2]);
                const lastAvgY = (transmittance[n-1] + transmittance[n-2]) / 2;
                area += lastDx * lastAvgY;
                endIndex = n - 1;
            }
            
            // Aplicar regla de Simpson para intervalos pares
            for (let i = 0; i < endIndex - 1; i += 2) {
                if (i + 2 < endIndex) {
                    const x0 = frequency[i];
                    const x1 = frequency[i + 1];
                    const x2 = frequency[i + 2];
                    
                    const y0 = transmittance[i];
                    const y1 = transmittance[i + 1];
                    const y2 = transmittance[i + 2];
                    
                    // Calcular h como promedio de los dos intervalos
                    const h1 = Math.abs(x1 - x0);
                    const h2 = Math.abs(x2 - x1);
                    const h = (h1 + h2) / 2;
                    
                    // Regla de Simpson: (h/3) * [f(x0) + 4*f(x1) + f(x2)]
                    const simpsonArea = (h / 3) * (y0 + 4 * y1 + y2);
                    area += simpsonArea;
                } else {
                    // Si queda un intervalo impar al final, usar trapezoidal
                    const dx = Math.abs(frequency[i + 1] - frequency[i]);
                    const avgY = (transmittance[i + 1] + transmittance[i]) / 2;
                    area += dx * avgY;
                }
            }
            
            return area;
        }

        function updateAnalysisPlot(analysisType) {
            const spectraData = window.AppState.spectraData;
            const results = window.AppState.analysisResults[analysisType];
            
            if (!spectraData || !results) return;
            
            // Actualizar ambos gráficos separados
            updateReferenceIntervalPlot(analysisType);
            updateInterestIntervalPlot(analysisType);
        }

        function updateReferenceIntervalPlot(analysisType) {
            const plotId = `${analysisType}ReferencePlot`;
            const plotElement = document.getElementById(plotId);
            
            if (!plotElement) return;
            
            const spectraData = window.AppState.spectraData;
            const results = window.AppState.analysisResults[analysisType];
            const parameters = getAnalysisParameters(analysisType);
            
            if (!spectraData || !results || !parameters) return;
            
            const traces = [];
            const { referencePeak } = parameters;
            
            // Obtener profundidades seleccionadas
            const selectedDepths = getSelectedDepths(analysisType);
            console.log(`Reference plot - Selected depths for ${analysisType}:`, selectedDepths);
            console.log(`Reference plot - Available spectra:`, Object.keys(spectraData));
            
            // Añadir trazas de espectros en el rango de referencia (solo para profundidades seleccionadas)
            Object.entries(spectraData).forEach(([label, data], index) => {
                // Solo mostrar si la profundidad está seleccionada
                if (!selectedDepths.includes(label)) {
                    console.log(`Skipping ${label} - not in selected depths`);
                    return;
                }
                
                const color = generateDepthColor(index, Object.keys(spectraData).length);
                
                // Get corrected spectrum from analysis results
                const result = results[label];
                const correctedData = result && result.correctedSpectrum ? result.correctedSpectrum : data;
                
                // Filtrar datos al rango de referencia
                const refIndices = [];
                for (let i = 0; i < correctedData.frequency.length; i++) {
                    if (correctedData.frequency[i] >= referencePeak.min && correctedData.frequency[i] <= referencePeak.max) {
                        refIndices.push(i);
                    }
                }
                
                if (refIndices.length > 0) {
                    const refFreq = refIndices.map(i => correctedData.frequency[i]);
                    const refTrans = refIndices.map(i => correctedData.transmittance[i]); // Datos corregidos del resultado del análisis
                    
                    traces.push({
                        x: refFreq,
                        y: refTrans,
                        type: 'scatter',
                        mode: 'lines',
                        name: `${label} - Corrected`,
                        line: { color: color, width: 3, opacity: 0.9 },
                        showlegend: false,
                        hovertemplate: '<b>%{fullData.name}</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<br><i>Baseline corrected</i><extra></extra>'
                    });
                    
                    // Opcional: Añadir traza original para comparación (más tenue)
                    if (data.originalTransmittance) {
                        const refTransOriginal = refIndices.map(i => data.originalTransmittance[i]);
                        traces.push({
                            x: refFreq,
                            y: refTransOriginal,
                            type: 'scatter',
                            mode: 'lines',
                            name: `${label} - Original`,
                            line: { color: color, width: 1, opacity: 0.3, dash: 'dot' },
                            showlegend: false,
                            hovertemplate: '<b>%{fullData.name}</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<br><i>Original data</i><extra></extra>'
                        });
                    }
                }
            });
            
            // Encontrar rango Y máximo para el área sombreada
            let yMax = 0;
            traces.forEach(trace => {
                if (trace.y && trace.y.length > 0) {
                    yMax = Math.max(yMax, Math.max(...trace.y));
                }
            });
            
            // Añadir área sombreada del intervalo de referencia
            traces.push({
                x: [referencePeak.min, referencePeak.min, referencePeak.max, referencePeak.max, referencePeak.min],
                y: [0, yMax * 1.1, yMax * 1.1, 0, 0],
                type: 'scatter',
                mode: 'lines',
                fill: 'toself',
                fillcolor: 'rgba(67, 233, 123, 0.2)',
                line: { color: 'rgba(67, 233, 123, 0.8)', width: 2 },
                name: 'Reference Range',
                showlegend: false,
                hoverinfo: 'skip'
            });
            
            const selectedCount = selectedDepths.length;
            const totalCount = Object.keys(spectraData).length;
            
            const layout = {
                title: {
                    text: `Reference Interval - ${parameters.name}<br><sub>Showing ${selectedCount} of ${totalCount} depths</sub>`,
                    font: { size: 18, color: '#2c3e50' }
                },
                xaxis: { 
                    title: { text: 'Wavenumber (cm⁻¹)', font: { size: 14 } },
                    autorange: 'reversed',
                    range: [referencePeak.max + 50, referencePeak.min - 50],
                    tickfont: { size: 12 }
                },
                yaxis: { 
                    title: { text: 'Transmittance (Baseline Corrected)', font: { size: 14 } },
                    tickfont: { size: 12 }
                },
                margin: { l: 60, r: 20, t: 80, b: 60 },
                showlegend: false,
                hovermode: 'closest',
                annotations: [{
                    text: '✓ Data used for area calculation',
                    x: 0.02, y: 0.98,
                    xref: 'paper', yref: 'paper',
                    xanchor: 'left', yanchor: 'top',
                    showarrow: false,
                    font: { size: 12, color: '#27ae60' },
                    bgcolor: 'rgba(39, 174, 96, 0.1)',
                    bordercolor: '#27ae60',
                    borderwidth: 1
                }]
            };
            
            Plotly.newPlot(plotId, traces, layout, { displayModeBar: false, responsive: true });
        }

        function updateInterestIntervalPlot(analysisType) {
            const plotId = `${analysisType}InterestPlot`;
            const plotElement = document.getElementById(plotId);
            
            if (!plotElement) return;
            
            const spectraData = window.AppState.spectraData;
            const results = window.AppState.analysisResults[analysisType];
            const parameters = getAnalysisParameters(analysisType);
            
            if (!spectraData || !results || !parameters) return;
            
            const traces = [];
            const { interestPeak } = parameters;
            
            // Obtener profundidades seleccionadas
            const selectedDepths = getSelectedDepths(analysisType);
            console.log(`Interest plot - Selected depths for ${analysisType}:`, selectedDepths);
            console.log(`Interest plot - Available spectra:`, Object.keys(spectraData));
            
            // Añadir trazas de espectros en el rango de interés (solo para profundidades seleccionadas)
            Object.entries(spectraData).forEach(([label, data], index) => {
                // Solo mostrar si la profundidad está seleccionada
                if (!selectedDepths.includes(label)) {
                    console.log(`Skipping ${label} - not in selected depths`);
                    return;
                }
                
                const color = generateDepthColor(index, Object.keys(spectraData).length);
                
                // Get corrected spectrum from analysis results
                const result = results[label];
                const correctedData = result && result.correctedSpectrum ? result.correctedSpectrum : data;
                
                // Filtrar datos al rango de interés
                const intIndices = [];
                for (let i = 0; i < correctedData.frequency.length; i++) {
                    if (correctedData.frequency[i] >= interestPeak.min && correctedData.frequency[i] <= interestPeak.max) {
                        intIndices.push(i);
                    }
                }
                
                if (intIndices.length > 0) {
                    const intFreq = intIndices.map(i => correctedData.frequency[i]);
                    const intTrans = intIndices.map(i => correctedData.transmittance[i]); // Datos corregidos del resultado del análisis
                    
                    traces.push({
                        x: intFreq,
                        y: intTrans,
                        type: 'scatter',
                        mode: 'lines',
                        name: `${label} - Corrected`,
                        line: { color: color, width: 3, opacity: 0.9 },
                        showlegend: false,
                        hovertemplate: '<b>%{fullData.name}</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<br><i>Baseline corrected</i><extra></extra>'
                    });
                    
                    // Opcional: Añadir traza original para comparación (más tenue)
                    if (data.originalTransmittance) {
                        const intTransOriginal = intIndices.map(i => data.originalTransmittance[i]);
                        traces.push({
                            x: intFreq,
                            y: intTransOriginal,
                            type: 'scatter',
                            mode: 'lines',
                            name: `${label} - Original`,
                            line: { color: color, width: 1, opacity: 0.3, dash: 'dot' },
                            showlegend: false,
                            hovertemplate: '<b>%{fullData.name}</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<br><i>Original data</i><extra></extra>'
                        });
                    }
                }
            });
            
            // Encontrar rango Y máximo para el área sombreada
            let yMax = 0;
            traces.forEach(trace => {
                if (trace.y && trace.y.length > 0) {
                    yMax = Math.max(yMax, Math.max(...trace.y));
                }
            });
            
            // Añadir área sombreada del intervalo de interés
            traces.push({
                x: [interestPeak.min, interestPeak.min, interestPeak.max, interestPeak.max, interestPeak.min],
                y: [0, yMax * 1.1, yMax * 1.1, 0, 0],
                type: 'scatter',
                mode: 'lines',
                fill: 'toself',
                fillcolor: 'rgba(240, 147, 251, 0.2)',
                line: { color: 'rgba(240, 147, 251, 0.8)', width: 2 },
                name: 'Interest Range',
                showlegend: false,
                hoverinfo: 'skip'
            });
            
            const selectedCount = selectedDepths.length;
            const totalCount = Object.keys(spectraData).length;
            
            const layout = {
                title: {
                    text: `Interest Interval - ${parameters.name}<br><sub>Showing ${selectedCount} of ${totalCount} depths</sub>`,
                    font: { size: 18, color: '#2c3e50' }
                },
                xaxis: { 
                    title: { text: 'Wavenumber (cm⁻¹)', font: { size: 14 } },
                    autorange: 'reversed',
                    range: [interestPeak.max + 50, interestPeak.min - 50],
                    tickfont: { size: 12 }
                },
                yaxis: { 
                    title: { text: 'Transmittance (Baseline Corrected)', font: { size: 14 } },
                    tickfont: { size: 12 }
                },
                margin: { l: 60, r: 20, t: 80, b: 60 },
                showlegend: false,
                hovermode: 'closest',
                annotations: [{
                    text: '✓ Data used for area calculation',
                    x: 0.02, y: 0.98,
                    xref: 'paper', yref: 'paper',
                    xanchor: 'left', yanchor: 'top',
                    showarrow: false,
                    font: { size: 12, color: '#8e44ad' },
                    bgcolor: 'rgba(142, 68, 173, 0.1)',
                    bordercolor: '#8e44ad',
                    borderwidth: 1
                }]
            };
            
            Plotly.newPlot(plotId, traces, layout, { displayModeBar: false, responsive: true });
        }

        // ===== FUNCIONES DE SELECCIÓN DE PROFUNDIDADES =====
        
        function getSelectedDepths(analysisType) {
            const depthsList = document.getElementById(`${analysisType}DepthsList`);
            console.log(`Looking for depths list: ${analysisType}DepthsList`, depthsList);
            
            if (!depthsList) {
                console.log(`No depths list found for ${analysisType}, returning all available depths`);
                return Object.keys(window.AppState.spectraData || {});
            }
            
            const checkboxes = depthsList.querySelectorAll('input[type="checkbox"]:checked');
            console.log(`Found ${checkboxes.length} checked checkboxes for ${analysisType}`);
            
            if (checkboxes.length === 0) {
                console.log(`No checkboxes selected for ${analysisType}, returning all available depths`);
                return Object.keys(window.AppState.spectraData || {});
            }
            
            const selectedDepths = Array.from(checkboxes).map(cb => cb.value);
            console.log(`Selected depths for ${analysisType}:`, selectedDepths);
            return selectedDepths;
        }
        
        function selectAllDepths(analysisType) {
            const depthsList = document.getElementById(`${analysisType}DepthsList`);
            if (!depthsList) return;
            
            const checkboxes = depthsList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = true);
            
            // Actualizar visualización
            updateAnalysisPlot(analysisType);
        }
        
        function selectNoneDepths(analysisType) {
            const depthsList = document.getElementById(`${analysisType}DepthsList`);
            if (!depthsList) return;
            
            const checkboxes = depthsList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            
            // Actualizar visualización
            updateAnalysisPlot(analysisType);
        }
        
        function selectEveryNDepths(analysisType, n) {
            const depthsList = document.getElementById(`${analysisType}DepthsList`);
            if (!depthsList) return;
            
            const checkboxes = depthsList.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach((cb, index) => {
                cb.checked = (index % n === 0);
            });
            
            // Actualizar visualización
            updateAnalysisPlot(analysisType);
        }
        
        function populateDepthSelectors() {
            if (!window.AppState.spectraData) return;
            
            const analysisTypes = ['oxidation', 'crystallinity', 'tvi'];
            const depths = Object.keys(window.AppState.spectraData);
            
            console.log('Populating depth selectors...', { 
                spectraData: window.AppState.spectraData, 
                depthCount: depths.length,
                depths: depths
            });
            
            analysisTypes.forEach(analysisType => {
                const depthsList = document.getElementById(`${analysisType}DepthsList`);
                console.log(`Populating ${analysisType} depth selector:`, depthsList);
                if (!depthsList) return;
                
                // Limpiar lista actual
                depthsList.innerHTML = '';
                
                // Añadir checkboxes para cada profundidad
                depths.forEach((depth, index) => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.className = 'form-check form-check-sm mb-1';
                    
                    const checkbox = document.createElement('input');
                    checkbox.className = 'form-check-input';
                    checkbox.type = 'checkbox';
                    checkbox.id = `${analysisType}_depth_${index}`;
                    checkbox.value = depth;
                    checkbox.checked = true; // Por defecto todas seleccionadas
                    
                    // Evento para actualizar visualización al cambiar selección
                    checkbox.addEventListener('change', () => {
                        updateAnalysisPlot(analysisType);
                    });
                    
                    const label = document.createElement('label');
                    label.className = 'form-check-label text-sm';
                    label.htmlFor = checkbox.id;
                    label.textContent = depth;
                    
                    // Mostrar color asociado
                    const colorIndicator = document.createElement('span');
                    colorIndicator.className = 'depth-color-indicator';
                    const color = generateDepthColor(index, depths.length);
                    colorIndicator.style.cssText = `
                        display: inline-block;
                        width: 12px;
                        height: 12px;
                        background-color: ${color};
                        border-radius: 50%;
                        margin-right: 6px;
                        vertical-align: middle;
                    `;
                    
                    checkboxDiv.appendChild(checkbox);
                    checkboxDiv.appendChild(colorIndicator);
                    checkboxDiv.appendChild(label);
                    depthsList.appendChild(checkboxDiv);
                });
                
                // Añadir información del total
                const infoDiv = document.createElement('div');
                infoDiv.className = 'mt-2 text-muted small';
                infoDiv.innerHTML = `<i class="fas fa-info-circle"></i> Total: ${depths.length} depths available`;
                depthsList.appendChild(infoDiv);
            });
        }

        // Función para aplicar línea base automática solo en intervalos definidos por el usuario
        function applyAutoBaselineToRelevantIntervals(spectrumData, parameters, analysisType) {
            const { frequency, transmittance } = spectrumData;
            const { interestPeak, referencePeak } = parameters;
            
            // Crear copia de los datos preservando originales si existen
            const correctedData = {
                ...spectrumData,
                transmittance: [...transmittance],
                originalTransmittance: spectrumData.originalTransmittance || [...transmittance]
            };
            
            // Aplicar corrección de línea base independientemente a cada región especificada por el usuario
            console.log(`Applying baseline correction to user-defined regions:`);
            console.log(`Interest peak: ${interestPeak.min}-${interestPeak.max} cm⁻¹`);
            console.log(`Reference peak: ${referencePeak.min}-${referencePeak.max} cm⁻¹`);
            
            // Procesar región de interés
            const interestIndices = getIndicesInRange(frequency, interestPeak.min, interestPeak.max);
            if (interestIndices.length >= 3) {
                applyBaselineToRegion(correctedData, interestIndices, 'interest');
            } else {
                console.warn(`Interest region (${interestPeak.min}-${interestPeak.max}) too small for baseline correction`);
            }
            
            // Procesar región de referencia (solo si es diferente de la región de interés)
            if (referencePeak.min !== interestPeak.min || referencePeak.max !== interestPeak.max) {
                const referenceIndices = getIndicesInRange(frequency, referencePeak.min, referencePeak.max);
                if (referenceIndices.length >= 3) {
                    applyBaselineToRegion(correctedData, referenceIndices, 'reference');
                } else {
                    console.warn(`Reference region (${referencePeak.min}-${referencePeak.max}) too small for baseline correction`);
                }
            }
            
            return correctedData;
        }
        
        function getIndicesInRange(frequency, minFreq, maxFreq) {
            const indices = [];
            for (let i = 0; i < frequency.length; i++) {
                if (frequency[i] >= minFreq && frequency[i] <= maxFreq) {
                    indices.push(i);
                }
            }
            return indices;
        }
        
        function applyBaselineToRegion(spectrumData, regionIndices, regionType) {
            const { frequency, transmittance } = spectrumData;
            
            if (regionIndices.length < 3) {
                console.warn(`Region ${regionType} too small for baseline correction`);
                return;
            }
            
            // Extraer datos de la región
            const regionFreq = regionIndices.map(i => frequency[i]);
            const regionTrans = regionIndices.map(i => transmittance[i]);
            
            // Calcular línea base usando mínimos locales solo en esta región
            const baselinePoints = calculateAutoBaseline(regionFreq, regionTrans);
            
            // Aplicar corrección solo en esta región
            regionIndices.forEach((originalIndex, localIndex) => {
                const baseline = baselinePoints[localIndex];
                const correctedValue = transmittance[originalIndex] - baseline;
                spectrumData.transmittance[originalIndex] = correctedValue;
            });
            
            // Verificar que el mínimo de la región corregida esté cerca de 0
            const correctedRegionValues = regionIndices.map(i => spectrumData.transmittance[i]);
            const minCorrected = Math.min(...correctedRegionValues);
            const maxCorrected = Math.max(...correctedRegionValues);
            
            console.log(`Baseline correction applied to ${regionType} region: ${regionIndices.length} points corrected`);
            console.log(`After correction - Min: ${minCorrected.toFixed(4)}, Max: ${maxCorrected.toFixed(4)}, Range: ${(maxCorrected - minCorrected).toFixed(4)}`);
        }
        
        function calculateAutoBaseline(frequencies, transmittances) {
            const n = frequencies.length;
            
            if (n < 3) {
                console.warn('Not enough points for baseline calculation');
                return new Array(n).fill(0);
            }
            
            // Método mejorado: usar línea recta entre mínimos de los extremos de la región
            const windowSize = Math.max(3, Math.floor(n / 10));
            
            // Encontrar mínimo en el primer tercio de la región
            const firstThirdEnd = Math.floor(n / 3);
            let leftMinIndex = 0;
            let leftMinValue = transmittances[0];
            for (let i = 0; i < firstThirdEnd; i++) {
                if (transmittances[i] < leftMinValue) {
                    leftMinValue = transmittances[i];
                    leftMinIndex = i;
                }
            }
            
            // Encontrar mínimo en el último tercio de la región
            const lastThirdStart = Math.floor(2 * n / 3);
            let rightMinIndex = n - 1;
            let rightMinValue = transmittances[n - 1];
            for (let i = lastThirdStart; i < n; i++) {
                if (transmittances[i] < rightMinValue) {
                    rightMinValue = transmittances[i];
                    rightMinIndex = i;
                }
            }
            
            console.log(`Baseline calculation: Left min at index ${leftMinIndex} (${frequencies[leftMinIndex].toFixed(1)} cm⁻¹, value: ${leftMinValue.toFixed(4)})`);
            console.log(`Baseline calculation: Right min at index ${rightMinIndex} (${frequencies[rightMinIndex].toFixed(1)} cm⁻¹, value: ${rightMinValue.toFixed(4)})`);
            
            // Crear línea base lineal entre los dos mínimos
            const baselineValues = new Array(n);
            
            if (leftMinIndex === rightMinIndex) {
                // Si ambos mínimos son el mismo punto, usar valor constante
                for (let i = 0; i < n; i++) {
                    baselineValues[i] = leftMinValue;
                }
            } else {
                // Interpolación lineal entre los dos mínimos
                const slope = (rightMinValue - leftMinValue) / (rightMinIndex - leftMinIndex);
                
                for (let i = 0; i < n; i++) {
                    baselineValues[i] = leftMinValue + slope * (i - leftMinIndex);
                }
            }
            
            // Verificar que la línea base no sea superior a ningún punto de datos
            // (ajuste de seguridad para evitar sobre-corrección)
            for (let i = 0; i < n; i++) {
                if (baselineValues[i] > transmittances[i]) {
                    baselineValues[i] = transmittances[i];
                }
            }
            
            return baselineValues;
        }

        // Función utilitaria para debounce
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Función para actualizar todos los gráficos de análisis en tiempo real
        function updateAllAnalysisPlots() {
            const analysisTypes = ['oxidation', 'crystallinity', 'tvi'];
            
            analysisTypes.forEach(analysisType => {
                // Solo actualizar si hay datos de análisis para ese tipo
                if (window.AppState.analysisResults[analysisType] && 
                    Object.keys(window.AppState.analysisResults[analysisType]).length > 0) {
                    updateAnalysisPlot(analysisType);
                } else {
                    // Si no hay resultados de análisis pero sí datos de espectro, mostrar gráficos vacíos con regiones sombreadas
                    if (window.AppState.spectraData && Object.keys(window.AppState.spectraData).length > 0) {
                        updateReferenceIntervalPlot(analysisType);
                        updateInterestIntervalPlot(analysisType);
                    }
                }
            });
        }

        function updateAnalysisResults(analysisType) {
            const resultsElement = document.getElementById(`${analysisType}Results`);
            const results = window.AppState.analysisResults[analysisType];
            const parameters = ANALYSIS_PARAMETERS[analysisType];
            
            if (!resultsElement || !results) return;
            
            let html = `
                <h6>${parameters.name} Results</h6>
                <p class="text-muted small">${parameters.description}</p>
            `;
            
            // Crear tabla de resultados
            html += `
                <div class="table-responsive">
                    <table class="table table-sm table-striped">
                        <thead>
                            <tr>
                                <th>Depth</th>
                                <th>Index</th>
                                <th>Areas</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            Object.entries(results).forEach(([label, result]) => {
                const depth = label.replace('μm', '');
                // Format index based on analysis type (all following mpint 1.1.1 format)
                let index = 'N/A';
                if (result.index !== undefined && result.index !== null && !isNaN(result.index)) {
                    if (analysisType === 'crystallinity') {
                        index = result.index.toFixed(4); // Crystallinity as ratio (0-1) per mpint
                    } else {
                        index = result.index.toFixed(4); // Other indices as ratios per mpint
                    }
                }
                const areas = result.interestArea && result.referenceArea ? 
                    `${result.interestArea.toFixed(2)} / ${result.referenceArea.toFixed(2)}` : 'N/A';
                
                html += `
                    <tr>
                        <td><strong>${depth}</strong></td>
                        <td><span class="badge bg-secondary">${index}</span></td>
                        <td class="small">${areas}</td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            // Agregar estadísticas resumidas
            const indices = Object.values(results)
                .filter(r => r.index && !isNaN(r.index))
                .map(r => r.index);
            
            if (indices.length > 0) {
                const mean = indices.reduce((sum, val) => sum + val, 0) / indices.length;
                const min = Math.min(...indices);
                const max = Math.max(...indices);
                const std = Math.sqrt(
                    indices.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / indices.length
                );
                
                // Find frequency and intensity min/max points
                const allFrequencies = [];
                const allIntensities = [];
                Object.values(results).forEach(result => {
                    if (result.frequency && result.transmittance) {
                        allFrequencies.push(...result.frequency);
                        allIntensities.push(...result.transmittance);
                    }
                });
                
                const freqMin = allFrequencies.length > 0 ? Math.min(...allFrequencies) : 0;
                const freqMax = allFrequencies.length > 0 ? Math.max(...allFrequencies) : 0;
                const intensityMin = allIntensities.length > 0 ? Math.min(...allIntensities) : 0;
                const intensityMax = allIntensities.length > 0 ? Math.max(...allIntensities) : 0;
                
                html += `
                    <div class="mt-3 p-2 bg-light rounded">
                        <h6 class="mb-2">Summary Statistics</h6>
                        <div class="row">
                            <div class="col-2 text-center">
                                <div class="stat-value">${mean.toFixed(4)}</div>
                                <div class="stat-label small">Mean</div>
                            </div>
                            <div class="col-2 text-center">
                                <div class="stat-value">${std.toFixed(4)}</div>
                                <div class="stat-label small">Std Dev</div>
                            </div>
                            <div class="col-2 text-center">
                                <div class="stat-value">${min.toFixed(4)}</div>
                                <div class="stat-label small">Index Min</div>
                            </div>
                            <div class="col-2 text-center">
                                <div class="stat-value">${max.toFixed(4)}</div>
                                <div class="stat-label small">Index Max</div>
                            </div>
                            <div class="col-2 text-center">
                                <div class="stat-value">${freqMin.toFixed(0)}</div>
                                <div class="stat-label small">Freq Min</div>
                            </div>
                            <div class="col-2 text-center">
                                <div class="stat-value">${freqMax.toFixed(0)}</div>
                                <div class="stat-label small">Freq Max</div>
                            </div>
                        </div>
                        <div class="row mt-2">
                            <div class="col-6 text-center">
                                <div class="stat-value">${intensityMin.toFixed(4)}</div>
                                <div class="stat-label small">Intensity Min</div>
                            </div>
                            <div class="col-6 text-center">
                                <div class="stat-value">${intensityMax.toFixed(4)}</div>
                                <div class="stat-label small">Intensity Max</div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            resultsElement.innerHTML = html;
        }

        function resetAnalysis(analysisType) {
            // Clear results
            window.AppState.analysisResults[analysisType] = {};
            
            // Restablecer datos originales si existen correcciones de línea base
            Object.entries(window.AppState.spectraData).forEach(([label, data]) => {
                if (data.originalTransmittance) {
                    data.transmittance = [...data.originalTransmittance];
                    delete data.baselineCorrections;
                }
            });
            
            // Restablecer estado de línea base
            window.AppState.processingStatus.baselineCorrected = false;
            
            // Limpiar visualización
            const plotElement = document.getElementById(`${analysisType}Plot`);
            if (plotElement) {
                Plotly.purge(plotElement);
            }
            
            // Actualizar gráficos de intervalos
            updateAllAnalysisPlots();
            
            // Clear results display
            const resultsElement = document.getElementById(`${analysisType}Results`);
            if (resultsElement) {
                resultsElement.innerHTML = `
                    <p class="text-muted">No analysis results yet. Click "Analyze All Automatically" to start.</p>
                `;
            }
            
            console.log(`Analysis of ${analysisType} reset - original data restored`);
        }

        // Report Generation Functions
        function generateReports() {
            console.log('Generating complete reports...');
            
            try {
                updateSummaryStatistics();
                updateResultsTable();
                plotDepthProfile();
                
                console.log('Reports generated successfully');
            } catch (error) {
                console.error('Error generating reports:', error);
                alert(`Error generating reports: ${error.message}`);
            }
        }



        function getAllAnalysisResults() {
            const analysisTypes = ['oxidation', 'crystallinity', 'tvi'];
            const results = {
                depths: [],
                oxidation: [],
                crystallinity: [],
                tvi: []
            };
            
            // Obtener todas las profundidades únicas
            const allDepths = new Set();
            analysisTypes.forEach(type => {
                Object.keys(window.AppState.analysisResults[type]).forEach(label => {
                    const depth = parseFloat(label.replace('μm', ''));
                    allDepths.add(depth);
                });
            });
            
            results.depths = Array.from(allDepths).sort((a, b) => a - b);
            
            // Obtener valores para cada profundidad
            results.depths.forEach(depth => {
                const depthLabel = `${depth}μm`;
                
                analysisTypes.forEach(type => {
                    const analysis = window.AppState.analysisResults[type][depthLabel];
                    const value = analysis && analysis.index ? analysis.index : null;
                    results[type].push(value);
                });
            });
            
            return results;
        }

        function updateSummaryStatistics() {
            const summaryElement = document.getElementById('summaryStats');
            if (!summaryElement) return;
            
            const results = getAllAnalysisResults();
            const spectraData = window.AppState.spectraData;
            
            if (!spectraData || Object.keys(spectraData).length === 0) {
                summaryElement.innerHTML = '<p class="text-muted">No data available for analysis</p>';
                return;
            }
            
            const spectraKeys = Object.keys(spectraData);
            let html = `
                <div class="stat-item">
                    <span class="stat-label">
                        <i class="fas fa-layer-group me-1"></i>Total Spectra
                    </span>
                    <span class="stat-value">${spectraKeys.length}</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">
                        <i class="fas fa-ruler me-1"></i>Depth Range
                    </span>
                    <span class="stat-value">${results.depths.length > 0 ? 
                        `${Math.min(...results.depths)} - ${Math.max(...results.depths)} μm` : 'N/A'}</span>
                </div>
            `;
            
            // Specific analysis statistics
            const analysisTypes = ['oxidation', 'crystallinity', 'tvi'];
            const analysisNames = {
                oxidation: 'Oxidation',
                crystallinity: 'Crystallinity',
                tvi: 'TVI'
            };
            
            analysisTypes.forEach(analysisType => {
                const values = results[analysisType].filter(val => val !== null && !isNaN(val));
                
                if (values.length > 0) {
                    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const std = Math.sqrt(values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length);
                    
                    html += `
                        <div class="stat-item">
                            <span class="stat-label">
                                <i class="fas fa-chart-line me-1"></i>${analysisNames[analysisType]} Average
                            </span>
                            <span class="stat-value">${mean.toFixed(4)}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">
                                <i class="fas fa-arrow-up me-1"></i>${analysisNames[analysisType]} Maximum
                            </span>
                            <span class="stat-value text-success">${max.toFixed(4)}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">
                                <i class="fas fa-arrow-down me-1"></i>${analysisNames[analysisType]} Minimum
                            </span>
                            <span class="stat-value text-info">${min.toFixed(4)}</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">
                                <i class="fas fa-chart-bar me-1"></i>${analysisNames[analysisType]} Std Dev
                            </span>
                            <span class="stat-value text-warning">${std.toFixed(4)}</span>
                        </div>
                    `;
                }
            });
            
            summaryElement.innerHTML = html;
        }

        function updateResultsTable() {
            const tableBody = document.querySelector('#resultsTable tbody');
            if (!tableBody) return;
            
            const results = getAllAnalysisResults();
            
            if (results.depths.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">No analysis results available</td></tr>';
                return;
            }
            
            let html = '';
            
            results.depths.forEach((depth, index) => {
                const oxidationValue = results.oxidation[index];
                const crystallinityValue = results.crystallinity[index];
                const tviValue = results.tvi[index];
                
                html += `
                    <tr>
                        <td><strong>${depth.toFixed(1)} μm</strong></td>
                        <td>${oxidationValue !== null ? `<span class="badge bg-secondary">${oxidationValue.toFixed(4)}</span>` : '<span class="text-muted">N/A</span>'}</td>
                        <td>${crystallinityValue !== null ? `<span class="badge bg-secondary">${crystallinityValue.toFixed(4)}</span>` : '<span class="text-muted">N/A</span>'}</td>
                        <td>${tviValue !== null ? `<span class="badge bg-secondary">${tviValue.toFixed(4)}</span>` : '<span class="text-muted">N/A</span>'}</td>
                    </tr>
                `;
            });
            
            tableBody.innerHTML = html;
        }

        function plotDepthProfile() {
            const plotElement = document.getElementById('depthProfilePlot');
            if (!plotElement) return;
            
            const results = getAllAnalysisResults();
            
            if (results.depths.length === 0) {
                plotElement.innerHTML = '<div class="text-center text-muted p-4">No analysis results available</div>';
                return;
            }
            
            const traces = [];
            
            // Oxidation depth profile
            if (results.oxidation.some(val => val !== null)) {
                traces.push({
                    x: results.depths,
                    y: results.oxidation,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Oxidation Index',
                    line: {
                        color: '#e74c3c',
                        width: 3
                    },
                    marker: {
                        size: 8,
                        color: '#e74c3c'
                    }
                });
            }
            
            // Crystallinity depth profile
            if (results.crystallinity.some(val => val !== null)) {
                traces.push({
                    x: results.depths,
                    y: results.crystallinity,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'Crystallinity Index',
                    line: {
                        color: '#3498db',
                        width: 3
                    },
                    marker: {
                        size: 8,
                        color: '#3498db'
                    }
                });
            }
            
            // TVI depth profile
            if (results.tvi.some(val => val !== null)) {
                traces.push({
                    x: results.depths,
                    y: results.tvi,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: 'TVI Index',
                    line: {
                        color: '#2ecc71',
                        width: 3
                    },
                    marker: {
                        size: 8,
                        color: '#2ecc71'
                    }
                });
            }
            
            const layout = {
                title: 'Analysis Results vs Depth Profile',
                xaxis: {
                    title: 'Depth (μm)',
                    showgrid: true,
                    gridcolor: '#e2e8f0'
                },
                yaxis: {
                    title: 'Index Value',
                    showgrid: true,
                    gridcolor: '#e2e8f0'
                },
                hovermode: 'x unified',
                showlegend: true,
                legend: {
                    orientation: 'h',
                    x: 0,
                    y: 1.1
                },
                plot_bgcolor: 'white',
                paper_bgcolor: 'white'
            };
            
            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };
            
            Plotly.newPlot(plotElement, traces, layout, config);
        }

        function exportReports() {
            const exportModal = createExportModal();
            document.body.appendChild(exportModal);
            
            // Show modal using Bootstrap
            const modal = new bootstrap.Modal(exportModal);
            modal.show();
            
            // Clean up when modal is hidden
            exportModal.addEventListener('hidden.bs.modal', function () {
                document.body.removeChild(exportModal);
            });
        }

        function createExportModal() {
            const modal = document.createElement('div');
            modal.className = 'modal fade';
            modal.tabIndex = -1;
            modal.innerHTML = `
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="fas fa-download me-2"></i>Export Analysis Reports
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <div class="row">
                                <div class="col-md-6">
                                    <h6>Data Export Formats</h6>
                                    <div class="list-group">
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportData('csv')">
                                            <i class="fas fa-file-csv me-2"></i>CSV (Comma Separated Values)
                                            <small class="d-block text-muted">Suitable for Excel and data analysis</small>
                                        </button>
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportData('xlsx')">
                                            <i class="fas fa-file-excel me-2"></i>Excel Workbook
                                            <small class="d-block text-muted">Complete workbook with multiple sheets</small>
                                        </button>
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportData('json')">
                                            <i class="fas fa-file-code me-2"></i>JSON Data
                                            <small class="d-block text-muted">Machine-readable format</small>
                                        </button>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <h6>Chart Export</h6>
                                    <div class="list-group">
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportPlots('png')">
                                            <i class="fas fa-image me-2"></i>PNG Images
                                            <small class="d-block text-muted">High-quality raster images</small>
                                        </button>
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportPlots('svg')">
                                            <i class="fas fa-vector-square me-2"></i>SVG Vector Graphics
                                            <small class="d-block text-muted">Scalable vector format</small>
                                        </button>
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportCompleteReport()">
                                            <i class="fas fa-file-code me-2"></i>HTML Report with Charts
                                            <small class="d-block text-muted">Complete HTML with embedded charts</small>
                                        </button>
                                        <button type="button" class="list-group-item list-group-item-action" onclick="exportPDFReport()">
                                            <i class="fas fa-file-pdf me-2"></i>PDF Report
                                            <small class="d-block text-muted">Professional PDF document</small>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="row mt-4">
                                <div class="col-12">
                                    <h6>Export Options</h6>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="includeRawData" checked>
                                        <label class="form-check-label" for="includeRawData">
                                            Include original spectral data
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="includeStatistics" checked>
                                        <label class="form-check-label" for="includeStatistics">
                                            Include summary statistics with maximum values
                                        </label>
                                    </div>
                                    <div class="form-check">
                                        <input class="form-check-input" type="checkbox" id="includeParameters" checked>
                                        <label class="form-check-label" for="includeParameters">
                                            Include analysis parameters used
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            return modal;
        }

        function exportData(format) {
            const results = getAllAnalysisResults();
            const includeRawData = document.getElementById('includeRawData')?.checked || false;
            const includeStatistics = document.getElementById('includeStatistics')?.checked || false;
            const includeParameters = document.getElementById('includeParameters')?.checked || false;
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const filename = `FTIR_Analysis_Results_${timestamp}`;
            
            switch (format) {
                case 'csv':
                    exportToCSV(results, filename, { includeRawData, includeStatistics, includeParameters });
                    break;
                case 'xlsx':
                    exportToExcel(results, window.AppState.spectraData, filename, { includeRawData, includeStatistics, includeParameters });
                    break;
                case 'json':
                    exportToJSON(results, window.AppState.spectraData, filename, { includeRawData, includeStatistics, includeParameters });
                    break;
            }
        }

        function exportToCSV(results, filename, options) {
            let csvContent = '';
            
            // Headers with filename
            csvContent += 'FTIR UHMWPE Analysis Results\n';
            csvContent += `Sample File(s): ${window.AppState.currentFileName || 'Unknown'}\n`;
            csvContent += `Exported: ${new Date().toLocaleString()}\n\n`;
            
            // Tabla principal de resultados
            csvContent += 'Depth (μm),Oxidation Index,Crystallinity Index,TVI Index\n';
            
            results.depths.forEach((depth, index) => {
                const oxidation = results.oxidation[index] !== null ? results.oxidation[index].toFixed(6) : 'N/A';
                const crystallinity = results.crystallinity[index] !== null ? results.crystallinity[index].toFixed(6) : 'N/A';
                const tvi = results.tvi[index] !== null ? results.tvi[index].toFixed(6) : 'N/A';
                
                csvContent += `${depth},${oxidation},${crystallinity},${tvi}\n`;
            });
            
            // Statistics with maximum values highlighted
            if (options.includeStatistics) {
                csvContent += '\n\nStatistics Summary\n';
                csvContent += 'Analysis Type,Mean,Std Dev,Min,Max,Count\n';
                
                ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                    const values = results[type].filter(v => v !== null && !isNaN(v));
                    if (values.length > 0) {
                        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                        const stdDev = Math.sqrt(variance);
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        
                        csvContent += `${type},${mean.toFixed(6)},${stdDev.toFixed(6)},${min.toFixed(6)},${max.toFixed(6)},${values.length}\n`;
                    }
                });
                
                // Add maximum values section
                csvContent += '\n\nMaximum Values Summary\n';
                csvContent += 'Analysis Type,Maximum Value,Depth at Maximum (μm)\n';
                
                ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                    const values = results[type];
                    const maxValue = Math.max(...values.filter(v => v !== null && !isNaN(v)));
                    const maxIndex = values.indexOf(maxValue);
                    const depthAtMax = maxIndex !== -1 ? results.depths[maxIndex] : 'N/A';
                    
                    if (!isNaN(maxValue) && maxValue !== -Infinity) {
                        csvContent += `${type},${maxValue.toFixed(6)},${depthAtMax}\n`;
                    }
                });
            }
            
            // Analysis parameters
            if (options.includeParameters) {
                csvContent += '\n\nAnalysis Parameters\n';
                csvContent += 'Analysis Type,Interest Peak Min (cm-1),Interest Peak Max (cm-1),Reference Peak Min (cm-1),Reference Peak Max (cm-1)\n';
                
                Object.entries(ANALYSIS_PARAMETERS).forEach(([type, params]) => {
                    csvContent += `${type},${params.interestPeak.min},${params.interestPeak.max},${params.referencePeak.min},${params.referencePeak.max}\n`;
                });
            }
            
            // Original spectral data
            if (options.includeRawData && window.AppState.spectraData) {
                csvContent += '\n\nRaw Spectral Data\n';
                const spectraData = window.AppState.spectraData;
                const spectraKeys = Object.keys(spectraData);
                
                if (spectraKeys.length > 0) {
                    // Headers
                    const firstSpectrum = spectraData[spectraKeys[0]];
                    csvContent += 'Wavenumber (cm-1),' + spectraKeys.join(',') + '\n';
                    
                    // Data
                    firstSpectrum.frequency.forEach((freq, index) => {
                        let row = freq.toString();
                        spectraKeys.forEach(key => {
                            const transmittance = spectraData[key].transmittance[index];
                            row += ',' + (transmittance !== undefined ? transmittance.toFixed(6) : 'N/A');
                        });
                        csvContent += row + '\n';
                    });
                }
            }
            
            downloadFile(csvContent, `${filename}.csv`, 'text/csv');
        }

        function exportToExcel(results, spectraData, filename, options) {
            const workbook = XLSX.utils.book_new();
            
            // Sheet 1: Main results
            const resultsData = [
                ['FTIR UHMWPE Analysis Results'],
                [`Sample File(s): ${window.AppState.currentFileName || 'Unknown'}`],
                [`Exported: ${new Date().toLocaleString()}`],
                [],
                ['Depth (μm)', 'Oxidation Index', 'Crystallinity Index', 'TVI Index']
            ];
            
            results.depths.forEach((depth, index) => {
                resultsData.push([
                    depth,
                    results.oxidation[index] !== null ? results.oxidation[index] : 'N/A',
                    results.crystallinity[index] !== null ? results.crystallinity[index] : 'N/A',
                    results.tvi[index] !== null ? results.tvi[index] : 'N/A'
                ]);
            });
            
            const resultsSheet = XLSX.utils.aoa_to_sheet(resultsData);
            XLSX.utils.book_append_sheet(workbook, resultsSheet, 'Analysis Results');
            
            // Sheet 2: Statistics with maximum values
            if (options.includeStatistics) {
                const statsData = [
                    ['Statistics Summary'],
                    [],
                    ['Analysis Type', 'Mean', 'Std Dev', 'Min', 'Max', 'Count']
                ];
                
                ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                    const values = results[type].filter(v => v !== null && !isNaN(v));
                    if (values.length > 0) {
                        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                        const stdDev = Math.sqrt(variance);
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        
                        statsData.push([type, mean, stdDev, min, max, values.length]);
                    }
                });
                
                // Add maximum values section
                statsData.push([]);
                statsData.push(['Maximum Values Summary']);
                statsData.push(['Analysis Type', 'Maximum Value', 'Depth at Maximum (μm)']);
                
                ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                    const values = results[type];
                    const maxValue = Math.max(...values.filter(v => v !== null && !isNaN(v)));
                    const maxIndex = values.indexOf(maxValue);
                    const depthAtMax = maxIndex !== -1 ? results.depths[maxIndex] : 'N/A';
                    
                    if (!isNaN(maxValue) && maxValue !== -Infinity) {
                        statsData.push([type, maxValue, depthAtMax]);
                    }
                });
                
                const statsSheet = XLSX.utils.aoa_to_sheet(statsData);
                XLSX.utils.book_append_sheet(workbook, statsSheet, 'Statistics');
            }
            
            // Sheet 3: Parameters
            if (options.includeParameters) {
                const paramsData = [
                    ['Analysis Parameters'],
                    [],
                    ['Analysis Type', 'Interest Peak Min (cm-1)', 'Interest Peak Max (cm-1)', 'Reference Peak Min (cm-1)', 'Reference Peak Max (cm-1)']
                ];
                
                Object.entries(ANALYSIS_PARAMETERS).forEach(([type, params]) => {
                    paramsData.push([type, params.interestPeak.min, params.interestPeak.max, params.referencePeak.min, params.referencePeak.max]);
                });
                
                const paramsSheet = XLSX.utils.aoa_to_sheet(paramsData);
                XLSX.utils.book_append_sheet(workbook, paramsSheet, 'Parameters');
            }
            
            // Sheet 4: Original spectral data
            if (options.includeRawData && spectraData) {
                const spectraKeys = Object.keys(spectraData);
                if (spectraKeys.length > 0) {
                    const firstSpectrum = spectraData[spectraKeys[0]];
                    const spectralData = [
                        ['Raw Spectral Data'],
                        [],
                        ['Wavenumber (cm-1)', ...spectraKeys]
                    ];
                    
                    firstSpectrum.frequency.forEach((freq, index) => {
                        const row = [freq];
                        spectraKeys.forEach(key => {
                            const transmittance = spectraData[key].transmittance[index];
                            row.push(transmittance !== undefined ? transmittance : 'N/A');
                        });
                        spectralData.push(row);
                    });
                    
                    const spectralSheet = XLSX.utils.aoa_to_sheet(spectralData);
                    XLSX.utils.book_append_sheet(workbook, spectralSheet, 'Raw Data');
                }
            }
            
            // Generate and download Excel file
            const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${filename}.xlsx`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportToJSON(results, spectraData, filename, options) {
            const exportData = {
                metadata: {
                    title: 'FTIR UHMWPE Analysis Results',
                    sampleFiles: window.AppState.currentFileName || 'Unknown',
                    loadedFiles: window.AppState.loadedFiles || [],
                    exportDate: new Date().toISOString(),
                    version: '1.0',
                    description: 'Complete analysis results including oxidation, crystallinity, and TVI indices'
                },
                results: {
                    depths: results.depths,
                    oxidation: results.oxidation,
                    crystallinity: results.crystallinity,
                    tvi: results.tvi
                }
            };
            
            // Estadísticas
            if (options.includeStatistics) {
                exportData.statistics = {};
                ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                    const values = results[type].filter(v => v !== null && !isNaN(v));
                    if (values.length > 0) {
                        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                        const stdDev = Math.sqrt(variance);
                        
                        exportData.statistics[type] = {
                            mean: mean,
                            standardDeviation: stdDev,
                            min: Math.min(...values),
                            max: Math.max(...values),
                            count: values.length
                        };
                    }
                });
            }
            
            // Parámetros
            if (options.includeParameters) {
                exportData.analysisParameters = ANALYSIS_PARAMETERS;
            }
            
            // Datos espectrales
            if (options.includeRawData && spectraData) {
                exportData.rawSpectralData = spectraData;
            }
            
            const jsonString = JSON.stringify(exportData, null, 2);
            downloadFile(jsonString, `${filename}.json`, 'application/json');
        }

        function exportPlots(format) {
            const plots = [
                { id: 'overviewPlot', name: 'Overview_Spectra' },
                { id: 'oxidationPlot', name: 'Oxidation_Analysis' },
                { id: 'crystallinityPlot', name: 'Crystallinity_Analysis' },
                { id: 'tviPlot', name: 'TVI_Analysis' },
                { id: 'depthProfilePlot', name: 'Depth_Profile' }
            ];
            
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            
            plots.forEach(plot => {
                const plotElement = document.getElementById(plot.id);
                if (plotElement && plotElement.data && plotElement.data.length > 0) {
                    const options = {
                        format: format,
                        width: 1200,
                        height: 800,
                        filename: `${plot.name}_${timestamp}`
                    };
                    
                    Plotly.downloadImage(plotElement, options);
                }
            });
        }

        async function captureAllPlots() {
            const plots = [
                { id: 'overviewPlot', name: 'Overview Spectra' },
                { id: 'oxidationReferencePlot', name: 'Oxidation Analysis - Reference' },
                { id: 'oxidationInterestPlot', name: 'Oxidation Analysis - Interest' },
                { id: 'crystallinityReferencePlot', name: 'Crystallinity Analysis - Reference' },
                { id: 'crystallinityInterestPlot', name: 'Crystallinity Analysis - Interest' },
                { id: 'tviReferencePlot', name: 'TVI Analysis - Reference' },
                { id: 'tviInterestPlot', name: 'TVI Analysis - Interest' },
                { id: 'depthProfilePlot', name: 'Depth Profile' }
            ];
            
            const plotImages = {};
            
            for (const plot of plots) {
                const plotElement = document.getElementById(plot.id);
                if (plotElement && plotElement.data && plotElement.data.length > 0) {
                    try {
                        const imageData = await Plotly.toImage(plotElement, {
                            format: 'png',
                            width: 800,
                            height: 500
                        });
                        plotImages[plot.id] = {
                            name: plot.name,
                            data: imageData
                        };
                    } catch (error) {
                        console.warn(`Could not capture chart ${plot.id}:`, error);
                    }
                }
            }
            
            return plotImages;
        }

        async function captureAllPlotsEnhanced() {
            const plots = [
                { id: 'overviewPlot', name: 'Overview Spectra' },
                { id: 'oxidationReferencePlot', name: 'Oxidation Analysis - Reference Peak' },
                { id: 'oxidationInterestPlot', name: 'Oxidation Analysis - Interest Peak' },
                { id: 'crystallinityReferencePlot', name: 'Crystallinity Analysis - Reference Peak' },
                { id: 'crystallinityInterestPlot', name: 'Crystallinity Analysis - Interest Peak' },
                { id: 'tviReferencePlot', name: 'TVI Analysis - Reference Peak' },
                { id: 'tviInterestPlot', name: 'TVI Analysis - Interest Peak' },
                { id: 'depthProfilePlot', name: 'Analysis Results vs Depth Profile' }
            ];
            
            const plotImages = {};
            
            for (const plot of plots) {
                const plotElement = document.getElementById(plot.id);
                if (plotElement && plotElement.data && plotElement.data.length > 0) {
                    try {
                        const imageData = await Plotly.toImage(plotElement, {
                            format: 'png',
                            width: 1200, // Higher resolution for PDF
                            height: 800,
                            scale: 2 // Enhanced quality
                        });
                        plotImages[plot.id] = {
                            name: plot.name,
                            data: imageData
                        };
                    } catch (error) {
                        console.warn(`Could not capture enhanced chart ${plot.id}:`, error);
                    }
                }
            }
            
            return plotImages;
        }

        async function exportCompleteReport() {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const results = getAllAnalysisResults();
            
            showLoading('Generating HTML report with embedded charts...');
            
            try {
                // Capturar todos los gráficos
                const plotImages = await captureAllPlots();
                
                let reportHTML = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>FTIR UHMWPE Report - ${timestamp}</title>
                    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
                    <style>
                        body { font-family: Arial, sans-serif; margin: 20px; }
                        .header { text-align: center; margin-bottom: 30px; }
                        .results-table { margin: 20px 0; }
                        .plot-container { text-align: center; margin: 20px 0; }
                        .max-values { background-color: #f8f9fa; border: 2px solid #dc3545; padding: 15px; margin: 20px 0; border-radius: 5px; }
                        .sample-info { background-color: #e9ecef; padding: 10px; margin-bottom: 20px; border-radius: 5px; }
                        @media print { .no-print { display: none; } }
                    </style>
                </head>
                <body>
                    <div class="header">
                        <h1>FTIR UHMWPE Analysis Report</h1>
                        <div class="sample-info">
                            <strong>Sample File(s):</strong> ${window.AppState.currentFileName || 'Unknown'}
                        </div>
                        <p>Generated on: ${new Date().toLocaleString()}</p>
                    </div>
                    
                    <div class="container">
                        <h2>Results Summary</h2>
                        <table class="table table-striped results-table">
                            <thead>
                                <tr>
                                    <th>Depth (μm)</th>
                                    <th>Oxidation Index</th>
                                    <th>Crystallinity Index</th>
                                    <th>TVI Index</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            results.depths.forEach((depth, index) => {
                const oxidation = results.oxidation[index] !== null ? results.oxidation[index].toFixed(4) : 'N/A';
                const crystallinity = results.crystallinity[index] !== null ? results.crystallinity[index].toFixed(4) : 'N/A';
                const tvi = results.tvi[index] !== null ? results.tvi[index].toFixed(4) : 'N/A';
                
                reportHTML += `
                    <tr>
                        <td>${depth.toFixed(1)}</td>
                        <td>${oxidation}</td>
                        <td>${crystallinity}</td>
                        <td>${tvi}</td>
                    </tr>
                `;
            });
            
            reportHTML += `
                            </tbody>
                        </table>
                        
                        <h2>Gráficos de Análisis</h2>
            `;
            
            // Añadir gráficos embebidos
            Object.keys(plotImages).forEach(plotId => {
                const plotInfo = plotImages[plotId];
                reportHTML += `
                    <div class="plot-container">
                        <h4>${plotInfo.name}</h4>
                        <img src="${plotInfo.data}" alt="${plotInfo.name}" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 8px;">
                    </div>
                `;
            });
            
            reportHTML += `
                        <h2>Estadísticas Resumidas</h2>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Análisis</th>
                                    <th>Media</th>
                                    <th>Desviación Estándar</th>
                                    <th>Mínimo</th>
                                    <th>Máximo</th>
                                    <th>Cuenta</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                const values = results[type].filter(v => v !== null && !isNaN(v));
                if (values.length > 0) {
                    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                    const stdDev = Math.sqrt(variance);
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    
                    const typeNames = {
                        oxidation: 'Oxidation',
                        crystallinity: 'Crystallinity',
                        tvi: 'TVI'
                    };
                    
                    reportHTML += `
                        <tr>
                            <td>${typeNames[type]}</td>
                            <td>${mean.toFixed(4)}</td>
                            <td>${stdDev.toFixed(4)}</td>
                            <td>${min.toFixed(4)}</td>
                            <td>${max.toFixed(4)}</td>
                            <td>${values.length}</td>
                        </tr>
                    `;
                }
            });
            
            reportHTML += `
                            </tbody>
                        </table>
                        
                        <h2>Parámetros de Análisis Utilizados</h2>
                        <table class="table table-bordered">
                            <thead>
                                <tr>
                                    <th>Analysis Type</th>
                                    <th>Interest Peak (cm⁻¹)</th>
                                    <th>Reference Peak (cm⁻¹)</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
            `;
            
            Object.entries(ANALYSIS_PARAMETERS).forEach(([type, params]) => {
                reportHTML += `
                    <tr>
                        <td>${params.name}</td>
                        <td>${params.interestPeak.min} - ${params.interestPeak.max}</td>
                        <td>${params.referencePeak.min} - ${params.referencePeak.max}</td>
                        <td>${params.description}</td>
                    </tr>
                `;
            });
            
            reportHTML += `
                            </tbody>
                        </table>
                        
                        <div class="max-values">
                            <h3>Maximum Values Summary</h3>
                            ${['oxidation', 'crystallinity', 'tvi'].map(type => {
                                const values = results[type].filter(v => v !== null && !isNaN(v));
                                if (values.length > 0) {
                                    const max = Math.max(...values);
                                    const maxIndex = results[type].indexOf(max);
                                    const depthAtMax = maxIndex !== -1 ? results.depths[maxIndex] : 'N/A';
                                    const typeNames = { oxidation: 'Oxidation', crystallinity: 'Crystallinity', tvi: 'TVI' };
                                    return `<p><strong>${typeNames[type]} Maximum:</strong> ${max.toFixed(4)} at depth ${depthAtMax} μm</p>`;
                                }
                                return '';
                            }).join('')}
                        </div>
                        
                        <div class="mt-4">
                            <p class="text-muted">
                                <strong>Note:</strong> This report was automatically generated by the FTIR UHMWPE Analyzer.
                                For interactive charts, use the chart export options.
                            </p>
                        </div>
                    </div>
                </body>
                </html>
            `;
            
                downloadFile(reportHTML, `FTIR_Complete_Report_${timestamp}.html`, 'text/html');
                hideLoading();
                showNotification('HTML report with charts generated successfully', 'success');
                
            } catch (error) {
                console.error('Error generating HTML report:', error);
                hideLoading();
                showNotification('Error generating HTML report: ' + error.message, 'error');
            }
        }

        async function exportPDFReport() {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
            const results = getAllAnalysisResults();
            
            if (results.depths.length === 0) {
                showNotification('No analysis results available for export', 'warning');
                return;
            }
            
            showLoading('Generating PDF report...');
            
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                let yPosition = 20;
                
                // Función para añadir nueva página si es necesario
                const checkNewPage = (requiredHeight) => {
                    if (yPosition + requiredHeight > pageHeight - 20) {
                        pdf.addPage();
                        yPosition = 20;
                    }
                };
                
                // Título del documento
                pdf.setFontSize(20);
                pdf.setFont(undefined, 'bold');
                pdf.text('FTIR UHMWPE Analysis Report', pageWidth / 2, yPosition, { align: 'center' });
                yPosition += 15;
                
                // Sample filename
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text(`Sample: ${window.AppState.currentFileName || 'Unknown'}`, pageWidth / 2, yPosition, { align: 'center' });
                yPosition += 10;
                
                // Fecha de generación
                pdf.setFontSize(12);
                pdf.setFont(undefined, 'normal');
                pdf.text(`Generated on: ${new Date().toLocaleString()}`, pageWidth / 2, yPosition, { align: 'center' });
                yPosition += 20;
                
                // Resumen de resultados
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('Results Summary', 20, yPosition);
                yPosition += 10;
                
                // Tabla de resultados
                const headers = ['Depth (μm)', 'Oxidation', 'Crystallinity', 'TVI'];
                const tableData = results.depths.map((depth, index) => [
                    depth.toFixed(1),
                    results.oxidation[index] !== null ? results.oxidation[index].toFixed(4) : 'N/A',
                    results.crystallinity[index] !== null ? results.crystallinity[index].toFixed(4) : 'N/A',
                    results.tvi[index] !== null ? results.tvi[index].toFixed(4) : 'N/A'
                ]);
                
                // Dibujar tabla manualmente
                pdf.setFontSize(10);
                const cellWidth = (pageWidth - 40) / 4;
                const cellHeight = 7;
                
                checkNewPage(cellHeight * (tableData.length + 2));
                
                // Headers
                pdf.setFont(undefined, 'bold');
                headers.forEach((header, i) => {
                    pdf.rect(20 + i * cellWidth, yPosition, cellWidth, cellHeight);
                    pdf.text(header, 20 + i * cellWidth + 2, yPosition + 5);
                });
                yPosition += cellHeight;
                
                // Data rows
                pdf.setFont(undefined, 'normal');
                tableData.forEach((row, rowIndex) => {
                    checkNewPage(cellHeight);
                    row.forEach((cell, i) => {
                        pdf.rect(20 + i * cellWidth, yPosition, cellWidth, cellHeight);
                        pdf.text(String(cell), 20 + i * cellWidth + 2, yPosition + 5);
                    });
                    yPosition += cellHeight;
                });
                
                yPosition += 15;
                
                // Statistics with maximum values highlighted
                checkNewPage(60);
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('Summary Statistics', 20, yPosition);
                yPosition += 15;
                
                pdf.setFontSize(10);
                ['oxidation', 'crystallinity', 'tvi'].forEach(type => {
                    const values = results[type].filter(v => v !== null && !isNaN(v));
                    if (values.length > 0) {
                        const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
                        const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                        const stdDev = Math.sqrt(variance);
                        const min = Math.min(...values);
                        const max = Math.max(...values);
                        const maxIndex = results[type].indexOf(max);
                        const depthAtMax = maxIndex !== -1 ? results.depths[maxIndex] : 'N/A';
                        
                        const typeNames = {
                            oxidation: 'Oxidation',
                            crystallinity: 'Crystallinity',
                            tvi: 'TVI'
                        };
                        
                        checkNewPage(35);
                        pdf.setFont(undefined, 'bold');
                        pdf.text(`${typeNames[type]}:`, 20, yPosition);
                        pdf.setFont(undefined, 'normal');
                        yPosition += 5;
                        
                        pdf.text(`  Mean: ${mean.toFixed(4)}`, 25, yPosition);
                        yPosition += 5;
                        pdf.text(`  Standard Deviation: ${stdDev.toFixed(4)}`, 25, yPosition);
                        yPosition += 5;
                        pdf.text(`  Range: ${min.toFixed(4)} - ${max.toFixed(4)}`, 25, yPosition);
                        yPosition += 5;
                        pdf.setFont(undefined, 'bold');
                        pdf.setTextColor(220, 53, 69); // Red color for maximum
                        pdf.text(`  MAXIMUM: ${max.toFixed(4)} at depth ${depthAtMax} μm`, 25, yPosition);
                        pdf.setTextColor(0, 0, 0); // Reset to black
                        pdf.setFont(undefined, 'normal');
                        yPosition += 5;
                        pdf.text(`  Samples: ${values.length}`, 25, yPosition);
                        yPosition += 10;
                    }
                });
                
                // Add enhanced maximum values summary box
                checkNewPage(50);
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.text('Maximum Values Summary', 20, yPosition);
                yPosition += 10;
                
                // Create a highlighted box for maximum values
                pdf.setDrawColor(220, 53, 69);
                pdf.setLineWidth(0.5);
                pdf.rect(20, yPosition, pageWidth - 40, 30);
                pdf.setDrawColor(0, 0, 0);
                yPosition += 5;
                
                pdf.setFontSize(12);
                ['oxidation', 'crystallinity', 'tvi'].forEach((type, index) => {
                    const values = results[type].filter(v => v !== null && !isNaN(v));
                    if (values.length > 0) {
                        const max = Math.max(...values);
                        const maxIndex = results[type].indexOf(max);
                        const depthAtMax = maxIndex !== -1 ? results.depths[maxIndex] : 'N/A';
                        
                        const typeNames = {
                            oxidation: 'Oxidation',
                            crystallinity: 'Crystallinity',
                            tvi: 'TVI'
                        };
                        
                        pdf.setTextColor(220, 53, 69);
                        pdf.text(`${typeNames[type]}: ${max.toFixed(4)} at ${depthAtMax} μm`, 25, yPosition + (index * 7));
                    }
                });
                pdf.setTextColor(0, 0, 0);
                yPosition += 40;
                
                // Capture and add enhanced plots
                try {
                    updateLoadingText('Capturing high-quality charts for PDF...');
                    const plotImages = await captureAllPlotsEnhanced();
                    
                    Object.keys(plotImages).forEach(plotId => {
                        const plotInfo = plotImages[plotId];
                        
                        checkNewPage(120);
                        pdf.setFontSize(14);
                        pdf.setFont(undefined, 'bold');
                        pdf.text(plotInfo.name, 20, yPosition);
                        yPosition += 10;
                        
                        try {
                            // Enhanced image sizing and quality
                            const imgWidth = pageWidth - 40;
                            const imgHeight = 100; // Increased height for better visibility
                            
                            pdf.addImage(plotInfo.data, 'PNG', 20, yPosition, imgWidth, imgHeight);
                            yPosition += imgHeight + 15;
                        } catch (imgError) {
                            console.warn(`Could not add image ${plotId} to PDF:`, imgError);
                            pdf.setFont(undefined, 'italic');
                            pdf.text('(Chart not available)', 20, yPosition);
                            yPosition += 10;
                        }
                    });
                } catch (plotError) {
                    console.warn('Could not capture charts for PDF:', plotError);
                }
                
                // Información final
                checkNewPage(30);
                yPosition += 10;
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'italic');
                pdf.text('This report was automatically generated by the FTIR UHMWPE Analyzer', 20, yPosition);
                pdf.text(`Timestamp: ${timestamp}`, 20, yPosition + 5);
                
                // Guardar PDF
                pdf.save(`FTIR_Report_${timestamp}.pdf`);
                
                hideLoading();
                showNotification('PDF report generated successfully', 'success');
                
            } catch (error) {
                console.error('Error generating PDF:', error);
                hideLoading();
                showNotification('Error generating PDF: ' + error.message, 'error');
            }
        }

        // Función de análisis completo automático
        async function performFullAutoAnalysis() {
            if (!window.AppState.spectraData || Object.keys(window.AppState.spectraData).length === 0) {
                showNotification('No spectrum data loaded. Please load a file first.', 'warning');
                return;
            }

            const fullAutoBtn = document.getElementById('fullAutoAnalysisBtn');
            const originalText = fullAutoBtn.innerHTML;
            
            try {
                // Deshabilitar botón durante el análisis
                fullAutoBtn.disabled = true;
                fullAutoBtn.classList.add('btn-analyzing');
                fullAutoBtn.querySelector('.btn-content').innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Analyzing...';
                
                showLoading('Starting complete automatic analysis...');
                
                // Paso 1: Aplicar corrección de offset automáticamente
                updateLoadingText('Calculating and applying offset correction...');
                await new Promise(resolve => setTimeout(resolve, 800));
                
                try {
                    // Siempre aplicar corrección de offset, incluso si ya está aplicada
                    applyOffsetCorrection();
                    await new Promise(resolve => setTimeout(resolve, 500));
                    showNotification('Offset correction calculated and applied', 'success');
                } catch (offsetError) {
                    console.warn('Error en corrección de offset:', offsetError);
                    showNotification('Continuing without offset correction', 'warning');
                }
                
                // Paso 2: Realizar análisis de oxidación
                updateLoadingText('Analyzing oxidation...');
                await new Promise(resolve => setTimeout(resolve, 800));
                try {
                    performAutoAnalysis('oxidation');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    showNotification('Oxidation analysis completed', 'success');
                } catch (oxError) {
                    console.error('Error en análisis de oxidación:', oxError);
                    showNotification('Error in oxidation analysis', 'error');
                }
                
                // Paso 3: Realizar análisis de cristalinidad
                updateLoadingText('Analyzing crystallinity...');
                await new Promise(resolve => setTimeout(resolve, 800));
                try {
                    performAutoAnalysis('crystallinity');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    showNotification('Crystallinity analysis completed', 'success');
                } catch (crystError) {
                    console.error('Error en análisis de cristalinidad:', crystError);
                    showNotification('Error in crystallinity analysis', 'error');
                }
                
                // Paso 4: Realizar análisis TVI
                updateLoadingText('Analyzing TVI...');
                await new Promise(resolve => setTimeout(resolve, 800));
                try {
                    performAutoAnalysis('tvi');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    showNotification('TVI analysis completed', 'success');
                } catch (tviError) {
                    console.error('Error en análisis TVI:', tviError);
                    showNotification('Error in TVI analysis', 'error');
                }
                
                // Paso 5: Generar perfil de profundidad
                updateLoadingText('Generating depth profile...');
                await new Promise(resolve => setTimeout(resolve, 800));
                try {
                    updateDepthProfile();
                    showNotification('Depth profile generated', 'success');
                } catch (depthError) {
                    console.error('Error en perfil de profundidad:', depthError);
                    showNotification('Error generating depth profile', 'warning');
                }
                
                // Completar
                hideLoading();
                
                // Mostrar resumen de resultados
                setTimeout(() => {
                    showAnalysisCompleteSummary();
                }, 1000);
                
            } catch (error) {
                console.error('Error en análisis completo automático:', error);
                hideLoading();
                showNotification('Error durante el análisis automático: ' + error.message, 'error');
            } finally {
                // Restaurar botón
                fullAutoBtn.disabled = false;
                fullAutoBtn.classList.remove('btn-analyzing');
                fullAutoBtn.innerHTML = originalText;
            }
        }

        function updateLoadingText(text) {
            const loadingTextElement = document.getElementById('loadingText');
            if (loadingTextElement) {
                loadingTextElement.textContent = text;
            }
        }

        function updateDepthProfile() {
            // Esta función actualiza el gráfico de perfil de profundidad
            const plotElement = document.getElementById('depthProfilePlot');
            if (!plotElement) return;
            
            try {
                plotDepthProfile();
                console.log('Perfil de profundidad actualizado');
            } catch (error) {
                console.error('Error actualizando perfil de profundidad:', error);
            }
        }

        function showAnalysisCompleteSummary() {
            const results = window.AppState.analysisResults;
            
            if (!results.oxidation || !results.crystallinity || !results.tvi) {
                showNotification('Análisis completo finalizado, pero algunos resultados no están disponibles', 'warning');
                return;
            }
            
            // Contar resultados
            const oxidationCount = Object.keys(results.oxidation).length;
            const crystallinityCount = Object.keys(results.crystallinity).length;
            const tviCount = Object.keys(results.tvi).length;
            
            // Calcular estadísticas rápidas
            const oxidationValues = Object.values(results.oxidation).map(r => r.ratio).filter(v => v !== null && !isNaN(v));
            const crystallinityValues = Object.values(results.crystallinity).map(r => r.ratio).filter(v => v !== null && !isNaN(v));
            const tviValues = Object.values(results.tvi).map(r => r.ratio).filter(v => v !== null && !isNaN(v));
            
            const avgOxidation = oxidationValues.length > 0 ? (oxidationValues.reduce((a, b) => a + b, 0) / oxidationValues.length).toFixed(4) : 'N/A';
            const avgCrystallinity = crystallinityValues.length > 0 ? (crystallinityValues.reduce((a, b) => a + b, 0) / crystallinityValues.length).toFixed(4) : 'N/A';
            const avgTvi = tviValues.length > 0 ? (tviValues.reduce((a, b) => a + b, 0) / tviValues.length).toFixed(4) : 'N/A';
            
            const summaryMessage = `
🔬 **COMPLETE ANALYSIS FINISHED**

📊 **Processed Results:**
• Oxidation: ${oxidationCount} samples (average: ${avgOxidation})
• Crystallinity: ${crystallinityCount} samples (average: ${avgCrystallinity})
• TVI: ${tviCount} samples (average: ${avgTvi})

✅ All analyses have been completed with automatic baseline
📈 Charts and results are available in the corresponding tabs

            `;
            
            showNotification(summaryMessage, 'success', 8000);
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Event Listeners Setup
        document.addEventListener('DOMContentLoaded', function() {
            console.log('FTIR UHMWPE Deep Analyzer initialized');
            
            // Initialize file handlers
            initializeFileHandlers();
            
            // Initialize Bootstrap tooltips
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
            
            // Event listeners para controles de procesamiento
            document.getElementById('autoOffsetBtn').addEventListener('click', performAutoOffset);
            document.getElementById('manualOffsetBtn').addEventListener('click', enableManualOffset);
            
            // Event listeners para botones de análisis
            document.getElementById('autoAnalyzeOxidation').addEventListener('click', () => performAutoAnalysis('oxidation'));
            document.getElementById('manualBaselineOxidation').addEventListener('click', () => enableManualBaseline('oxidation'));
            document.getElementById('resetOxidationAnalysis').addEventListener('click', () => resetAnalysis('oxidation'));
            
            document.getElementById('autoAnalyzeCrystallinity').addEventListener('click', () => performAutoAnalysis('crystallinity'));
            document.getElementById('manualBaselineCrystallinity').addEventListener('click', () => enableManualBaseline('crystallinity'));
            document.getElementById('resetCrystallinityAnalysis').addEventListener('click', () => resetAnalysis('crystallinity'));
            
            document.getElementById('autoAnalyzeTvi').addEventListener('click', () => performAutoAnalysis('tvi'));
            document.getElementById('manualBaselineTvi').addEventListener('click', () => enableManualBaseline('tvi'));
            document.getElementById('resetTviAnalysis').addEventListener('click', () => resetAnalysis('tvi'));
            

            
            // Event listeners para actualización automática de gráficos de intervalos cuando cambien parámetros
            const parameterInputs = [
                'oxidationInterestMin', 'oxidationInterestMax', 'oxidationRefMin', 'oxidationRefMax',
                'crystallinityInterestMin', 'crystallinityInterestMax', 'crystallinityRefMin', 'crystallinityRefMax',
                'tviInterestMin', 'tviInterestMax', 'tviRefMin', 'tviRefMax'
            ];
            
            parameterInputs.forEach(inputId => {
                const element = document.getElementById(inputId);
                if (element) {
                    element.addEventListener('input', debounce(() => {
                        if (window.AppState.spectraData && Object.keys(window.AppState.spectraData).length > 0) {
                            // Determinar qué análisis se ha modificado
                            const analysisType = inputId.includes('oxidation') ? 'oxidation' : 
                                               inputId.includes('crystallinity') ? 'crystallinity' : 'tvi';
                            
                            console.log(`Parameter changed for ${analysisType}: ${inputId}`);
                            
                            // Si ya existen resultados para este análisis, recalcular automáticamente
                            if (window.AppState.analysisResults[analysisType] && 
                                Object.keys(window.AppState.analysisResults[analysisType]).length > 0) {
                                
                                console.log(`Auto-recalculating ${analysisType} analysis with new intervals`);
                                performAutoAnalysis(analysisType);
                            } else {
                                // Solo actualizar gráficos de intervalos si no hay análisis
                                updateAllAnalysisPlots();
                                
                                // Actualizar también gráficos individuales de intervalos
                                updateReferenceIntervalPlot(analysisType);
                                updateInterestIntervalPlot(analysisType);
                            }
                        }
                    }, 500)); // Aumentar debounce para evitar cálculos excesivos
                }
            });
            
            // Event listener para análisis completo automático
            document.getElementById('fullAutoAnalysisBtn').addEventListener('click', performFullAutoAnalysis);
            
            // Event listeners para reportes
            document.getElementById('generateReportsBtn').addEventListener('click', generateReports);
            document.getElementById('exportReportsBtn').addEventListener('click', exportReports);
            
            // Event listeners para deconvolución
            document.getElementById('performDeconvolutionBtn').addEventListener('click', performDeconvolution);
            document.getElementById('resetDeconvolutionBtn').addEventListener('click', resetDeconvolution);
            
            // Event listeners para deconvolución múltiple
            document.getElementById('runMultipleDeconvBtn').addEventListener('click', runMultipleDeconvolution);
            document.getElementById('resetMultipleDeconvBtn').addEventListener('click', resetMultipleDeconvolution);
            document.getElementById('exportMultiDeconvPdfBtn').addEventListener('click', exportMultipleDeconvolutionToPDF);
            document.getElementById('exportMultiDeconvExcelBtn').addEventListener('click', exportMultipleDeconvolutionToExcel);
            
            // Event listeners para controles de visualización
            document.getElementById('toggleSpectraBtn')?.addEventListener('click', () => alert('Alternar vista: Se implementará funcionalidad de vista individual/superpuesta.'));
            document.getElementById('resetZoomBtn')?.addEventListener('click', () => {
                // Restablecer zoom en todos los gráficos
                const plots = ['overviewPlot', 'oxidationPlot', 'crystallinityPlot', 'tviPlot', 'depthProfilePlot'];
                plots.forEach(plotId => {
                    const element = document.getElementById(plotId);
                    if (element && element.data) {
                        Plotly.relayout(element, {
                            'xaxis.autorange': true,
                            'yaxis.autorange': true
                        });
                    }
                });
            });
        });

        // DECONVOLUTION FUNCTIONS        
        // Define carbonyl species based on provided table (only ketones, carboxylic acids, esters)
        const CARBONYL_SPECIES = {
            ketones: { 
                freq: 1721, 
                name: 'Ketones', 
                color: '#3498db', 
                bandWidth: 12, // Average of 11-13
                lorentzianContrib: 0.915, // Average of 90-93%
                lorentzianMin: 0.90,
                lorentzianMax: 0.93
            },
            carboxylic_acids: { 
                freq: 1714, 
                name: 'Carboxylic Acids (associated)', 
                color: '#2ecc71', 
                bandWidth: 17, // Average of 16-18
                lorentzianContrib: 0.90, // Average of 85-95%
                lorentzianMin: 0.85,
                lorentzianMax: 0.95
            },
            esters_aldehydes: { 
                freq: 1737, 
                name: 'Esters and Aldehydes', 
                color: '#e74c3c', 
                bandWidth: 19, 
                lorentzianContrib: 0.875, // Average of 85-90%
                lorentzianMin: 0.85,
                lorentzianMax: 0.90
            },
            carboxylic_acids_isolated: { 
                freq: 1767, 
                name: 'Carboxylic Acids (isolated)', 
                color: '#9b59b6', 
                bandWidth: 21.5, // Average of 20-23
                lorentzianContrib: 0.90, // ~90%
                lorentzianMin: 0.88,
                lorentzianMax: 0.92
            },
            gamma_ketoacids_acid: { 
                freq: 1707, 
                name: 'Gamma-ketoacids (acid group)', 
                color: '#f39c12', 
                bandWidth: 16, 
                lorentzianContrib: 0.92, // Average of 90-94%
                lorentzianMin: 0.90,
                lorentzianMax: 0.94
            },
            gamma_ketoacids_keto: { 
                freq: 1698, 
                name: 'Gamma-ketoacids (keto group)', 
                color: '#16a085', 
                bandWidth: 15, 
                lorentzianContrib: 0.90, // ~90%
                lorentzianMin: 0.88,
                lorentzianMax: 0.92
            }
        };

        let deconvolutionResults = {
            species: {},
            fitQuality: {},
            derivatives: {},
            originalSpectrum: [],
            fittedTrace: null,        // ← Nueva lógica
            individualTraces: []      // ← Nueva lógica
        };

        const layout = {
                title: {
                    text: 'Carbonyl Deconvolution - Individual Species Contributions',
                    font: { size: 16, color: '#2c3e50' }
                },
                xaxis: { 
                    title: 'Wavenumber (cm⁻¹)', 
                    range: [1650, 1800],
                    showgrid: true,
                    gridcolor: 'rgba(128,128,128,0.2)'
                },
                yaxis: { 
                    title: 'Absorbance',
                    showgrid: true,
                    gridcolor: 'rgba(128,128,128,0.2)'
                },
                margin: { l: 60, r: 20, t: 60, b: 60 },
                showlegend: true,
                legend: {
                    x: 1.02,
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                hovermode: 'closest',
                plot_bgcolor: 'rgba(248, 249, 250, 0.6)',
                paper_bgcolor: 'white',
                
            };
        const config = { responsive: true };

        async function performDeconvolution() {
            const performBtn = document.getElementById('performDeconvolutionBtn');
            const originalText = performBtn.innerHTML;
            
            try {
                performBtn.disabled = true;
                performBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Performing Deconvolution...';
                
                showLoading('Performing carbonyl deconvolution...');
                
                // Get current spectrum data
                const currentSpectrum = getCurrentSpectrumData();
                if (!currentSpectrum) {
                    throw new Error('Please select a depth to analyze from the dropdown above.');
                }
                
                // Get parameters
                const minFreq = parseFloat(document.getElementById('deconvMinFreq').value);
                const maxFreq = parseFloat(document.getElementById('deconvMaxFreq').value);
                const refBand = parseFloat(document.getElementById('deconvRefBand').value);
                const baselineType = document.getElementById('deconvBaselineType').value;
                
                // Extract carbonyl region
                const carbonylRegion = extractSpectralRegion(currentSpectrum, minFreq, maxFreq);
                
                // Normalize spectrum (according to Salvalaggio methodology)
                const normalizedSpectrum = normalizeSpectrum(carbonylRegion, currentSpectrum, refBand);
                
                // Calculate derivatives
                const derivatives = calculateDerivatives(normalizedSpectrum);
                deconvolutionResults.derivatives = derivatives;
                
                // Perform baseline correction using the same method as automatic oxidation analysis
                const baselineCorrected = automaticBaselineCorrection(normalizedSpectrum);
                
                
                
                // 1) Guardar parámetros optimizados
                const fittingResults = await performCurveFitting(baselineCorrected, derivatives);
                deconvolutionResults.species = fittingResults.species;
                deconvolutionResults.fitQuality = fittingResults.fitQuality;
                deconvolutionResults.originalSpectrum = baselineCorrected;
                

                // 2) Generar individualTraces con species optimizadas
                const individualTraces = Object.entries(deconvolutionResults.species).map(
                ([id, data]) => generateSpeciesTrace(data, id)
                );
                deconvolutionResults.individualTraces = individualTraces;

                // 3) Construir fittedTrace suma de picos
                const freq = baselineCorrected.frequency;
                const fittedY = freq.map((_, i) =>
                individualTraces.reduce((sum, t) => sum + t.y[i], 0)
                );
                const fittedTrace = { x: freq, y: fittedY, name: 'Fitted Spectrum', type: 'scatter', mode: 'lines', line:{color:'#000',width:2} };
                deconvolutionResults.fittedTrace = fittedTrace;

                // 4) Calcular R² y áreaError de forma redundante para mostrar
                const origY = baselineCorrected.transmittance;
                const areaFit = calculateAreaSimpsonRule(freq, fittedY);
                deconvolutionResults.fitQuality.areaError = Math.abs(
                calculateAreaSimpsonRule(freq, origY) - areaFit
                );
                deconvolutionResults.fitQuality.r2 = deconvolutionResults.fitQuality.r2;

                // 5) Plotly: mostrar original baseline, picos y fitted
                const originalTrace = {
                x: freq, y: origY, name: 'Original (baseline-corrected)',
                type:'scatter',mode:'lines',line:{color:'#888',width:1,dash:'dot'}
                };
                Plotly.newPlot('deconvolutionMainPlot', [
                originalTrace,
                ...individualTraces,
                fittedTrace
                ], layout, config);

                // 6) Actualizar UI de resultados
                updateSpeciesQuantificationDisplay();
                updateFitQualityDisplay();

                
                // Update plots
                updateDeconvolutionPlots();
                
                
                showNotification('Deconvolution completed successfully!', 'success');
                
            } catch (error) {
                console.error('Deconvolution error:', error);
                showNotification('Error in deconvolution: ' + error.message, 'error');
            } finally {
                hideLoading();
                performBtn.disabled = false;
                performBtn.innerHTML = originalText;
            }
        }

        function getCurrentSpectrumData() {
            // Get current spectrum from the loaded data
            const spectraData = window.AppState.spectraData;
            if (!spectraData || Object.keys(spectraData).length === 0) {
                return null;
            }
            
            // Get selected depth from deconvolution dropdown
            const selectedDepth = document.getElementById('deconvDepthSelect').value;
            
            if (selectedDepth && spectraData[selectedDepth]) {
                // CRITICAL: Return a deep copy to prevent contamination between tabs
                const originalData = spectraData[selectedDepth];
                return {
                    frequency: [...originalData.frequency],
                    transmittance: originalData.originalTransmittance ? 
                        [...originalData.originalTransmittance] : 
                        [...originalData.transmittance],
                    depth: originalData.depth,
                    color: originalData.color,
                    // Store original for reference but don't expose it for modification
                    originalTransmittance: originalData.originalTransmittance ? 
                        [...originalData.originalTransmittance] : 
                        [...originalData.transmittance]
                };
            }
            
            // If no depth selected in deconvolution tab, show helpful message
            return null;
        }
        
        function populateDepthSelector() {
            const depthSelect = document.getElementById('deconvDepthSelect');
            if (!depthSelect) return; // Element might not exist yet
            
            const spectraData = window.AppState.spectraData;
            
            // Clear existing options
            depthSelect.innerHTML = '<option value="">Choose depth to analyze...</option>';
            
            if (!spectraData || Object.keys(spectraData).length === 0) {
                return;
            }
            
            // Add options for each available depth
            const depths = Object.keys(spectraData).sort((a, b) => {
                // Sort by numeric value if possible
                const numA = parseFloat(a.replace(/[^\d.]/g, ''));
                const numB = parseFloat(b.replace(/[^\d.]/g, ''));
                return numA - numB;
            });
            
            depths.forEach(depth => {
                const option = document.createElement('option');
                option.value = depth;
                option.textContent = depth;
                depthSelect.appendChild(option);
            });
            
            // Add event listener for depth changes
            depthSelect.onchange = function() {
                updateDeconvolutionDepthInfo();
            };
        }
        
        function updateDeconvolutionDepthInfo() {
            const selectedDepth = document.getElementById('deconvDepthSelect').value;
            const spectraData = window.AppState.spectraData;
            const depthSelect = document.getElementById('deconvDepthSelect');
            const depthInfo = document.getElementById('depthSelectionInfo');
            const depthInfoText = document.getElementById('depthInfoText');
            
            if (selectedDepth && spectraData && spectraData[selectedDepth]) {
                const spectrum = spectraData[selectedDepth];
                console.log(`Deconvolution depth changed to: ${selectedDepth}`);
                
                // Update visual indicators
                depthSelect.classList.remove('border-warning');
                depthSelect.classList.add('border-success');
                
                // Show depth information
                depthInfo.style.display = 'block';
                depthInfo.classList.add('depth-selected');
                depthInfoText.innerHTML = `
                    <strong>Selected:</strong> ${selectedDepth} | 
                    <strong>Data points:</strong> ${spectrum.frequency ? spectrum.frequency.length : 'N/A'} | 
                    <strong>Range:</strong> ${spectrum.frequency ? Math.min(...spectrum.frequency).toFixed(0) : 'N/A'}-${spectrum.frequency ? Math.max(...spectrum.frequency).toFixed(0) : 'N/A'} cm⁻¹
                `;
                
                // Reset any previous deconvolution results when depth changes
                resetDeconvolutionResults();
                
                showNotification(`Depth changed to ${selectedDepth}. Ready for deconvolution.`, 'info');
            } else {
                // No depth selected
                depthSelect.classList.remove('border-success');
                depthSelect.classList.add('border-warning');
                
                if (depthInfo) {
                    depthInfo.style.display = 'none';
                    depthInfo.classList.remove('depth-selected');
                }
                
                resetDeconvolutionResults();
            }
        }
        
        function resetDeconvolutionResults() {
            // Clear previous results when changing depth
            deconvolutionResults = {
                species: {},              
                fitQuality: {},
                derivatives: {},
                originalSpectrum: null,
                fittedTrace: null,
                individualTraces: []
                };
            
            // Clear plots
            if (document.getElementById('deconvolutionDerivativesPlot')) {
                Plotly.newPlot('deconvolutionDerivativesPlot', [], {});
            }
            if (document.getElementById('deconvolutionMainPlot')) {
                Plotly.newPlot('deconvolutionMainPlot', [], {});
            }
            
            // Reset displays
            const elR2 = document.getElementById('deconvR2Value');
            if (elR2) elR2.textContent = '--';
            const elDisc = document.getElementById('deconvDiscrepancy');
            if (elDisc) elDisc.textContent = '--';
            const elConv = document.getElementById('deconvConvergence');
            if (elConv) elConv.textContent = '--';
            document.getElementById('speciesQuantificationResults').innerHTML = '<p class="text-muted text-center">Select depth and run deconvolution</p>';
        }

        function extractSpectralRegion(spectrum, minFreq, maxFreq) {
            const frequencies = spectrum.frequency;
            const transmittances = spectrum.transmittance;
            
            const extracted = { frequency: [], transmittance: [] };
            
            for (let i = 0; i < frequencies.length; i++) {
                if (frequencies[i] >= minFreq && frequencies[i] <= maxFreq) {
                    extracted.frequency.push(frequencies[i]);
                    extracted.transmittance.push(transmittances[i]);
                }
            }
            
            return extracted;
        }

        function normalizeSpectrum(carbonylRegion, fullSpectrum, refBand) {
            // Find reference band intensity (according to Salvalaggio methodology)
            const refIntensity = findReferenceIntensity(fullSpectrum, refBand);
            
            const normalized = {
                frequency: [...carbonylRegion.frequency],
                transmittance: carbonylRegion.transmittance.map(t => t / refIntensity)
            };
            
            return normalized;
        }

        function findReferenceIntensity(spectrum, refBand) {
            const frequencies = spectrum.frequency;
            const transmittances = spectrum.transmittance;
            
            // Find closest frequency to reference band
            let closestIndex = 0;
            let minDiff = Math.abs(frequencies[0] - refBand);
            
            for (let i = 1; i < frequencies.length; i++) {
                const diff = Math.abs(frequencies[i] - refBand);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestIndex = i;
                }
            }
            
            return transmittances[closestIndex];
        }

        function calculateDerivatives(spectrum) {
            const freq = spectrum.frequency;
            const trans = spectrum.transmittance;
            
            // Calculate second derivative
            const secondDerivative = [];
            for (let i = 1; i < trans.length - 1; i++) {
                const d2 = trans[i-1] - 2*trans[i] + trans[i+1];
                secondDerivative.push(d2);
            }
            
            // Calculate fourth derivative
            const fourthDerivative = [];
            for (let i = 2; i < secondDerivative.length - 2; i++) {
                const d4 = secondDerivative[i-2] - 4*secondDerivative[i-1] + 6*secondDerivative[i] - 4*secondDerivative[i+1] + secondDerivative[i+2];
                fourthDerivative.push(d4);
            }
            
            return {
                frequency: freq.slice(3, -3), // Adjust for derivative calculation
                secondDerivative: secondDerivative.slice(1, -1),
                fourthDerivative: fourthDerivative
            };
        }

        function performBaselineCorrection(spectrum, baselineType) {
            // Simple baseline correction for deconvolution
            let corrected = { ...spectrum };
            
            switch (baselineType) {
                case 'linear':
                    corrected = linearBaselineCorrection(spectrum);
                    break;
                case 'polynomial':
                    corrected = automaticBaselineCorrection(spectrum);
                    break;
                case 'subtract_intact':
                    // This would require an intact sample - for now use automatic
                    corrected = automaticBaselineCorrection(spectrum);
                    break;
                default:
                    // Default to automatic baseline for deconvolution
                    corrected = automaticBaselineCorrection(spectrum);
                    break;
            }
            
            return corrected;
        }
        
        function automaticBaselineCorrection(spectrum) {
            // Simple straight line baseline using minima from carbonyl region (1650-1800 cm⁻¹)
            const { frequency, transmittance } = spectrum;
            
            // Use original data if available
            const sourceData = spectrum.originalTransmittance || transmittance;
            
            // Store original spectrum for visualization
            deconvolutionResults.originalSpectrum = {
                frequency: [...frequency],
                transmittance: [...sourceData]
            };
            
            // Find carbonyl region indices (1650-1800 cm⁻¹)
            const carbonylIndices = [];
            for (let i = 0; i < frequency.length; i++) {
                if (frequency[i] >= 1650 && frequency[i] <= 1800) {
                    carbonylIndices.push(i);
                }
            }
            
            if (carbonylIndices.length < 2) {
                console.warn('Insufficient data in carbonyl region for baseline correction');
                return spectrum;
            }
            
            // Find minimum values at the edges of carbonyl region
            const startIndex = carbonylIndices[0];
            const endIndex = carbonylIndices[carbonylIndices.length - 1];
            
            // Look for minima in edge regions (first and last 20% of the region)
            const edgeSize = Math.max(5, Math.floor(carbonylIndices.length * 0.2));
            
            // Find minimum in start region
            let startMin = sourceData[startIndex];
            let startMinFreq = frequency[startIndex];
            for (let i = 0; i < edgeSize && i < carbonylIndices.length; i++) {
                const idx = carbonylIndices[i];
                if (sourceData[idx] < startMin) {
                    startMin = sourceData[idx];
                    startMinFreq = frequency[idx];
                }
            }
            
            // Find minimum in end region
            let endMin = sourceData[endIndex];
            let endMinFreq = frequency[endIndex];
            for (let i = Math.max(0, carbonylIndices.length - edgeSize); i < carbonylIndices.length; i++) {
                const idx = carbonylIndices[i];
                if (sourceData[idx] < endMin) {
                    endMin = sourceData[idx];
                    endMinFreq = frequency[idx];
                }
            }
            
            // Calculate linear baseline between minima
            const slope = (endMin - startMin) / (endMinFreq - startMinFreq);
            const intercept = startMin - slope * startMinFreq;
            
            // Create corrected spectrum
            const correctedTransmittance = [...sourceData];
            const baselineValues = [];
            
            // Apply correction only to carbonyl region
            for (const idx of carbonylIndices) {
                const baselineValue = slope * frequency[idx] + intercept;
                correctedTransmittance[idx] = sourceData[idx] - baselineValue;
                baselineValues.push(baselineValue);
            }
            
            // Store baseline for visualization
            deconvolutionResults.baseline = {
                frequency: carbonylIndices.map(i => frequency[i]),
                values: baselineValues
            };
            
            // Create corrected spectrum data
            const correctedSpectrum = {
                ...spectrum,
                transmittance: correctedTransmittance,
                originalTransmittance: spectrum.originalTransmittance || [...transmittance]
            };
            
            // Store corrected spectrum for visualization
            deconvolutionResults.correctedSpectrum = {
                frequency: [...frequency],
                transmittance: [...correctedTransmittance]
            };
            
            console.log(`Applied linear baseline correction to carbonyl region (${startMinFreq.toFixed(1)}-${endMinFreq.toFixed(1)} cm⁻¹)`);
            console.log(`Baseline: y = ${slope.toFixed(6)}x + ${intercept.toFixed(6)}`);
            
            return correctedSpectrum;
        }
        


        function linearBaselineCorrection(spectrum) {
            const freq = spectrum.frequency;
            const trans = spectrum.transmittance;
            
            // Simple linear baseline from endpoints
            const startY = trans[0];
            const endY = trans[trans.length - 1];
            const slope = (endY - startY) / (freq[freq.length - 1] - freq[0]);
            
            const corrected = {
                frequency: [...freq],
                transmittance: trans.map((t, i) => {
                    const baselineY = startY + slope * (freq[i] - freq[0]);
                    return t - baselineY;
                })
            };
            
            return corrected;
        }

        function polynomialBaselineCorrection(spectrum) {
            // Use the same simple baseline correction for polynomial option
            return automaticBaselineCorrection(spectrum);
        }



        

        async function performCurveFitting(spectrum, derivatives) {
        const speciesIds = Object.keys(CARBONYL_SPECIES);
        let params = speciesIds.map(id => ({
            speciesId: id,
            intensity: CARBONYL_SPECIES[id].initialIntensity || 1,
            width: CARBONYL_SPECIES[id].bandWidth,
            frequency: CARBONYL_SPECIES[id].freq,
            lorentzianFraction: CARBONYL_SPECIES[id].lorentzianContrib || 0.9
        }));

        // Adam optimizer state - mejora significativa sobre gradiente simple
        const adam = {
            m_intensity: params.map(() => 0),
            v_intensity: params.map(() => 0),
            m_width: params.map(() => 0),
            v_width: params.map(() => 0),
            m_lorentz: params.map(() => 0),
            v_lorentz: params.map(() => 0),
            m_freq: params.map(() => 0),
            v_freq: params.map(() => 0),
            beta1: 0.9,
            beta2: 0.999,
            epsilon: 1e-8,
            learningRate: 0.05
        };

        let best = {
            params: JSON.parse(JSON.stringify(params)),
            fitQuality: { r2: -Infinity, areaError: Infinity }
        };

        const maxIter = 500; // Aumentado de 200 a 500 para mayor precisión
        const areaOrig = calculateAreaSimpsonRule(spectrum.frequency, spectrum.transmittance);
        const delta = 0.005; // Reducido de 0.01 a 0.005 para gradientes más precisos
        
        // Cache para evitar cálculos repetidos
        const absTransmittance = spectrum.transmittance.map(Math.abs);
        const freqLength = spectrum.frequency.length;
        
        let prevR2 = -Infinity;
        let noImprovementCount = 0;

        for (let iter = 0; iter < maxIter; iter++) {
            // 1. Calcular contribuciones individuales una sola vez (optimización)
            const individualContributions = params.map(p => 
                spectrum.frequency.map(f => 
                    calculateMixedGaussianLorentzianValue(
                        f, p.frequency, p.intensity, p.width, p.lorentzianFraction
                    )
                )
            );
            
            // 2. Sumar contribuciones para obtener espectro fitted
            const fittedY = new Array(freqLength);
            for (let i = 0; i < freqLength; i++) {
                fittedY[i] = individualContributions.reduce((sum, contrib) => sum + contrib[i], 0);
            }

            // 3. Calcular métricas
            const areaFit = calculateAreaSimpsonRule(spectrum.frequency, fittedY);
            const areaError = Math.abs(areaOrig - areaFit);
            const r2 = calculateR2(
                { frequency: spectrum.frequency, transmittance: spectrum.transmittance },
                { frequency: spectrum.frequency, transmittance: fittedY }
            );

            // Log con información de Lorentziana cada 50 iteraciones
            if (iter % 50 === 0 || iter < 5) {
                const lorentzValues = params.map(p => `${CARBONYL_SPECIES[p.speciesId].name.substring(0,10)}: ${(p.lorentzianFraction*100).toFixed(1)}%`).join(', ');
                console.log(`Iteration ${iter}: R² = ${r2.toFixed(4)}, Area Error = ${areaError.toFixed(6)}, Lorentz: [${lorentzValues}]`);
            }

            // 4. Guardar mejor resultado
            if (r2 > best.fitQuality.r2 || (r2 === best.fitQuality.r2 && areaError < best.fitQuality.areaError)) {
                best = {
                    params: JSON.parse(JSON.stringify(params)),
                    fitQuality: { r2, areaError }
                };
                noImprovementCount = 0;
            } else {
                noImprovementCount++;
            }

            // 5. Criterio de convergencia mejorado - más estricto para mayor precisión
            const relativeImprovement = Math.abs(r2 - prevR2) / Math.max(Math.abs(prevR2), 1e-10);
            if ((areaError < 5e-7 || r2 > 0.9995) && relativeImprovement < 1e-6) {
                console.log(`Convergencia de alta precisión alcanzada en iteración ${iter}`);
                break;
            }
            
            // Early stopping si no hay mejora en 50 iteraciones (aumentado para permitir más exploración)
            if (noImprovementCount > 50) {
                console.log(`Parada temprana: sin mejora en ${noImprovementCount} iteraciones`);
                break;
            }
            
            prevR2 = r2;

            // 6. Ajuste con Adam optimizer (mucho más eficiente)
            params.forEach((p, idx) => {
                // Gradiente para intensidad usando contribuciones ya calculadas
                let gradI = 0;
                for (let i = 0; i < freqLength; i++) {
                    const error = fittedY[i] - absTransmittance[i];
                    // Derivada aproximada usando la contribución existente
                    const dContrib_dI = individualContributions[idx][i] / Math.max(p.intensity, 0.01);
                    gradI += 2 * error * dContrib_dI;
                }
                gradI /= freqLength;
                
                // Adam update para intensidad
                adam.m_intensity[idx] = adam.beta1 * adam.m_intensity[idx] + (1 - adam.beta1) * gradI;
                adam.v_intensity[idx] = adam.beta2 * adam.v_intensity[idx] + (1 - adam.beta2) * gradI * gradI;
                const m_hat_i = adam.m_intensity[idx] / (1 - Math.pow(adam.beta1, iter + 1));
                const v_hat_i = adam.v_intensity[idx] / (1 - Math.pow(adam.beta2, iter + 1));
                const newIntensity = p.intensity - adam.learningRate * m_hat_i / (Math.sqrt(v_hat_i) + adam.epsilon);
                p.intensity = Math.max(0.001, newIntensity); // Límite mínimo reducido para mayor rango
                
                // Gradiente para anchura
                const origW = p.width;
                p.width = origW + delta;
                const contributionPlusW = spectrum.frequency.map(f => 
                    calculateMixedGaussianLorentzianValue(
                        f, p.frequency, p.intensity, p.width, p.lorentzianFraction
                    )
                );
                p.width = origW;
                
                let gradW = 0;
                for (let i = 0; i < freqLength; i++) {
                    const error = fittedY[i] - absTransmittance[i];
                    const derivative = (contributionPlusW[i] - individualContributions[idx][i]) / delta;
                    gradW += 2 * error * derivative;
                }
                gradW /= freqLength;
                
                // Adam update para anchura
                adam.m_width[idx] = adam.beta1 * adam.m_width[idx] + (1 - adam.beta1) * gradW;
                adam.v_width[idx] = adam.beta2 * adam.v_width[idx] + (1 - adam.beta2) * gradW * gradW;
                const m_hat_w = adam.m_width[idx] / (1 - Math.pow(adam.beta1, iter + 1));
                const v_hat_w = adam.v_width[idx] / (1 - Math.pow(adam.beta2, iter + 1));
                const newWidth = origW - adam.learningRate * m_hat_w / (Math.sqrt(v_hat_w) + adam.epsilon);
                // Límites más amplios: mín 0.5 cm⁻¹, máx 50 cm⁻¹ para mayor flexibilidad
                p.width = Math.max(0.5, Math.min(50, newWidth));
                
                // Gradiente para fracción Lorentziana (rangos específicos por especie)
                const origL = p.lorentzianFraction;
                
                // Calcular contribución con Lorentziana incrementada
                p.lorentzianFraction = Math.min(origL + delta, 1.0);
                const contributionPlusL = spectrum.frequency.map(f => 
                    calculateMixedGaussianLorentzianValue(
                        f, p.frequency, p.intensity, p.width, p.lorentzianFraction
                    )
                );
                p.lorentzianFraction = origL;
                
                let gradL = 0;
                for (let i = 0; i < freqLength; i++) {
                    const error = fittedY[i] - absTransmittance[i];
                    const derivative = (contributionPlusL[i] - individualContributions[idx][i]) / delta;
                    gradL += 2 * error * derivative;
                }
                gradL /= freqLength;
                
                // Adam update para fracción Lorentziana
                adam.m_lorentz[idx] = adam.beta1 * adam.m_lorentz[idx] + (1 - adam.beta1) * gradL;
                adam.v_lorentz[idx] = adam.beta2 * adam.v_lorentz[idx] + (1 - adam.beta2) * gradL * gradL;
                const m_hat_l = adam.m_lorentz[idx] / (1 - Math.pow(adam.beta1, iter + 1));
                const v_hat_l = adam.v_lorentz[idx] / (1 - Math.pow(adam.beta2, iter + 1));
                const newLorentz = origL - adam.learningRate * m_hat_l / (Math.sqrt(v_hat_l) + adam.epsilon);
                
                // Restricción: rangos específicos para cada especie
                const minLorentz = CARBONYL_SPECIES[p.speciesId].lorentzianMin || 0.85;
                const maxLorentz = CARBONYL_SPECIES[p.speciesId].lorentzianMax || 0.95;
                p.lorentzianFraction = Math.max(minLorentz, Math.min(maxLorentz, newLorentz));
                
                // Gradiente para frecuencia del pico (±2 cm⁻¹)
                const origFreq = p.frequency;
                const initialFreq = CARBONYL_SPECIES[p.speciesId].freq;
                
                // Calcular contribución con frecuencia incrementada
                p.frequency = origFreq + delta;
                const contributionPlusFreq = spectrum.frequency.map(f => 
                    calculateMixedGaussianLorentzianValue(
                        f, p.frequency, p.intensity, p.width, p.lorentzianFraction
                    )
                );
                p.frequency = origFreq;
                
                let gradFreq = 0;
                for (let i = 0; i < freqLength; i++) {
                    const error = fittedY[i] - absTransmittance[i];
                    const derivative = (contributionPlusFreq[i] - individualContributions[idx][i]) / delta;
                    gradFreq += 2 * error * derivative;
                }
                gradFreq /= freqLength;
                
                // Adam update para frecuencia
                adam.m_freq[idx] = adam.beta1 * adam.m_freq[idx] + (1 - adam.beta1) * gradFreq;
                adam.v_freq[idx] = adam.beta2 * adam.v_freq[idx] + (1 - adam.beta2) * gradFreq * gradFreq;
                const m_hat_freq = adam.m_freq[idx] / (1 - Math.pow(adam.beta1, iter + 1));
                const v_hat_freq = adam.v_freq[idx] / (1 - Math.pow(adam.beta2, iter + 1));
                const newFreq = origFreq - adam.learningRate * m_hat_freq / (Math.sqrt(v_hat_freq) + adam.epsilon);
                
                // Restricción: ±2 cm⁻¹ del valor inicial
                const minFreq = initialFreq - 2;
                const maxFreq = initialFreq + 2;
                p.frequency = Math.max(minFreq, Math.min(maxFreq, newFreq));
            });
        }

        // Construir resultado
        const speciesOptimized = {};
        best.params.forEach(p => {
            speciesOptimized[p.speciesId] = {
                ...CARBONYL_SPECIES[p.speciesId],
                intensity: p.intensity,
                width: p.width,
                frequency: p.frequency,
                lorentzianContrib: p.lorentzianFraction
            };
        });

        // Log final con todos los parámetros optimizados
        console.log(`Optimización completada con R² = ${best.fitQuality.r2.toFixed(4)}`);
        console.log('=== PARÁMETROS LORENTZIANOS OPTIMIZADOS ===');
        best.params.forEach(p => {
            const initial = CARBONYL_SPECIES[p.speciesId].lorentzianContrib || 0.9;
            const change = ((p.lorentzianFraction - initial) / initial * 100);
            console.log(`${CARBONYL_SPECIES[p.speciesId].name}: ${(initial*100).toFixed(1)}% → ${(p.lorentzianFraction*100).toFixed(1)}% (${change >= 0 ? '+' : ''}${change.toFixed(2)}%)`);
        });
        
        // Guardar parámetros optimizados globalmente para visualización
        window.optimizedParams = {};
        best.params.forEach(p => {
            window.optimizedParams[p.speciesId] = {
                intensity: p.intensity,
                width: p.width,
                frequency: p.frequency,
                lorentzianContrib: p.lorentzianFraction
            };
        });
        
        return { species: speciesOptimized, fitQuality: best.fitQuality };
    }


        
        function decomposeOverlappingPeaks(carbonylRegion) {
            // Advanced peak decomposition using least squares optimization
            const freq = carbonylRegion.frequency;
            const trans = carbonylRegion.transmittance;
            
            if (freq.length === 0) {
                return {
                    'ketones': 0.001,
                    'carboxylic_acids': 0.001,
                    'esters_aldehydes': 0.001
                };
            }
            
            // Initial guess for intensities based on local maxima
            const initialGuess = getInitialIntensityGuess(freq, trans);
            
            // Optimize intensities using iterative fitting
            const optimizedIntensities = optimizeIntensities(freq, trans, initialGuess);
            
            console.log('Peak decomposition results:', optimizedIntensities);
            
            return optimizedIntensities;
        }
        
        function getInitialIntensityGuess(freq, trans) {
            // Get initial estimates for each species based on local spectrum values
            const intensities = {};
            
            for (const [speciesId, speciesData] of Object.entries(CARBONYL_SPECIES)) {
                const targetFreq = speciesData.freq;
                
                // Find closest frequency index
                let closestIndex = 0;
                let minDistance = Math.abs(freq[0] - targetFreq);
                
                for (let i = 1; i < freq.length; i++) {
                    const distance = Math.abs(freq[i] - targetFreq);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestIndex = i;
                    }
                }
                
                // Use local maximum in a small window around the expected position
                let localMax = Math.abs(trans[closestIndex]);
                const windowSize = 3;
                
                for (let i = Math.max(0, closestIndex - windowSize); 
                     i <= Math.min(freq.length - 1, closestIndex + windowSize); i++) {
                    const localIntensity = Math.abs(trans[i]);
                    if (localIntensity > localMax) {
                        localMax = localIntensity;
                    }
                }
                
                intensities[speciesId] = Math.max(localMax, 0.001);
            }
            
            return intensities;
        }
        
        function optimizeIntensities(freq, trans, initialGuess) {
            // Advanced iterative optimization with multiple parameters
            let currentParams = initializeOptimizationParameters(initialGuess);
            let bestParams = JSON.parse(JSON.stringify(currentParams));
            let bestError = Infinity;
            
            const maxIterations = 50;
            let learningRate = 0.05;
            const minLearningRate = 0.001;
            const learningRateDecay = 0.95;
            
            console.log('Starting multi-parameter optimization...');
            
            for (let iteration = 0; iteration < maxIterations; iteration++) {
                // Calculate current fitted spectrum with all parameters
                const fittedValues = calculateAdvancedFittedSpectrum(freq, currentParams);
                
                // Calculate error
                const error = calculateMeanSquaredError(trans, fittedValues);
                
                // Update UI progress
                updateOptimizationProgress(iteration, maxIterations, error);
                
                if (error < bestError) {
                    bestError = error;
                    bestParams = JSON.parse(JSON.stringify(currentParams));
                    console.log(`Iteration ${iteration}: New best error = ${bestError.toFixed(6)}`);
                }
                
                // Calculate gradients for all parameters
                const gradients = calculateAdvancedGradients(freq, trans, fittedValues, currentParams);
                
                // Update parameters using adaptive gradient descent
                updateParameters(currentParams, gradients, learningRate);
                
                // Decay learning rate
                learningRate = Math.max(learningRate * learningRateDecay, minLearningRate);
                
                // Early stopping if error is small enough or improvement is minimal
                if (error < 0.0001 || (iteration > 10 && (bestError - error) < 0.000001)) {
                    console.log(`Early stopping at iteration ${iteration}`);
                    break;
                }
            }
            
            console.log(`Optimization completed. Final error: ${bestError.toFixed(6)}`);
            logOptimizationResults(bestParams);
            
            // Store best error for UI updates
            window.lastOptimizationError = bestError;
            
            return extractIntensitiesFromParams(bestParams);
        }
        
        function initializeOptimizationParameters(initialGuess) {
            // Initialize all optimizable parameters
            const params = {};
            
            for (const [speciesId, intensity] of Object.entries(initialGuess)) {
                const speciesData = CARBONYL_SPECIES[speciesId];
                params[speciesId] = {
                    intensity: intensity,
                    width: speciesData.bandWidth, // Allow slight variation in bandwidth
                    lorentzianContrib: speciesData.lorentzianContrib, // Allow variation in peak shape
                    frequency: speciesData.freq // Keep frequency close to literature value
                };
            }
            
            return params;
        }
        
        function calculateAdvancedFittedSpectrum(freq, params) {
            // Calculate fitted spectrum using optimized parameters
            const fittedValues = new Array(freq.length).fill(0);
            
            for (const [speciesId, speciesParams] of Object.entries(params)) {
                for (let i = 0; i < freq.length; i++) {
                    const contribution = calculateMixedGaussianLorentzianValue(
                        freq[i],
                        speciesParams.frequency,
                        speciesParams.intensity,
                        speciesParams.width,
                        speciesParams.lorentzianContrib
                    );
                    fittedValues[i] += contribution;
                }
            }
            
            return fittedValues;
        }
        
        function calculateAdvancedGradients(freq, originalTrans, fittedValues, params) {
            // Calculate gradients for all parameters
            const gradients = {};
            
            for (const [speciesId, speciesParams] of Object.entries(params)) {
                gradients[speciesId] = {
                    intensity: 0,
                    width: 0,
                    lorentzianContrib: 0,
                    frequency: 0
                };
                
                for (let i = 0; i < freq.length; i++) {
                    const originalValue = Math.abs(originalTrans[i]);
                    const fittedValue = fittedValues[i];
                    const error = fittedValue - originalValue;
                    
                    // Gradient with respect to intensity
                    const intensityDerivative = calculateMixedGaussianLorentzianValue(
                        freq[i], speciesParams.frequency, 1.0, 
                        speciesParams.width, speciesParams.lorentzianContrib
                    );
                    gradients[speciesId].intensity += 2 * error * intensityDerivative;
                    
                    // Gradient with respect to width (numerical approximation)
                    const widthDelta = 0.1;
                    const valueWidthPlus = calculateMixedGaussianLorentzianValue(
                        freq[i], speciesParams.frequency, speciesParams.intensity,
                        speciesParams.width + widthDelta, speciesParams.lorentzianContrib
                    );
                    const valueWidthMinus = calculateMixedGaussianLorentzianValue(
                        freq[i], speciesParams.frequency, speciesParams.intensity,
                        speciesParams.width - widthDelta, speciesParams.lorentzianContrib
                    );
                    const widthDerivative = (valueWidthPlus - valueWidthMinus) / (2 * widthDelta);
                    gradients[speciesId].width += 2 * error * widthDerivative;
                    
                    // Gradient with respect to Lorentzian contribution
                    const lorentzDelta = 0.01;
                    const valueLorentzPlus = calculateMixedGaussianLorentzianValue(
                        freq[i], speciesParams.frequency, speciesParams.intensity,
                        speciesParams.width, Math.min(speciesParams.lorentzianContrib + lorentzDelta, 1.0)
                    );
                    const valueLorentzMinus = calculateMixedGaussianLorentzianValue(
                        freq[i], speciesParams.frequency, speciesParams.intensity,
                        speciesParams.width, Math.max(speciesParams.lorentzianContrib - lorentzDelta, 0.0)
                    );
                    const lorentzDerivative = (valueLorentzPlus - valueLorentzMinus) / (2 * lorentzDelta);
                    gradients[speciesId].lorentzianContrib += 2 * error * lorentzDerivative;

                    gradients[speciesId].frequency = 0;
                    
                }
                
                // Normalize gradients
                const numPoints = freq.length;
                gradients[speciesId].intensity /= numPoints;
                gradients[speciesId].width /= numPoints;
                gradients[speciesId].lorentzianContrib /= numPoints;
                gradients[speciesId].frequency /= numPoints;
            }
            
            return gradients;
        }
        
        function updateParameters(params, gradients, learningRate) {
            // Update all parameters with constraints
            for (const [speciesId, gradient] of Object.entries(gradients)) {
                const speciesData = CARBONYL_SPECIES[speciesId];
                const currentParams = params[speciesId];
                
                // Update intensity (always positive)
                currentParams.intensity = Math.max(
                    currentParams.intensity - learningRate * gradient.intensity,
                    0.001
                );
                
                // Update width (constrained around literature value ±30%)
                const minWidth = speciesData.bandWidth * 0.7;
                const maxWidth = speciesData.bandWidth * 1.3;
                currentParams.width = Math.max(minWidth, Math.min(maxWidth,
                    currentParams.width - learningRate * 0.5 * gradient.width
                ));
                
                // Update Lorentzian contribution with REDUCED MARGIN (±5% from initial value)
                // This provides fine-tuning while keeping the profile shape consistent
                const initialLorentz = speciesData.lorentzianContrib;
                const minLorentz = Math.max(0.1, initialLorentz * 0.95); // -5%
                const maxLorentz = Math.min(1.0, initialLorentz * 1.05); // +5%
                
                // Use higher learning rate (0.3) for better optimization of this parameter
                const newLorentz = currentParams.lorentzianContrib - learningRate * 0.3 * gradient.lorentzianContrib;
                currentParams.lorentzianContrib = Math.max(minLorentz, Math.min(maxLorentz, newLorentz));
                
                currentParams.frequency = speciesData.freq;
            }
        }
        
        function logOptimizationResults(bestParams) {
            console.log('Optimization results:');
            for (const [speciesId, params] of Object.entries(bestParams)) {
                const original = CARBONYL_SPECIES[speciesId];
                console.log(`${speciesId}:`);
                console.log(`  Intensity: ${params.intensity.toFixed(4)}`);
                console.log(`  Width: ${params.width.toFixed(2)} cm⁻¹ (original: ${original.bandWidth})`);
                console.log(`  Frequency: ${params.frequency.toFixed(1)} cm⁻¹ (original: ${original.freq})`);
                console.log(`  Lorentzian: ${(params.lorentzianContrib*100).toFixed(1)}% (original: ${(original.lorentzianContrib*100).toFixed(1)}%)`);
            }
            
            // Update UI with optimized parameters
            updateOptimizedParametersDisplay(bestParams);
        }
        
        function updateOptimizedParametersDisplay(optimizedParams) {
            const displayElement = document.getElementById('optimizedParametersDisplay');
            if (!displayElement) return;
            
            let html = '';
            
            for (const [speciesId, params] of Object.entries(optimizedParams)) {
                const original = CARBONYL_SPECIES[speciesId];
                const speciesName = original.name;
                
                // Calculate changes from original
                const freqChange = params.frequency - original.freq;
                const widthChange = params.width - original.bandWidth;
                const lorentzChange = (params.lorentzianContrib - original.lorentzianContrib) * 100;
                
                html += `
                    <div class="mb-3 p-2" style="border-left: 3px solid ${original.color}; background-color: rgba(248,249,250,0.5);">
                        <h6 class="mb-2" style="color: ${original.color};">${speciesName}</h6>
                        <div class="row text-sm">
                            <div class="col-6">
                                <strong>Frequency:</strong><br>
                                ${params.frequency.toFixed(1)} cm⁻¹
                                <span class="text-muted">(${freqChange >= 0 ? '+' : ''}${freqChange.toFixed(1)} cm⁻¹)</span>
                            </div>
                            <div class="col-6">
                                <strong>Width:</strong><br>
                                ${params.width.toFixed(1)} cm⁻¹
                                <span class="text-muted">(${widthChange >= 0 ? '+' : ''}${widthChange.toFixed(1)} cm⁻¹)</span>
                            </div>
                        </div>
                        <div class="row text-sm mt-1">
                            <div class="col-6">
                                <strong>Intensity:</strong><br>
                                ${params.intensity.toFixed(4)}
                            </div>
                            <div class="col-6">
                                <strong>Lorentzian:</strong><br>
                                ${(params.lorentzianContrib*100).toFixed(1)}%
                                <span class="text-muted">(${lorentzChange >= 0 ? '+' : ''}${lorentzChange.toFixed(1)}%)</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            displayElement.innerHTML = html;
        }
        
        function updateOptimizationProgress(iteration, maxIterations, error) {
            // Update progress display during optimization
            const progressElement = document.getElementById('optimizationProgress');
            const resultsElement = document.getElementById('optimizationResults');
            const iterationElement = document.getElementById('currentIteration');
            const errorElement = document.getElementById('currentError');
            const progressBar = document.getElementById('optimizationProgressBar');
            
            if (progressElement && iteration !== undefined) {
                progressElement.style.display = 'block';
                resultsElement.style.display = 'none';
                
                if (iterationElement) iterationElement.textContent = `${iteration}/${maxIterations}`;
                if (errorElement) errorElement.textContent = error.toExponential(3);
                if (progressBar) {
                    const percentage = (iteration / maxIterations) * 100;
                    progressBar.style.width = `${percentage}%`;
                }
            }
        }
        
        function updateOptimizationComplete(finalError, r2Value) {
            // Update display when optimization is complete
            const progressElement = document.getElementById('optimizationProgress');
            const resultsElement = document.getElementById('optimizationResults');
            const finalErrorElement = document.getElementById('finalError');
            const r2Element = document.getElementById('deconvR2Value');
            const statusElement = document.getElementById('optimizationStatus');
            
            if (resultsElement) {
                if (progressElement) progressElement.style.display = 'none';
                resultsElement.style.display = 'block';
                
                if (finalErrorElement && finalError !== undefined) {
                    finalErrorElement.textContent = finalError.toExponential(3);
                }
                if (r2Element && r2Value !== undefined) {
                    r2Element.textContent = r2Value.toFixed(4);
                }
                if (statusElement && r2Value !== undefined) {
                    const status = r2Value > 0.95 ? 'Excellent' : r2Value > 0.90 ? 'Good' : 'Needs improvement';
                    statusElement.textContent = status;
                    statusElement.className = 'float-end ' + (r2Value > 0.95 ? 'badge bg-success' : 
                                           r2Value > 0.90 ? 'badge bg-warning' : 'badge bg-danger');
                }
            }
        }
        
        function extractIntensitiesFromParams(params) {
            // Extract just intensities for compatibility with existing code
            const intensities = {};
            for (const [speciesId, speciesParams] of Object.entries(params)) {
                intensities[speciesId] = speciesParams.intensity;
            }
            
            // Store optimized parameters globally for use in visualization
            window.optimizedParams = params;
            
            return intensities;
        }
        
        function calculateFittedCarbonylSpectrum(freq, intensities) {
            // Calculate fitted spectrum using current intensities
            const fittedValues = new Array(freq.length).fill(0);
            
            for (const [speciesId, intensity] of Object.entries(intensities)) {
                const speciesData = CARBONYL_SPECIES[speciesId];
                if (!speciesData) continue;
                
                for (let i = 0; i < freq.length; i++) {
                    const contribution = calculateMixedGaussianLorentzianValue(
                        freq[i],
                        speciesData.freq,
                        intensity,
                        speciesData.bandWidth,
                        speciesData.lorentzianContrib
                    );
                    fittedValues[i] += contribution;
                }
            }
            
            return fittedValues;
        }
        
        function calculateMeanSquaredError(original, fitted) {
            // Calculate mean squared error between original and fitted spectra
            if (original.length !== fitted.length) {
                return Infinity;
            }
            
            let sumSquaredError = 0;
            for (let i = 0; i < original.length; i++) {
                const diff = Math.abs(original[i]) - fitted[i];
                sumSquaredError += diff * diff;
            }
            
            return sumSquaredError / original.length;
        }
        
        function calculateGradients(freq, originalTrans, fittedValues, intensities) {
            // Calculate gradients for each species intensity
            const gradients = {};
            
            for (const [speciesId, currentIntensity] of Object.entries(intensities)) {
                const speciesData = CARBONYL_SPECIES[speciesId];
                if (!speciesData) continue;
                
                let gradient = 0;
                
                for (let i = 0; i < freq.length; i++) {
                    const originalValue = Math.abs(originalTrans[i]);
                    const fittedValue = fittedValues[i];
                    const error = fittedValue - originalValue;
                    
                    // Derivative of mixed Gaussian-Lorentzian with respect to intensity
                    const derivative = calculateMixedGaussianLorentzianValue(
                        freq[i],
                        speciesData.freq,
                        1.0, // Unit intensity to get pure shape
                        speciesData.bandWidth,
                        speciesData.lorentzianContrib
                    );
                    
                    gradient += 2 * error * derivative;
                }
                
                gradients[speciesId] = gradient / freq.length;
            }
            
            return gradients;
        }

        function detectPeaksFromDerivatives(derivatives) {
            const peaks = [];
            const secondDeriv = derivatives.secondDerivative;
            const fourthDeriv = derivatives.fourthDerivative;
            const freq = derivatives.frequency;
            
            // Enhanced peak detection specifically for carbonyl region
            for (let i = 2; i < secondDeriv.length - 2; i++) {
                // Look for negative values in second derivative (peaks in original spectrum)
                if (secondDeriv[i] < -0.0001) {
                    // Check if it's a local minimum in second derivative
                    const isLocalMin = secondDeriv[i] < secondDeriv[i-1] && 
                                      secondDeriv[i] < secondDeriv[i+1] &&
                                      secondDeriv[i] < secondDeriv[i-2] && 
                                      secondDeriv[i] < secondDeriv[i+2];
                    
                    if (isLocalMin) {
                        // Check if frequency is in carbonyl region (1650-1800)
                        if (freq[i] >= 1650 && freq[i] <= 1800) {
                            peaks.push({
                                frequency: freq[i],
                                intensity: Math.abs(secondDeriv[i]),
                                index: i
                            });
                        }
                    }
                }
            }
            
            // Also look for peaks specifically around expected frequencies
            const expectedFreqs = [1698, 1707, 1714, 1721, 1737, 1767]; // All 6 carbonyl species
            
            for (const expectedFreq of expectedFreqs) {
                // Find indices near expected frequency
                const nearIndices = [];
                for (let i = 0; i < freq.length; i++) {
                    if (Math.abs(freq[i] - expectedFreq) < 15) {
                        nearIndices.push(i);
                    }
                }
                
                if (nearIndices.length > 0) {
                    // Find the most negative second derivative in this region
                    let bestIndex = nearIndices[0];
                    let bestValue = secondDeriv[nearIndices[0]];
                    
                    for (const idx of nearIndices) {
                        if (secondDeriv[idx] < bestValue) {
                            bestValue = secondDeriv[idx];
                            bestIndex = idx;
                        }
                    }
                    
                    // Add if not already present
                    const exists = peaks.some(p => Math.abs(p.frequency - freq[bestIndex]) < 5);
                    if (!exists && bestValue < -0.00001) {
                        peaks.push({
                            frequency: freq[bestIndex],
                            intensity: Math.abs(bestValue),
                            index: bestIndex
                        });
                    }
                }
            }
            
            console.log('Detected peaks:', peaks.map(p => `${p.frequency.toFixed(1)} cm⁻¹`));
            return peaks.sort((a, b) => b.intensity - a.intensity);
        }

        function calculateGaussianArea(peak, bandWidth) {
            // Simplified area calculation for Gaussian peak
            return peak.intensity * bandWidth * Math.sqrt(2 * Math.PI);
        }
        
        function calculateMixedArea(peak, bandWidth, lorentzianFraction) {
            // Calculate area for mixed Gaussian-Lorentzian peak
            const gaussianArea = peak.intensity * bandWidth * Math.sqrt(2 * Math.PI);
            const lorentzianArea = peak.intensity * bandWidth * Math.PI;
            
            return (1 - lorentzianFraction) * gaussianArea + lorentzianFraction * lorentzianArea;
        }

        function generateFittedSpectrumFromTraces() {
            const freq = deconvolutionResults.originalSpectrum.frequency;
            const traces = deconvolutionResults.individualTraces || [];
            const fittedY = freq.map((_, idx) =>
                traces.reduce((sum, tr) => sum + tr.y[idx], 0)
            );
            return {
                frequency: freq,
                transmittance: fittedY
            };
        }



        function calculateGaussianValue(x, center, intensity, width) {
            const sigma = width / 2.35; // Convert FWHM to sigma
            const exponent = -0.5 * Math.pow((x - center) / sigma, 2);
            return intensity * Math.exp(exponent);
        }
        
        function calculateLorentzianValue(x, center, intensity, width) {
            const gamma = width / 2; // Half-width at half-maximum
            const denominator = 1 + Math.pow((x - center) / gamma, 2);
            return intensity / denominator;
        }
        
        function calculateMixedGaussianLorentzianValue(x, center, intensity, width, lorentzFraction) {
            const gauss = calculateGaussianValue(x, center, intensity, width);
            const lorentz = calculateLorentzianValue(x, center, intensity, width);
            const result = (1 - lorentzFraction) * gauss + lorentzFraction * lorentz;
            return Math.max(0, result); // Nunca negativo
        }



        function calculateR2(original, fitted) {
            const originalTrans = original.transmittance;
            const fittedTrans = fitted.transmittance;
            
            const meanOriginal = originalTrans.reduce((sum, val) => sum + val, 0) / originalTrans.length;
            
            let ssRes = 0;
            let ssTot = 0;
            
            for (let i = 0; i < originalTrans.length; i++) {
                ssRes += Math.pow(originalTrans[i] - fittedTrans[i], 2);
                ssTot += Math.pow(originalTrans[i] - meanOriginal, 2);
            }
            
            return 1 - (ssRes / ssTot);
        }

        function calculateMaxDiscrepancy(original, fitted) {
            const originalTrans = original.transmittance;
            const fittedTrans = fitted.transmittance;
            
            let maxDiscrepancy = 0;
            
            for (let i = 0; i < originalTrans.length; i++) {
                const discrepancy = Math.abs(originalTrans[i] - fittedTrans[i]);
                if (discrepancy > maxDiscrepancy) {
                    maxDiscrepancy = discrepancy;
                }
            }
            
            return maxDiscrepancy;
        }

        function updateDeconvolutionPlots() {
            updateDerivativesPlot();
            updateMainDeconvolutionPlot();
        }

        function updateDerivativesPlot() {
        const derivatives = deconvolutionResults.derivatives;
        
        if (!derivatives || !derivatives.frequency) {
            console.warn("No hay datos de derivadas para graficar");
            return;
        }
        
        const traces = [
            {
                x: derivatives.frequency,
                y: derivatives.secondDerivative,
                name: 'Second Derivative (y″)',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#2c3e50', width: 2 }
            },
            {
                x: derivatives.frequency,
                y: derivatives.fourthDerivative,
                name: 'Fourth Derivative (y⁴)',
                type: 'scatter',
                mode: 'lines',
                line: { color: '#e74c3c', width: 2 }
            }
        ];
        
        const layout = {
            title: 'Derivative Analysis for Peak Detection',
            xaxis: { 
                title: 'Wavenumber (cm⁻¹)', 
                autorange: 'reversed' 
            },
            yaxis: { 
                title: 'Derivative Intensity' 
            },
            showlegend: true,
            margin: { l: 60, r: 20, t: 40, b: 60 },
            plot_bgcolor: 'white',
            paper_bgcolor: 'white'
        };
        
        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'select2d'],
            displaylogo: false
        };
        
        // *** ESTA LÍNEA FALTABA ***
        Plotly.newPlot('deconvolutionDerivativesPlot', traces, layout, config);
    }


        function updateMainDeconvolutionPlot() {
            const traces = [];
            
            // Show baseline-corrected spectrum (the one actually used for analysis)
            if (deconvolutionResults.correctedSpectrum) {
                traces.push({
                    x: deconvolutionResults.correctedSpectrum.frequency,
                    y: deconvolutionResults.correctedSpectrum.transmittance,
                    name: 'Baseline-Corrected Spectrum',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#2c3e50', width: 3 },
                    hovertemplate: '<b>Baseline-Corrected Spectrum</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<br><i>Data used for deconvolution</i><extra></extra>'
                });
            }
            
            // Show original spectrum (dotted) for comparison
            if (deconvolutionResults.originalSpectrum) {
                traces.push({
                    x: deconvolutionResults.originalSpectrum.frequency,
                    y: deconvolutionResults.originalSpectrum.transmittance,
                    name: 'Original Spectrum',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#95a5a6', width: 2, dash: 'dot' },
                    opacity: 0.6,
                    hovertemplate: '<b>Original Spectrum</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Transmittance: %{y:.4f}<br><i>Before baseline correction</i><extra></extra>'
                });
            }
            
            // Show calculated baseline
            if (deconvolutionResults.baseline) {
                traces.push({
                    x: deconvolutionResults.baseline.frequency,
                    y: deconvolutionResults.baseline.values,
                    name: 'Calculated Baseline',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#e67e22', width: 2, dash: 'dash' },
                    hovertemplate: '<b>Calculated Baseline</b><br>Wavenumber: %{x:.1f} cm⁻¹<br>Baseline Value: %{y:.4f}<br><i>Same as oxidation analysis</i><extra></extra>'
                });
            }
            
            // Fitted spectrum (nueva lógica)
            if (deconvolutionResults.fittedTrace) {
                traces.push({
                    x: deconvolutionResults.fittedTrace.x,
                    y: deconvolutionResults.fittedTrace.y,
                    name: 'Fitted Spectrum',
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#e74c3c', width: 2, dash: 'dash' }
                });
}
            
            // Individual species
            if (Array.isArray(deconvolutionResults.individualTraces)) {
                traces.push(...deconvolutionResults.individualTraces);
            }
            
            
            
            
        }

        function generateSpeciesTrace(speciesData, speciesId) {
            const freq = deconvolutionResults.originalSpectrum.frequency;
            const speciesIntensity = [];

            // Obtener parámetros optimizados O fallback
            const opt = window.optimizedParams?.[speciesId] || {};
            const centerFreq       = opt.frequency       ?? speciesData.frequency;
            const width            = opt.width           ?? speciesData.width;
            const intensity        = opt.intensity       ?? speciesData.intensity;
            const lorentzFraction  = opt.lorentzianContrib
                                ?? (CARBONYL_SPECIES[speciesId]?.lorentzianContrib ?? 0.9);

            for (let idx = 0; idx < freq.length; idx++) {
                // Cálculo mixto con parámetros correctos
                const raw = calculateMixedGaussianLorentzianValue(
                    freq[idx], centerFreq, intensity, width, lorentzFraction
                );
                // Clampear NEGATIVOS
                speciesIntensity.push(Math.max(0, raw));
            }

            // Conversión de color a RGBA (igual al anterior)
            let fillColor = speciesData.color;
            if (/^#[0-9A-Fa-f]{6}$/.test(fillColor)) {
                const r = parseInt(fillColor.slice(1,3),16);
                const g = parseInt(fillColor.slice(3,5),16);
                const b = parseInt(fillColor.slice(5,7),16);
                fillColor = `rgba(${r},${g},${b},0.4)`;
            } else if (fillColor.startsWith('rgb')) {
                fillColor = fillColor.replace('rgb','rgba').replace(')',',0.4)');
            }

            // Hovertemplate (sin cambios relevantes)
            return {
                x: freq,
                y: speciesIntensity,
                name: speciesData.name,
                type: 'scatter',
                mode: 'lines',
                line: { color: speciesData.color, width: 3 },
                fill: 'tonexty',
                fillcolor: fillColor,
                hovertemplate:
                    `<b>${speciesData.name}</b><br>` +
                    `Frequency: %{x:.1f} cm⁻¹<br>` +
                    `Intensity: %{y:.4f}<br>` +
                    `Optimized Peak: ${centerFreq.toFixed(1)} cm⁻¹<br>` +
                    `Width: ${width.toFixed(1)} cm⁻¹<br>` +
                    `Lorentzian: ${(lorentzFraction*100).toFixed(1)}%<extra></extra>`
            };
        }


        function updateFitQualityDisplay() {
            const fq = deconvolutionResults.fitQuality || {};
            let el = document.getElementById('deconvR2Value');
            if (el) el.textContent = fq.r2 ? fq.r2.toFixed(4) : '--';
            el = document.getElementById('deconvAreaError');
            if (el) el.textContent = fq.areaError ? fq.areaError.toExponential(2) : '--';
            el = document.getElementById('deconvDiscrepancy');
            if (el) el.textContent = fq.discrepancy ? fq.discrepancy.toFixed(4) : '--';
            el = document.getElementById('deconvConvergence');
            if (el) el.textContent = fq.convergence || '--';
            }

            // Función auxiliar para calcular el área en la banda de 2000-2040 cm⁻¹
            function calculateReferenceBandArea() {
                // Obtener datos de espectro post-offset desde AppState
                const allSpectra = window.AppState.spectraData;
                // Elegir un espectro de referencia (por ejemplo, el primero cargado)
                const firstKey = Object.keys(allSpectra)[0];
                if (!firstKey) {
                    console.error("No hay espectros disponibles en AppState.spectraData");
                    return 1; // fallback por si no hay datos
                }
                
                // Obtener pares [x, y] de frecuencia y transmittancia (ya corregida por offset)
                const freq = allSpectra[firstKey].frequency;
                const trans = allSpectra[firstKey].transmittance; // Estos datos ya incluyen la corrección de offset
                if (!freq || !trans || freq.length === 0 || trans.length === 0) {
                    console.error("Espectro de referencia inválido");
                    return 1;
                }

                // Empaquetar datos en forma [[x,y], ...]
                const spectraData = freq.map((x, i) => [x, trans[i]]);

                // Definir el rango de integración ampliado: 2000-2040 cm⁻¹
                const lowerBound = 2000;
                const upperBound = 2040;

                // Filtrar datos dentro del rango
                const filtered = spectraData.filter(([x, y]) => x >= lowerBound && x <= upperBound);

                if (filtered.length < 3) {
                    console.warn("Not enough data points in spectrumData for reference band (2000-2040 cm⁻¹)");
                    return 1;
                }

                // Extraer arrays de frecuencias (X) y absorbancias (Y)
                const xValues = filtered.map(p => p[0]);
                const yValues = filtered.map(p => p[1]);

                // Línea base automática: interpolación lineal entre extremos
                const baselineStart = yValues[0];
                const baselineEnd = yValues[yValues.length - 1];
                const baseline = yValues.map((_, i) => {
                    const t = i / (yValues.length - 1);
                    return baselineStart * (1 - t) + baselineEnd * t;
                });

                // Restar la línea base
                const correctedY = yValues.map((y, i) => y - baseline[i]);

                // Calcular el área usando Simpson
                const area = calculateAreaSimpsonRule(xValues, correctedY);

                // Guardar en deconvolutionResults para referencia global
                deconvolutionResults.referenceArea2010 = area;

                return area;
            }

            // REEMPLAZAR completamente updateSpeciesQuantificationDisplay (línea ~1620)
            function updateSpeciesQuantificationDisplay() {
                const species = deconvolutionResults.species;
                const container = document.getElementById('speciesQuantificationResults');
                
                if (!species || Object.keys(species).length === 0) {
                    container.innerHTML = '<p class="text-muted text-center">Run deconvolution to see results</p>';
                    return;
                }
                
                // Calcular áreas con Simpson
                const simpsonAreas = calculateSpeciesAreasWithSimpson();
                
                if (Object.keys(simpsonAreas).length === 0) {
                    container.innerHTML = '<p class="text-danger text-center">Error calculating areas</p>';
                    return;
                }
                
                let html = '<div class="species-results">';
                
                // Calcular área total para porcentajes (usando Simpson)
                const totalSimpsonArea = Object.values(simpsonAreas).reduce((sum, s) => sum + s.simpsonArea, 0);
                
                // Calcular automáticamente el área de referencia en 2000-2040 cm⁻¹ (b)
                const referenceBand = calculateReferenceBandArea();

                // Añadir header con información de integración
                html += `
                <div class="mb-3 p-2 bg-light rounded">
                    <div class="row text-sm">
                        <div class="col-6">
                            <strong>Integration Method:</strong><br>
                            <span class="text-primary">Simpson's Rule</span>
                        </div>
                        <div class="col-6 text-end">
                            <strong>Total Area:</strong><br>
                            <span class="text-primary">${totalSimpsonArea.toFixed(3)}</span>
                        </div>
                    </div>
                    <div class="row text-sm mt-2">
                        <div class="col-12">
                            <strong>Reference Area (2000-2040 cm⁻¹):</strong>
                            <span class="text-primary">${referenceBand.toFixed(4)}</span>
                        </div>
                    </div>
                </div>`;
                
                // Ordenar especies por área Simpson descendente
                const sortedSpecies = Object.entries(simpsonAreas).sort(([,a], [,b]) => b.simpsonArea - a.simpsonArea);
                
                sortedSpecies.forEach(([speciesId, areaData]) => {
                    const percentage = totalSimpsonArea > 0 ? (areaData.simpsonArea / totalSimpsonArea) * 100 : 0;
                    
                    // Determinar ε según especie
                    let epsilon = 1;
                    const nameLower = areaData.name.toLowerCase();
                    if (nameLower.includes("carbox")) epsilon = 16800;
                    else if (nameLower.includes("ester") || nameLower.includes("aldehyde")) epsilon = 8110;
                    else if (nameLower.includes("gamma-ketoacids") && nameLower.includes("keto")) epsilon = 6880;
                    else if (nameLower.includes("gamma-ketoacids") && nameLower.includes("acid")) epsilon = 16800;
                    else if (nameLower.includes("ketone")) epsilon = 6880;

                    // Calcular concentración: C = IA / (ε * b)
                    const concentration = (areaData.simpsonArea / (epsilon * referenceBand));

                    // Determinar color del badge según concordancia
                    const getAccuracyBadge = (relativeError) => {
                        if (relativeError < 10) return 'bg-success';
                        if (relativeError < 25) return 'bg-warning';
                        return 'bg-danger';
                    };
                    
                    html += `
                    <div class="species-result-item mb-3 p-2 border rounded" style="border-left: 4px solid ${areaData.color} !important;">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <div class="d-flex align-items-center">
                                <span class="color-indicator rounded-circle me-2" 
                                    style="background-color: ${areaData.color}; width: 12px; height: 12px; display: inline-block;"></span>
                                <strong class="species-name">${areaData.name}</strong>
                            </div>
                            <div class="text-end">
                                <span class="badge bg-primary fs-6">${percentage.toFixed(1)}%</span>
                            </div>
                        </div>
                        
                        <!-- Progress bar -->
                        <div class="progress mb-2" style="height: 6px;">
                            <div class="progress-bar" role="progressbar" 
                                style="width: ${percentage}%; background-color: ${areaData.color};" 
                                aria-valuenow="${percentage}" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                        
                        <!-- Simpson Area only -->
                        <div class="row text-sm">
                            <div class="col-6">
                                <div><strong>Simpson Area:</strong> ${areaData.simpsonArea.toFixed(4)}</div>
                                <div class="mt-1"><strong>Freq:</strong> ${areaData.frequency.toFixed(1)} cm⁻¹</div>
                            </div>
                            <div class="col-6 text-end">
                                <div><strong>Parameters:</strong></div>
                                <div class="text-muted">I: ${areaData.intensity.toFixed(3)}, W: ${areaData.width.toFixed(1)}</div>
                                <div class="text-primary"><strong>L:</strong> ${areaData.lorentzian.toFixed(1)}%</div>
                            </div>
                        </div>

                        <!-- Cálculo de concentración -->
                        <div class="mt-2">
                            <strong>Concentration (C):</strong> 
                            <span class="badge bg-info text-dark">${concentration.toExponential(3)} mol/cm³</span>
                            <div class="text-muted">ε = ${epsilon}, b = ${referenceBand.toFixed(4)}</div>
                        </div>
                        
                        
                    </div>`;
                });
                
                // Añadir resumen estadístico
                const avgError = sortedSpecies.reduce((sum, [,data]) => sum + data.relativeError, 0) / sortedSpecies.length;
                const maxError = Math.max(...sortedSpecies.map(([,data]) => data.relativeError));
                
                
                
                html += '</div>';
                container.innerHTML = html;
            }

            // AÑADIR después de updateSpeciesQuantificationDisplay (línea ~1620)
            function calculateSpeciesAreasWithSimpson() {
                if (!deconvolutionResults.species || !deconvolutionResults.originalSpectrum) {
                    return {};
                }
                
                const freq = deconvolutionResults.originalSpectrum.frequency;
                const speciesAreas = {};
                
                console.log("=== INTEGRACIÓN CON REGLA DE SIMPSON ===");
                
                // Calcular área de cada especie usando Simpson
                for (const [speciesId, speciesData] of Object.entries(deconvolutionResults.species)) {
                    // Generar el trace individual de la especie
                    const speciesTrace = generateSpeciesTrace(speciesData, speciesId);
                    const speciesTransmittance = speciesTrace.y;
                    
                    // Usar la función existente de Simpson del código
                    const simpsonArea = calculateAreaSimpsonRule(freq, speciesTransmittance);
                    
                    // Get optimized lorentzian fraction or use default
                    const opt = window.optimizedParams?.[speciesId] || {};
                    const lorentzFraction = opt.lorentzianContrib ?? (CARBONYL_SPECIES[speciesId]?.lorentzianContrib ?? 0.9);
                    const optimizedFreq = opt.frequency ?? speciesData.frequency ?? CARBONYL_SPECIES[speciesId]?.freq ?? 0;
                    const initialFreq = CARBONYL_SPECIES[speciesId]?.freq ?? optimizedFreq;
                    
                    // Calcular área teórica para comparación
                    const theoreticalArea = calculateMixedArea(
                        speciesData.intensity,
                        speciesData.width,
                        lorentzFraction
                    );
                    
                    speciesAreas[speciesId] = {
                        simpsonArea: Math.abs(simpsonArea), // Asegurar valor positivo
                        theoreticalArea: theoreticalArea,
                        name: speciesData.name,
                        color: speciesData.color,
                        intensity: speciesData.intensity,
                        width: speciesData.width,
                        lorentzian: lorentzFraction * 100, // Percentage for display
                        frequency: optimizedFreq, // Optimized frequency
                        initialFrequency: initialFreq, // Initial frequency for comparison
                        // Métricas de concordancia
                        absoluteError: Math.abs(simpsonArea - theoreticalArea),
                        relativeError: theoreticalArea > 0 ? Math.abs((simpsonArea - theoreticalArea) / theoreticalArea) * 100 : 0
                    };
                    
                    console.log(`${speciesData.name}:`);
                    console.log(`  - Área Simpson: ${Math.abs(simpsonArea).toFixed(4)}`);
                    console.log(`  - Área teórica: ${theoreticalArea.toFixed(4)}`);
                    console.log(`  - Error relativo: ${speciesAreas[speciesId].relativeError.toFixed(1)}%`);
                    console.log(`  - Lorentziano: ${(lorentzFraction * 100).toFixed(1)}%`);
                }
                
                return speciesAreas;
            }

            // AÑADIR función de validación después de calculateSpeciesAreasWithSimpson
            function validateSimpsonIntegration() {
                if (!deconvolutionResults.species || !deconvolutionResults.fittedTrace) {
                    console.warn("No hay datos disponibles para validar integración");
                    return false;
                }
                
                const freq = deconvolutionResults.originalSpectrum.frequency;
                const fittedTrans = deconvolutionResults.fittedTrace.y;
                
                // Integrar el espectro ajustado completo con Simpson
                const totalFittedArea = calculateAreaSimpsonRule(freq, fittedTrans);
                
                // Sumar áreas individuales calculadas con Simpson
                const simpsonAreas = calculateSpeciesAreasWithSimpson();
                const sumIndividualAreas = Object.values(simpsonAreas).reduce((sum, s) => sum + s.simpsonArea, 0);
                
                const difference = Math.abs(totalFittedArea - sumIndividualAreas);
                const relativeDifference = totalFittedArea > 0 ? (difference / Math.abs(totalFittedArea)) * 100 : 0;
                
                console.log("=== INTEGRATION VALIDATION ===");
                console.log(`Total fitted area: ${totalFittedArea.toFixed(4)}`);
                console.log(`Sum of individual areas: ${sumIndividualAreas.toFixed(4)}`);
                console.log(`Absolute difference: ${difference.toFixed(4)}`);
                console.log(`Relative difference: ${relativeDifference.toFixed(2)}%`);
                
                // Validación exitosa si la diferencia es menor al 5%
                return relativeDifference < 5.0;
            }

            function resetDeconvolution() {
                deconvolutionResults = {
                    species: {},
                    fitQuality: {},
                    derivatives: {},
                    originalSpectrum: null,
                    fittedTrace: null,
                    individualTraces: []
                };
            


            
            // Clear plots
            Plotly.newPlot('deconvolutionDerivativesPlot', [], {});
            Plotly.newPlot('deconvolutionMainPlot', [], {});
            
            // Reset fit quality display
            document.getElementById('deconvR2Value').textContent = '--';
            document.getElementById('deconvDiscrepancy').textContent = '--';
            document.getElementById('deconvConvergence').textContent = '--';
            
            // Reset species quantification
            document.getElementById('speciesQuantificationResults').innerHTML = '<p class="text-muted text-center">Run deconvolution to see results</p>';
            
            showNotification('Deconvolution analysis reset', 'info');
        }

        // Add species interaction handlers and file load monitoring
        document.addEventListener('DOMContentLoaded', function() {
            // Add click handlers for species items
            const speciesItems = document.querySelectorAll('.species-item');
            speciesItems.forEach(item => {
                item.addEventListener('click', function() {
                    const speciesId = this.dataset.species;
                    toggleSpeciesVisibility(speciesId);
                });
            });
            
            // Monitor for file loading to update depth selector
            const originalProcessMultiFileData = window.processMultiFileData;
            if (originalProcessMultiFileData) {
                window.processMultiFileData = function(...args) {
                    const result = originalProcessMultiFileData.apply(this, args);
                    // Update depth selector after file is loaded
                    setTimeout(() => {
                        populateDepthSelector();
                    }, 500);
                    return result;
                };
            }
            
            // Also monitor for tab activation to update selector
            document.addEventListener('shown.bs.tab', function(event) {
                if (event.target.id === 'deconvolution-tab') {
                    setTimeout(() => {
                        populateDepthSelector();
                    }, 100);
                }
            });
        });

        function toggleSpeciesVisibility(speciesId) {
            const speciesItem = document.querySelector(`[data-species="${speciesId}"]`);
            speciesItem.classList.toggle('active');
            
            // Update plot visibility
            if (deconvolutionResults.species[speciesId]) {
                // Toggle visibility in plot
                const plotElement = document.getElementById('deconvolutionMainPlot');
                if (plotElement.data) {
                    const traces = plotElement.data;
                    const speciesTrace = traces.find(trace => trace.name === CARBONYL_SPECIES[speciesId].name);
                    if (speciesTrace) {
                        const update = { visible: speciesItem.classList.contains('active') ? true : 'legendonly' };
                        Plotly.restyle('deconvolutionMainPlot', update, traces.indexOf(speciesTrace));
                    }
                }
            }
        }

        // MULTIPLE DECONVOLUTION FUNCTIONS
        let multipleDeconvResults = [];

        async function runMultipleDeconvolution() {
            const runBtn = document.getElementById('runMultipleDeconvBtn');
            const progressDiv = document.getElementById('multiDeconvProgress');
            const progressBar = document.getElementById('multiDeconvProgressBar');
            const progressText = document.getElementById('multiDeconvProgressText');
            
            try {
                runBtn.disabled = true;
                runBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Processing...';
                progressDiv.style.display = 'block';
                
                // Get all available depths
                const spectraData = window.AppState.spectraData;
                if (!spectraData || Object.keys(spectraData).length === 0) {
                    throw new Error('No spectra data available. Please load data first.');
                }
                
                const depths = Object.keys(spectraData).sort((a, b) => {
                    const numA = parseFloat(a.replace(/[^\d.]/g, ''));
                    const numB = parseFloat(b.replace(/[^\d.]/g, ''));
                    return numA - numB;
                });
                
                // Get parameters from individual deconvolution controls
                const minFreq = parseFloat(document.getElementById('deconvMinFreq').value);
                const maxFreq = parseFloat(document.getElementById('deconvMaxFreq').value);
                const refBand = parseFloat(document.getElementById('deconvRefBand').value);
                
                multipleDeconvResults = [];
                
                // Process each depth
                for (let i = 0; i < depths.length; i++) {
                    const depth = depths[i];
                    const progress = ((i + 1) / depths.length) * 100;
                    progressBar.style.width = progress + '%';
                    progressText.textContent = `Processing ${depth} (${i + 1}/${depths.length})...`;
                    
                    try {
                        // Process this depth using existing functions
                        const result = await processDepthDeconvolution(depth, minFreq, maxFreq, refBand);
                        multipleDeconvResults.push(result);
                    } catch (error) {
                        console.error(`Error processing depth ${depth}:`, error);
                        multipleDeconvResults.push({
                            depth: depth,
                            error: error.message,
                            concentrations: {},
                            r2: null
                        });
                    }
                    
                    // Small delay to allow UI updates
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Update UI with results
                updateMultipleDeconvolutionPlot();
                updateMultipleDeconvolutionTable();
                
                // Enable export buttons
                document.getElementById('exportMultiDeconvPdfBtn').disabled = false;
                document.getElementById('exportMultiDeconvExcelBtn').disabled = false;
                
                progressDiv.style.display = 'none';
                showNotification(`Multiple deconvolution completed for ${depths.length} depths!`, 'success');
                
            } catch (error) {
                console.error('Multiple deconvolution error:', error);
                showNotification('Error in multiple deconvolution: ' + error.message, 'error');
                progressDiv.style.display = 'none';
            } finally {
                runBtn.disabled = false;
                runBtn.innerHTML = '<i class="fas fa-play-circle me-2"></i>Run Multiple Deconvolution';
            }
        }

        async function processDepthDeconvolution(depth, minFreq, maxFreq, refBand) {
            const spectraData = window.AppState.spectraData;
            const currentSpectrum = spectraData[depth];
            
            if (!currentSpectrum) {
                throw new Error(`No spectrum data for depth ${depth}`);
            }
            
            // Use original transmittance if offset correction was applied
            const spectrumToUse = currentSpectrum.originalTransmittance ? {
                ...currentSpectrum,
                transmittance: currentSpectrum.originalTransmittance
            } : currentSpectrum;
            
            // Extract carbonyl region (using existing function)
            const carbonylRegion = extractSpectralRegion(spectrumToUse, minFreq, maxFreq);
            
            // Normalize spectrum (using existing function)
            const normalizedSpectrum = normalizeSpectrum(carbonylRegion, spectrumToUse, refBand);
            
            // Calculate derivatives (using existing function)
            const derivatives = calculateDerivatives(normalizedSpectrum);
            
            // Perform baseline correction (using existing function)
            const baselineCorrected = automaticBaselineCorrection(normalizedSpectrum);
            
            // Perform curve fitting (using existing function)
            const fittingResults = await performCurveFitting(baselineCorrected, derivatives);
            
            // Calculate reference band area for thickness (2000-2040 cm⁻¹)
            const referenceBandArea = calculateReferenceBandAreaForDepth(spectrumToUse);
            
            // Calculate concentrations for each species
            const concentrations = {};
            const freq = baselineCorrected.frequency;
            
            for (const [speciesId, speciesData] of Object.entries(fittingResults.species)) {
                // Generate species trace (using existing function)
                const speciesTrace = generateSpeciesTrace(speciesData, speciesId);
                
                // Calculate area using Simpson's rule (using existing function)
                const simpsonArea = calculateAreaSimpsonRule(freq, speciesTrace.y);
                
                // Determine epsilon according to species
                let epsilon = 1;
                const nameLower = speciesData.name.toLowerCase();
                if (nameLower.includes("carbox")) epsilon = 16800;
                else if (nameLower.includes("ester") || nameLower.includes("aldehyde")) epsilon = 8110;
                else if (nameLower.includes("gamma-ketoacids") && nameLower.includes("keto")) epsilon = 6880;
                else if (nameLower.includes("gamma-ketoacids") && nameLower.includes("acid")) epsilon = 16800;
                else if (nameLower.includes("ketone")) epsilon = 6880;
                
                // Calculate concentration: C = IA / (ε * b)
                // Convert to mmol/cm³ by multiplying by 1000
                const concentration = (Math.abs(simpsonArea) / (epsilon * referenceBandArea)) * 1000;
                
                concentrations[speciesId] = {
                    name: speciesData.name,
                    concentration: concentration,
                    area: Math.abs(simpsonArea),
                    epsilon: epsilon
                };
            }
            
            return {
                depth: depth,
                concentrations: concentrations,
                r2: fittingResults.fitQuality.r2 || 0,
                referenceBandArea: referenceBandArea
            };
        }

        function calculateReferenceBandAreaForDepth(spectrum) {
            // Calculate area in 2000-2040 cm⁻¹ range for this specific depth
            const freq = spectrum.frequency;
            const trans = spectrum.transmittance;
            
            if (!freq || !trans || freq.length === 0) {
                return 1; // fallback
            }
            
            const lowerBound = 2000;
            const upperBound = 2040;
            
            // Filter data within range
            const filtered = freq.map((x, i) => [x, trans[i]]).filter(([x, y]) => x >= lowerBound && x <= upperBound);
            
            if (filtered.length < 3) {
                console.warn(`Not enough data points for reference band at depth`);
                return 1;
            }
            
            const xValues = filtered.map(p => p[0]);
            const yValues = filtered.map(p => p[1]);
            
            // Automatic baseline: linear interpolation between endpoints
            const baselineStart = yValues[0];
            const baselineEnd = yValues[yValues.length - 1];
            const baseline = yValues.map((_, i) => {
                const t = i / (yValues.length - 1);
                return baselineStart * (1 - t) + baselineEnd * t;
            });
            
            // Subtract baseline
            const correctedY = yValues.map((y, i) => y - baseline[i]);
            
            // Calculate area using Simpson's rule
            const area = calculateAreaSimpsonRule(xValues, correctedY);
            
            return Math.abs(area);
        }

        function updateMultipleDeconvolutionPlot() {
            const plotDiv = document.getElementById('multiDeconvPlot');
            
            if (!multipleDeconvResults || multipleDeconvResults.length === 0) {
                Plotly.newPlot(plotDiv, [], {});
                return;
            }
            
            // Extract depth values (numeric)
            const depths = multipleDeconvResults.map(r => {
                const numericDepth = parseFloat(r.depth.replace(/[^\d.]/g, ''));
                return numericDepth;
            });
            
            // Prepare traces for each species
            const traces = [];
            const speciesColors = {
                'ketones': '#3498db',
                'carboxylic_acids': '#2ecc71',
                'esters_aldehydes': '#e74c3c'
            };
            
            // Create a trace for each species
            for (const speciesId in CARBONYL_SPECIES) {
                const concentrations = multipleDeconvResults.map(r => {
                    const conc = r.concentrations[speciesId];
                    return conc ? conc.concentration : 0;
                });
                
                traces.push({
                    x: depths,
                    y: concentrations,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: CARBONYL_SPECIES[speciesId].name,
                    line: {
                        color: speciesColors[speciesId] || CARBONYL_SPECIES[speciesId].color,
                        width: 3
                    },
                    marker: {
                        size: 8,
                        color: speciesColors[speciesId] || CARBONYL_SPECIES[speciesId].color
                    }
                });
            }
            
            const layout = {
                title: {
                    text: 'Carbonyl Species Concentration vs Depth',
                    font: { size: 18, weight: 'bold' }
                },
                xaxis: {
                    title: 'Depth (μm)',
                    showgrid: true,
                    gridcolor: 'rgba(128,128,128,0.2)'
                },
                yaxis: {
                    title: 'Concentration (mmol/cm³)',
                    showgrid: true,
                    gridcolor: 'rgba(128,128,128,0.2)'
                },
                margin: { l: 80, r: 40, t: 80, b: 60 },
                hovermode: 'closest',
                legend: {
                    x: 1.02,
                    y: 1,
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: '#ddd',
                    borderwidth: 1
                },
                plot_bgcolor: 'rgba(248, 249, 250, 0.6)',
                paper_bgcolor: 'white'
            };
            
            const config = { responsive: true };
            
            Plotly.newPlot(plotDiv, traces, layout, config);
        }

        function updateMultipleDeconvolutionTable() {
            const tbody = document.getElementById('multiDeconvTableBody');
            
            if (!multipleDeconvResults || multipleDeconvResults.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">Run multiple deconvolution to see results</td></tr>';
                return;
            }
            
            let html = '';
            
            multipleDeconvResults.forEach(result => {
                const gammaKeto = result.concentrations.gamma_ketoacids_keto?.concentration || 0;
                const gammaAcid = result.concentrations.gamma_ketoacids_acid?.concentration || 0;
                const carboxylic = result.concentrations.carboxylic_acids?.concentration || 0;
                const ketones = result.concentrations.ketones?.concentration || 0;
                const esters = result.concentrations.esters_aldehydes?.concentration || 0;
                const carboxylicIsolated = result.concentrations.carboxylic_acids_isolated?.concentration || 0;
                const r2 = result.r2 ? result.r2.toFixed(4) : '--';
                
                // Color code R² values
                let r2Class = '';
                if (result.r2 >= 0.95) r2Class = 'text-success fw-bold';
                else if (result.r2 >= 0.90) r2Class = 'text-warning fw-bold';
                else if (result.r2) r2Class = 'text-danger fw-bold';
                
                html += `
                    <tr>
                        <td class="fw-bold">${result.depth}</td>
                        <td>${gammaKeto.toExponential(3)}</td>
                        <td>${gammaAcid.toExponential(3)}</td>
                        <td>${carboxylic.toExponential(3)}</td>
                        <td>${ketones.toExponential(3)}</td>
                        <td>${esters.toExponential(3)}</td>
                        <td>${carboxylicIsolated.toExponential(3)}</td>
                        <td class="${r2Class}">${r2}</td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }

        function resetMultipleDeconvolution() {
            multipleDeconvResults = [];
            
            // Clear plot
            Plotly.newPlot('multiDeconvPlot', [], {});
            
            // Clear table
            const tbody = document.getElementById('multiDeconvTableBody');
            tbody.innerHTML = '<tr><td colspan="8" class="text-center text-muted">Run multiple deconvolution to see results</td></tr>';
            
            // Hide progress bar
            document.getElementById('multiDeconvProgress').style.display = 'none';
            document.getElementById('multiDeconvProgressBar').style.width = '0%';
            
            // Disable export buttons
            document.getElementById('exportMultiDeconvPdfBtn').disabled = true;
            document.getElementById('exportMultiDeconvExcelBtn').disabled = true;
            
            showNotification('Multiple deconvolution results cleared', 'info');
        }

        // EXPORT FUNCTIONS FOR MULTIPLE DECONVOLUTION
        async function exportMultipleDeconvolutionToPDF() {
            if (!multipleDeconvResults || multipleDeconvResults.length === 0) {
                showNotification('No results to export. Please run multiple deconvolution first.', 'warning');
                return;
            }
            
            try {
                showLoading('Generating PDF report...');
                
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                // Add title
                pdf.setFontSize(18);
                pdf.setFont(undefined, 'bold');
                pdf.text('Multiple Carbonyl Deconvolution Report', 105, 20, { align: 'center' });
                
                // Add date
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'normal');
                const date = new Date().toLocaleString();
                pdf.text(`Generated: ${date}`, 105, 28, { align: 'center' });
                
                // Capture the plot as image
                const plotDiv = document.getElementById('multiDeconvPlot');
                const plotImage = await Plotly.toImage(plotDiv, { format: 'png', width: 800, height: 500 });
                
                // Add plot to PDF
                pdf.addImage(plotImage, 'PNG', 15, 35, 180, 110);
                
                // Add table
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.text('Concentration Data Table', 15, 155);
                
                // Prepare table data
                const tableData = [];
                multipleDeconvResults.forEach(result => {
                    const gammaKeto = result.concentrations.gamma_ketoacids_keto?.concentration || 0;
                    const gammaAcid = result.concentrations.gamma_ketoacids_acid?.concentration || 0;
                    const carboxylic = result.concentrations.carboxylic_acids?.concentration || 0;
                    const ketones = result.concentrations.ketones?.concentration || 0;
                    const esters = result.concentrations.esters_aldehydes?.concentration || 0;
                    const carboxylicIsolated = result.concentrations.carboxylic_acids_isolated?.concentration || 0;
                    const r2 = result.r2 ? result.r2.toFixed(4) : '--';
                    
                    tableData.push([
                        result.depth,
                        gammaKeto.toExponential(3),
                        gammaAcid.toExponential(3),
                        carboxylic.toExponential(3),
                        ketones.toExponential(3),
                        esters.toExponential(3),
                        carboxylicIsolated.toExponential(3),
                        r2
                    ]);
                });
                
                // Add table to PDF using autoTable
                if (typeof pdf.autoTable === 'function') {
                    pdf.autoTable({
                        startY: 160,
                        head: [['Depth', 'Gamma-keto\nketo', 'Gamma-keto\nacid', 'Carbox.\nassoc.', 'Ketones', 'Esters &\nAldeh.', 'Carbox.\nisolated', 'R²']],
                        body: tableData,
                        theme: 'striped',
                        styles: { fontSize: 7, cellPadding: 1.5 },
                        headStyles: { fillColor: [102, 126, 234], fontStyle: 'bold' }
                    });
                } else {
                    // Fallback if autoTable is not available
                    pdf.setFontSize(8);
                    let y = 165;
                    pdf.text('Depth | Gamma-keto(keto) | Gamma-keto(acid) | Carbox.assoc. | Ketones | Esters | Carbox.isolated | R²', 15, y);
                    y += 5;
                    tableData.forEach(row => {
                        pdf.text(row.join(' | '), 15, y);
                        y += 5;
                        if (y > 280) {
                            pdf.addPage();
                            y = 15;
                        }
                    });
                }
                
                // Save PDF
                pdf.save('Multiple_Deconvolution_Report.pdf');
                
                hideLoading();
                showNotification('PDF report exported successfully!', 'success');
                
            } catch (error) {
                console.error('Error exporting PDF:', error);
                hideLoading();
                showNotification('Error exporting PDF: ' + error.message, 'error');
            }
        }

        async function exportMultipleDeconvolutionToExcel() {
            if (!multipleDeconvResults || multipleDeconvResults.length === 0) {
                showNotification('No results to export. Please run multiple deconvolution first.', 'warning');
                return;
            }
            
            try {
                showLoading('Generating Excel file...');
                
                // Prepare data for Excel
                const excelData = [];
                
                // Add headers
                excelData.push([
                    'Depth',
                    'Gamma-ketoacids keto (mmol/cm³)',
                    'Gamma-ketoacids acid (mmol/cm³)',
                    'Carboxylic Acids assoc. (mmol/cm³)',
                    'Ketones (mmol/cm³)',
                    'Esters & Aldehydes (mmol/cm³)',
                    'Carboxylic Acids isolated (mmol/cm³)',
                    'R²',
                    'Reference Band Area',
                    'Gamma-ketoacids keto Area',
                    'Gamma-ketoacids acid Area',
                    'Carboxylic Acids assoc. Area',
                    'Ketones Area',
                    'Esters & Aldehydes Area',
                    'Carboxylic Acids isolated Area'
                ]);
                
                // Add data rows
                multipleDeconvResults.forEach(result => {
                    const gammaKeto = result.concentrations.gamma_ketoacids_keto?.concentration || 0;
                    const gammaAcid = result.concentrations.gamma_ketoacids_acid?.concentration || 0;
                    const carboxylic = result.concentrations.carboxylic_acids?.concentration || 0;
                    const ketones = result.concentrations.ketones?.concentration || 0;
                    const esters = result.concentrations.esters_aldehydes?.concentration || 0;
                    const carboxylicIsolated = result.concentrations.carboxylic_acids_isolated?.concentration || 0;
                    const r2 = result.r2 || 0;
                    
                    const gammaKetoArea = result.concentrations.gamma_ketoacids_keto?.area || 0;
                    const gammaAcidArea = result.concentrations.gamma_ketoacids_acid?.area || 0;
                    const carboxylicArea = result.concentrations.carboxylic_acids?.area || 0;
                    const ketonesArea = result.concentrations.ketones?.area || 0;
                    const estersArea = result.concentrations.esters_aldehydes?.area || 0;
                    const carboxylicIsolatedArea = result.concentrations.carboxylic_acids_isolated?.area || 0;
                    
                    excelData.push([
                        result.depth,
                        gammaKeto,
                        gammaAcid,
                        carboxylic,
                        ketones,
                        esters,
                        carboxylicIsolated,
                        r2,
                        result.referenceBandArea || 0,
                        gammaKetoArea,
                        gammaAcidArea,
                        carboxylicArea,
                        ketonesArea,
                        estersArea,
                        carboxylicIsolatedArea
                    ]);
                });
                
                // Create workbook and worksheet
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.aoa_to_sheet(excelData);
                
                // Set column widths
                ws['!cols'] = [
                    { wch: 15 },  // Depth
                    { wch: 28 },  // Gamma-ketoacids keto
                    { wch: 28 },  // Gamma-ketoacids acid
                    { wch: 30 },  // Carboxylic Acids assoc.
                    { wch: 20 },  // Ketones
                    { wch: 28 },  // Esters & Aldehydes
                    { wch: 30 },  // Carboxylic Acids isolated
                    { wch: 12 },  // R²
                    { wch: 22 },  // Reference Band Area
                    { wch: 28 },  // Gamma-ketoacids keto Area
                    { wch: 28 },  // Gamma-ketoacids acid Area
                    { wch: 30 },  // Carboxylic Acids assoc. Area
                    { wch: 18 },  // Ketones Area
                    { wch: 28 },  // Esters & Aldehydes Area
                    { wch: 30 }   // Carboxylic Acids isolated Area
                ];
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Multiple Deconvolution');
                
                // Generate Excel file and download
                XLSX.writeFile(wb, 'Multiple_Deconvolution_Results.xlsx');
                
                hideLoading();
                showNotification('Excel file exported successfully!', 'success');
                
            } catch (error) {
                console.error('Error exporting Excel:', error);
                hideLoading();
                showNotification('Error exporting Excel: ' + error.message, 'error');
            }
        }
    </script>
</body>
</html>
